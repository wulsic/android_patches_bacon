From 3ab32a6a2da94c1738985f3edb5004372b15caff Mon Sep 17 00:00:00 2001
From: Hamster Tian <haotia@gmail.com>
Date: Fri, 26 Aug 2016 16:41:03 +0800
Subject: [PATCH 3/3] Remove unsupported HEVC code

Change-Id: Id2af6881be5ef99a2dc4c134949b0ff8f3b7e322
---
 msm8974/mm-video-v4l2/vidc/vdec/inc/omx_vdec.h     |   1 +
 .../vidc/vdec/src/omx_vdec_msm8974.cpp             | 167 ++------
 .../mm-video-v4l2/vidc/venc/inc/omx_video_base.h   |   1 +
 .../vidc/venc/src/video_encoder_device_v4l2.cpp    | 475 +--------------------
 4 files changed, 49 insertions(+), 595 deletions(-)

diff --git a/msm8974/mm-video-v4l2/vidc/vdec/inc/omx_vdec.h b/msm8974/mm-video-v4l2/vidc/vdec/inc/omx_vdec.h
index e3f5d8e..ab5ee4a 100644
--- a/msm8974/mm-video-v4l2/vidc/vdec/inc/omx_vdec.h
+++ b/msm8974/mm-video-v4l2/vidc/vdec/inc/omx_vdec.h
@@ -186,6 +186,7 @@ class VideoHeap : public MemoryHeapBase
 #define MAX_NUM_INPUT_OUTPUT_BUFFERS 64
 #endif
 
+#define _ION_HEAP_MASK_COMPATIBILITY_WA
 #ifdef _ION_HEAP_MASK_COMPATIBILITY_WA
     #define ION_HEAP_MASK heap_mask
 #else
diff --git a/msm8974/mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp b/msm8974/mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp
index 1f898a3..861152c 100644
--- a/msm8974/mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp
+++ b/msm8974/mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp
@@ -129,7 +129,7 @@ extern "C" {
 #define ALIGN(x, to_align) ((((unsigned) x) + (to_align - 1)) & ~(to_align - 1))
 
 #ifndef DISABLE_EXTRADATA
-#define DEFAULT_EXTRADATA (OMX_INTERLACE_EXTRADATA | OMX_VUI_DISPLAY_INFO_EXTRADATA)
+#define DEFAULT_EXTRADATA (OMX_INTERLACE_EXTRADATA)
 #endif
 
 #define DEFAULT_CONCEAL_COLOR "32784" //0x8010, black by default
@@ -245,15 +245,6 @@ void* async_message_thread (void *input)
                     DEBUG_PRINT_HIGH("async_message_thread Exited");
                     break;
                 }
-            } else if (dqevent.type == V4L2_EVENT_MSM_VIDC_HW_UNSUPPORTED) {
-                struct vdec_msginfo vdec_msg;
-                vdec_msg.msgcode=VDEC_MSG_EVT_HW_UNSUPPORTED;
-                vdec_msg.status_code=VDEC_S_SUCCESS;
-                DEBUG_PRINT_ERROR("HW Unsupported received");
-                if (omx->async_message_process(input,&vdec_msg) < 0) {
-                    DEBUG_PRINT_HIGH("async_message_thread Exited");
-                    break;
-                }
             } else if (dqevent.type == V4L2_EVENT_MSM_VIDC_SYS_ERROR) {
                 struct vdec_msginfo vdec_msg;
                 vdec_msg.msgcode=VDEC_MSG_EVT_HW_ERROR;
@@ -721,8 +712,7 @@ static const int event_type[] = {
     V4L2_EVENT_MSM_VIDC_RELEASE_UNQUEUED_BUFFER,
     V4L2_EVENT_MSM_VIDC_CLOSE_DONE,
     V4L2_EVENT_MSM_VIDC_SYS_ERROR,
-    V4L2_EVENT_MSM_VIDC_HW_OVERLOAD,
-    V4L2_EVENT_MSM_VIDC_HW_UNSUPPORTED
+    V4L2_EVENT_MSM_VIDC_HW_OVERLOAD
 };
 
 static OMX_ERRORTYPE subscribe_to_events(int fd)
@@ -1775,15 +1765,6 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
         codec_type_parse = CODEC_TYPE_H264;
         m_frame_parser.init_start_codes (codec_type_parse);
         m_frame_parser.init_nal_length(nal_length);
-    } else if (!strncmp(drv_ctx.kind, "OMX.qcom.video.decoder.mvc",\
-                OMX_MAX_STRINGNAME_SIZE)) {
-        strlcpy((char *)m_cRole, "video_decoder.mvc", OMX_MAX_STRINGNAME_SIZE);
-        drv_ctx.decoder_format = VDEC_CODECTYPE_MVC;
-        output_capability = V4L2_PIX_FMT_H264_MVC;
-        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingMVC;
-        codec_type_parse = CODEC_TYPE_H264;
-        m_frame_parser.init_start_codes(codec_type_parse);
-        m_frame_parser.init_nal_length(nal_length);
     } else if (!strncmp(drv_ctx.kind, "OMX.qcom.video.decoder.hevc",\
                 OMX_MAX_STRINGNAME_SIZE)) {
         strlcpy((char *)m_cRole, "video_decoder.hevc",OMX_MAX_STRINGNAME_SIZE);
@@ -1954,15 +1935,6 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
                 return OMX_ErrorInsufficientResources;
             }
         }
-        if (output_capability == V4L2_PIX_FMT_H264_MVC) {
-            control.id = V4L2_CID_MPEG_VIDC_VIDEO_MVC_BUFFER_LAYOUT;
-            control.value = V4L2_MPEG_VIDC_VIDEO_MVC_TOP_BOTTOM;
-            ret=ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL,&control);
-            if (ret) {
-                DEBUG_PRINT_ERROR("Failed to set MVC buffer layout");
-                return OMX_ErrorInsufficientResources;
-            }
-        }
 
         /*Get the Buffer requirements for input and output ports*/
         drv_ctx.ip_buf.buffer_type = VDEC_BUFFER_TYPE_INPUT;
@@ -2004,8 +1976,7 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
         DEBUG_PRINT_HIGH("Input Buffer Size =%u",(unsigned int)drv_ctx.ip_buf.buffer_size);
         get_buffer_req(&drv_ctx.op_buf);
         if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 ||
-                drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC ||
-                drv_ctx.decoder_format == VDEC_CODECTYPE_MVC) {
+                drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC) {
                     h264_scratch.nAllocLen = drv_ctx.ip_buf.buffer_size;
                     h264_scratch.pBuffer = (OMX_U8 *)malloc (drv_ctx.ip_buf.buffer_size);
                     h264_scratch.nFilledLen = 0;
@@ -2016,8 +1987,7 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
                         return OMX_ErrorInsufficientResources;
                     }
         }
-        if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 ||
-            drv_ctx.decoder_format == VDEC_CODECTYPE_MVC) {
+        if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) {
             if (m_frame_parser.mutils == NULL) {
                 m_frame_parser.mutils = new H264_Utils();
                 if (m_frame_parser.mutils == NULL) {
@@ -3362,42 +3332,6 @@ OMX_ERRORTYPE  omx_vdec::set_parameter(OMX_IN OMX_HANDLETYPE     hComp,
                                        if (eRet) {
                                            break;
                                        }
-
-                                       if (secure_mode) {
-                                           struct v4l2_control control;
-                                           control.id = V4L2_CID_MPEG_VIDC_VIDEO_SECURE_SCALING_THRESHOLD;
-                                           if (ioctl(drv_ctx.video_driver_fd, VIDIOC_G_CTRL, &control) < 0) {
-                                               DEBUG_PRINT_ERROR("Failed getting secure scaling threshold : %d, id was : %x", errno, control.id);
-                                               eRet = OMX_ErrorHardware;
-                                           } else {
-                                               /* This is a workaround for a bug in fw which uses stride
-                                                * and slice instead of width and height to check against
-                                                * the threshold.
-                                                */
-                                               OMX_U32 stride, slice;
-                                               if (drv_ctx.output_format == VDEC_YUV_FORMAT_NV12) {
-                                                   stride = VENUS_Y_STRIDE(COLOR_FMT_NV12, portDefn->format.video.nFrameWidth);
-                                                   slice = VENUS_Y_SCANLINES(COLOR_FMT_NV12, portDefn->format.video.nFrameHeight);
-                                               } else {
-                                                   stride = portDefn->format.video.nFrameWidth;
-                                                   slice = portDefn->format.video.nFrameHeight;
-                                               }
-
-                                               DEBUG_PRINT_LOW("Stride is %d, slice is %d, sxs is %d\n", stride, slice, stride * slice);
-                                               DEBUG_PRINT_LOW("Threshold value is %d\n", control.value);
-
-                                               if (stride * slice <= (OMX_U32)control.value) {
-                                                   secure_scaling_to_non_secure_opb = true;
-                                                   DEBUG_PRINT_HIGH("Enabling secure scalar out of CPZ");
-                                                   control.id = V4L2_CID_MPEG_VIDC_VIDEO_NON_SECURE_OUTPUT2;
-                                                   control.value = 1;
-                                                   if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control) < 0) {
-                                                       DEBUG_PRINT_ERROR("Enabling non-secure output2 failed");
-                                                       eRet = OMX_ErrorUnsupportedSetting;
-                                                   }
-                                   }
-                                           }
-                                       }
                                    }
 
                                    if (eRet) {
@@ -7454,11 +7388,6 @@ int omx_vdec::async_message_process (void *context, void* message)
                     OMX_COMPONENT_GENERATE_HARDWARE_OVERLOAD);
             break;
 
-        case VDEC_MSG_EVT_HW_UNSUPPORTED:
-            omx->post_event ((unsigned)NULL, vdec_msg->status_code,\
-                    OMX_COMPONENT_GENERATE_UNSUPPORTED_SETTING);
-            break;
-
         case VDEC_MSG_RESP_START_DONE:
             omx->post_event ((unsigned)NULL, vdec_msg->status_code,\
                     OMX_COMPONENT_GENERATE_START_DONE);
@@ -9198,27 +9127,27 @@ void omx_vdec::handle_extradata(OMX_BUFFERHEADERTYPE *p_buf_hdr)
     OMX_OTHER_EXTRADATATYPE *data = (struct OMX_OTHER_EXTRADATATYPE *)p_extradata;
     if (data && p_extra) {
         while ((consumed_len < drv_ctx.extradata_info.buffer_size)
-                && (data->eType != (OMX_EXTRADATATYPE)MSM_VIDC_EXTRADATA_NONE)) {
+                && (data->eType != (OMX_EXTRADATATYPE)V4L2_MPEG_VIDC_EXTRADATA_NONE)) {
             if ((consumed_len + data->nSize) > (unsigned)drv_ctx.extradata_info.buffer_size) {
                 DEBUG_PRINT_LOW("Invalid extra data size");
                 break;
             }
             DEBUG_PRINT_LOW("handle_extradata: eType = %d", data->eType);
             switch ((unsigned long)data->eType) {
-                case MSM_VIDC_EXTRADATA_INTERLACE_VIDEO:
+                case V4L2_MPEG_VIDC_EXTRADATA_INTERLACE_VIDEO:
                     struct msm_vidc_interlace_payload *payload;
                     payload = (struct msm_vidc_interlace_payload *)(void *)data->data;
                     if (payload) {
                         enable = 1;
                         switch (payload->format) {
-                            case MSM_VIDC_INTERLACE_FRAME_PROGRESSIVE:
+                            case INTERLACE_FRAME_PROGRESSIVE:
                                 drv_ctx.interlace = VDEC_InterlaceFrameProgressive;
                                 enable = 0;
                                 break;
-                            case MSM_VIDC_INTERLACE_INTERLEAVE_FRAME_TOPFIELDFIRST:
+                            case INTERLACE_INTERLEAVE_FRAME_TOPFIELDFIRST:
                                 drv_ctx.interlace = VDEC_InterlaceInterleaveFrameTopFieldFirst;
                                 break;
-                            case MSM_VIDC_INTERLACE_INTERLEAVE_FRAME_BOTTOMFIELDFIRST:
+                            case INTERLACE_INTERLEAVE_FRAME_BOTTOMFIELDFIRST:
                                 drv_ctx.interlace = VDEC_InterlaceInterleaveFrameBottomFieldFirst;
                                 break;
                             default:
@@ -9240,29 +9169,29 @@ void omx_vdec::handle_extradata(OMX_BUFFERHEADERTYPE *p_buf_hdr)
                         p_extra = (OMX_OTHER_EXTRADATATYPE *) (((OMX_U8 *) p_extra) + p_extra->nSize);
                     }
                     break;
-                case MSM_VIDC_EXTRADATA_FRAME_RATE:
+                case V4L2_MPEG_VIDC_EXTRADATA_FRAME_RATE:
                     struct msm_vidc_framerate_payload *frame_rate_payload;
                     frame_rate_payload = (struct msm_vidc_framerate_payload *)(void *)data->data;
                     frame_rate = frame_rate_payload->frame_rate;
                     break;
-                case MSM_VIDC_EXTRADATA_TIMESTAMP:
+                case V4L2_MPEG_VIDC_EXTRADATA_TIMESTAMP:
                     struct msm_vidc_ts_payload *time_stamp_payload;
                     time_stamp_payload = (struct msm_vidc_ts_payload *)(void *)data->data;
                     time_stamp = time_stamp_payload->timestamp_lo;
                     time_stamp |= ((unsigned long long)time_stamp_payload->timestamp_hi << 32);
                     p_buf_hdr->nTimeStamp = time_stamp;
                     break;
-                case MSM_VIDC_EXTRADATA_NUM_CONCEALED_MB:
+                case V4L2_MPEG_VIDC_EXTRADATA_NUM_CONCEALED_MB:
                     struct msm_vidc_concealmb_payload *conceal_mb_payload;
                     conceal_mb_payload = (struct msm_vidc_concealmb_payload *)(void *)data->data;
                     num_MB_in_frame = ((drv_ctx.video_resolution.frame_width + 15) *
                             (drv_ctx.video_resolution.frame_height + 15)) >> 8;
                     num_conceal_MB = ((num_MB_in_frame > 0)?(conceal_mb_payload->num_mbs * 100 / num_MB_in_frame) : 0);
                     break;
-                case MSM_VIDC_EXTRADATA_INDEX:
+                case EXTRADATA_INDEX:
                     int *etype;
                     etype  = (int *)(void *)data->data;
-                    if (etype && *etype == MSM_VIDC_EXTRADATA_ASPECT_RATIO) {
+                    if (etype && *etype == V4L2_MPEG_VIDC_INDEX_EXTRADATA_ASPECT_RATIO) {
                         struct msm_vidc_aspect_ratio_payload *aspect_ratio_payload;
                         aspect_ratio_payload = (struct msm_vidc_aspect_ratio_payload *)(++etype);
                         if (aspect_ratio_payload) {
@@ -9273,18 +9202,18 @@ void omx_vdec::handle_extradata(OMX_BUFFERHEADERTYPE *p_buf_hdr)
                         }
                     }
                     break;
-                case MSM_VIDC_EXTRADATA_RECOVERY_POINT_SEI:
+                case V4L2_MPEG_VIDC_EXTRADATA_RECOVERY_POINT_SEI:
                     struct msm_vidc_recoverysei_payload *recovery_sei_payload;
                     recovery_sei_payload = (struct msm_vidc_recoverysei_payload *)(void *)data->data;
                     recovery_sei_flags = recovery_sei_payload->flags;
-                    if (recovery_sei_flags != MSM_VIDC_FRAME_RECONSTRUCTION_CORRECT) {
+                    if (recovery_sei_flags != FRAME_RECONSTRUCTION_CORRECT) {
                         p_buf_hdr->nFlags |= OMX_BUFFERFLAG_DATACORRUPT;
                         DEBUG_PRINT_HIGH("***************************************************");
                         DEBUG_PRINT_HIGH("FillBufferDone: OMX_BUFFERFLAG_DATACORRUPT Received");
                         DEBUG_PRINT_HIGH("***************************************************");
                     }
                     break;
-               case MSM_VIDC_EXTRADATA_PANSCAN_WINDOW:
+               case V4L2_MPEG_VIDC_EXTRADATA_PANSCAN_WINDOW:
                     panscan_payload = (struct msm_vidc_panscan_window_payload *)(void *)data->data;
                     if (panscan_payload->num_panscan_windows > MAX_PAN_SCAN_WINDOWS) {
                         DEBUG_PRINT_ERROR("Panscan windows are more than supported\n");
@@ -9293,7 +9222,7 @@ void omx_vdec::handle_extradata(OMX_BUFFERHEADERTYPE *p_buf_hdr)
                         return;
                     }
                     break;
-                case MSM_VIDC_EXTRADATA_MPEG2_SEQDISP:
+                case V4L2_MPEG_VIDC_EXTRADATA_MPEG2_SEQDISP:
                     struct msm_vidc_mpeg2_seqdisp_payload *seqdisp_payload;
                     seqdisp_payload = (struct msm_vidc_mpeg2_seqdisp_payload *)(void *)data->data;
                     if (seqdisp_payload) {
@@ -9305,7 +9234,7 @@ void omx_vdec::handle_extradata(OMX_BUFFERHEADERTYPE *p_buf_hdr)
                         }
                     }
                     break;
-                case MSM_VIDC_EXTRADATA_S3D_FRAME_PACKING:
+                case V4L2_MPEG_VIDC_EXTRADATA_S3D_FRAME_PACKING:
                     struct msm_vidc_s3d_frame_packing_payload *s3d_frame_packing_payload;
                     s3d_frame_packing_payload = (struct msm_vidc_s3d_frame_packing_payload *)(void *)data->data;
                     if (client_extradata & OMX_FRAMEPACK_EXTRADATA) {
@@ -9313,7 +9242,7 @@ void omx_vdec::handle_extradata(OMX_BUFFERHEADERTYPE *p_buf_hdr)
                         p_extra = (OMX_OTHER_EXTRADATATYPE *) (((OMX_U8 *) p_extra) + p_extra->nSize);
                     }
                     break;
-                case MSM_VIDC_EXTRADATA_FRAME_QP:
+                case V4L2_MPEG_VIDC_EXTRADATA_FRAME_QP:
                     struct msm_vidc_frame_qp_payload *qp_payload;
                     qp_payload = (struct msm_vidc_frame_qp_payload*)(void *)data->data;
                     if (client_extradata & OMX_QP_EXTRADATA) {
@@ -9321,7 +9250,7 @@ void omx_vdec::handle_extradata(OMX_BUFFERHEADERTYPE *p_buf_hdr)
                         p_extra = (OMX_OTHER_EXTRADATATYPE *) (((OMX_U8 *) p_extra) + p_extra->nSize);
                     }
                     break;
-                case MSM_VIDC_EXTRADATA_FRAME_BITS_INFO:
+                case V4L2_MPEG_VIDC_EXTRADATA_FRAME_BITS_INFO:
                     struct msm_vidc_frame_bits_info_payload *bits_info_payload;
                     bits_info_payload = (struct msm_vidc_frame_bits_info_payload*)(void *)data->data;
                     if (client_extradata & OMX_BITSINFO_EXTRADATA) {
@@ -9329,41 +9258,12 @@ void omx_vdec::handle_extradata(OMX_BUFFERHEADERTYPE *p_buf_hdr)
                         p_extra = (OMX_OTHER_EXTRADATATYPE *) (((OMX_U8 *) p_extra) + p_extra->nSize);
                     }
                     break;
-                case MSM_VIDC_EXTRADATA_STREAM_USERDATA:
+                case V4L2_MPEG_VIDC_EXTRADATA_STREAM_USERDATA:
                     if (client_extradata & OMX_EXTNUSER_EXTRADATA) {
                         append_user_extradata(p_extra, data);
                         p_extra = (OMX_OTHER_EXTRADATATYPE *) (((OMX_U8 *) p_extra) + p_extra->nSize);
                     }
                     break;
-                case MSM_VIDC_EXTRADATA_VUI_DISPLAY_INFO:
-                    struct msm_vidc_vui_display_info_payload *display_info_payload;
-                    display_info_payload = (struct msm_vidc_vui_display_info_payload*)(void *)data->data;
-
-                    if (client_extradata & OMX_VUI_DISPLAY_INFO_EXTRADATA) {
-                        /* This extradata usually isn't needed by clients. Leave it unimplemented for now */
-                        DEBUG_PRINT_ERROR("VUI display info not propagated to client");
-                    }
-
-                    if (m_enable_android_native_buffers
-                            && display_info_payload->video_signal_present_flag
-                            && display_info_payload->color_description_present_flag) {
-                        ColorSpace_t color_space = ITU_R_601;
-
-                        switch (display_info_payload->color_primaries) {
-                            case 1:
-                                color_space = ITU_R_709;
-                                break;
-                            case 5:
-                                color_space = display_info_payload->video_full_range_flag ?
-                                    ITU_R_601_FR : ITU_R_601;
-                                break;
-                        }
-
-                        DEBUG_PRINT_LOW("colorspace from VUI = %d", color_space);
-                        setMetaData((private_handle_t *)native_buffer[buf_index].privatehandle,
-                               UPDATE_COLOR_SPACE, (void*)&color_space);
-                    }
-                    break;
                 default:
                     DEBUG_PRINT_LOW("Unrecognized extradata");
                     goto unrecognized_extradata;
@@ -9450,7 +9350,7 @@ OMX_ERRORTYPE omx_vdec::enable_extradata(OMX_U32 requested_extradata,
                 DEBUG_PRINT_HIGH("Failed to set panscan extradata");
             }
             control.id = V4L2_CID_MPEG_VIDC_VIDEO_EXTRADATA;
-            control.value = V4L2_MPEG_VIDC_EXTRADATA_ASPECT_RATIO;
+            control.value = V4L2_MPEG_VIDC_INDEX_EXTRADATA_ASPECT_RATIO;
             if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {
                 DEBUG_PRINT_HIGH("Failed to set panscan extradata");
             }
@@ -9507,13 +9407,6 @@ OMX_ERRORTYPE omx_vdec::enable_extradata(OMX_U32 requested_extradata,
                 DEBUG_PRINT_HIGH("Seq display extradata is supported for MPEG2 only");
             }
         }
-        if (requested_extradata & OMX_VUI_DISPLAY_INFO_EXTRADATA) {
-            control.id = V4L2_CID_MPEG_VIDC_VIDEO_EXTRADATA;
-            control.value = V4L2_MPEG_VIDC_EXTRADATA_VUI_DISPLAY;
-            if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {
-                DEBUG_PRINT_HIGH("Failed to set display VUI extradata");
-            }
-        }
     }
     ret = get_buffer_req(&drv_ctx.op_buf);
     return ret;
@@ -9707,15 +9600,15 @@ void omx_vdec::append_interlace_extradata(OMX_OTHER_EXTRADATATYPE *extra,
     interlace_format->nVersion.nVersion = OMX_SPEC_VERSION;
     interlace_format->nPortIndex = OMX_CORE_OUTPUT_PORT_INDEX;
 
-    if ((interlaced_format_type == MSM_VIDC_INTERLACE_FRAME_PROGRESSIVE) && !is_mbaff) {
+    if ((interlaced_format_type == INTERLACE_FRAME_PROGRESSIVE) && !is_mbaff) {
         interlace_format->bInterlaceFormat = OMX_FALSE;
         interlace_format->nInterlaceFormats = OMX_InterlaceFrameProgressive;
         drv_ctx.interlace = VDEC_InterlaceFrameProgressive;
-    } else if ((interlaced_format_type == MSM_VIDC_INTERLACE_INTERLEAVE_FRAME_TOPFIELDFIRST) && !is_mbaff) {
+    } else if ((interlaced_format_type == INTERLACE_INTERLEAVE_FRAME_TOPFIELDFIRST) && !is_mbaff) {
         interlace_format->bInterlaceFormat = OMX_TRUE;
         interlace_format->nInterlaceFormats =  OMX_InterlaceInterleaveFrameTopFieldFirst;
         drv_ctx.interlace = VDEC_InterlaceFrameProgressive;
-    } else if ((interlaced_format_type == MSM_VIDC_INTERLACE_INTERLEAVE_FRAME_BOTTOMFIELDFIRST) && !is_mbaff) {
+    } else if ((interlaced_format_type == INTERLACE_INTERLEAVE_FRAME_BOTTOMFIELDFIRST) && !is_mbaff) {
         interlace_format->bInterlaceFormat = OMX_TRUE;
         interlace_format->nInterlaceFormats = OMX_InterlaceInterleaveFrameBottomFieldFirst;
         drv_ctx.interlace = VDEC_InterlaceFrameProgressive;
@@ -10203,10 +10096,6 @@ bool omx_vdec::allocate_color_convert_buf::set_color_format(
     }
     pthread_mutex_lock(&omx->c_lock);
     if (omx->drv_ctx.output_format == VDEC_YUV_FORMAT_NV12)
-        if (omx->drv_ctx.decoder_format == VDEC_CODECTYPE_MVC)
-            drv_color_format = (OMX_COLOR_FORMATTYPE)
-                QOMX_COLOR_FORMATYUV420PackedSemiPlanar32mMultiView;
-        else
         drv_color_format = (OMX_COLOR_FORMATTYPE)
             QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;
     else {
@@ -10471,10 +10360,6 @@ bool omx_vdec::allocate_color_convert_buf::get_color_format(OMX_COLOR_FORMATTYPE
     bool status = true;
     if (!enabled) {
         if (omx->drv_ctx.output_format == VDEC_YUV_FORMAT_NV12)
-            if (omx->drv_ctx.decoder_format == VDEC_CODECTYPE_MVC)
-                    dest_color_format = (OMX_COLOR_FORMATTYPE)
-                        QOMX_COLOR_FORMATYUV420PackedSemiPlanar32mMultiView;
-                else
             dest_color_format =  (OMX_COLOR_FORMATTYPE)
                 QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;
         else
diff --git a/msm8974/mm-video-v4l2/vidc/venc/inc/omx_video_base.h b/msm8974/mm-video-v4l2/vidc/venc/inc/omx_video_base.h
index 5916582..70b7f56 100644
--- a/msm8974/mm-video-v4l2/vidc/venc/inc/omx_video_base.h
+++ b/msm8974/mm-video-v4l2/vidc/venc/inc/omx_video_base.h
@@ -102,6 +102,7 @@ static const char* MEM_DEVICE = "/dev/pmem_smipool";
 #error MEM_DEVICE cannot be determined.
 #endif
 
+#define _ION_HEAP_MASK_COMPATIBILITY_WA
 #ifdef _ION_HEAP_MASK_COMPATIBILITY_WA
     #define ION_HEAP_MASK heap_mask
 #else
diff --git a/msm8974/mm-video-v4l2/vidc/venc/src/video_encoder_device_v4l2.cpp b/msm8974/mm-video-v4l2/vidc/venc/src/video_encoder_device_v4l2.cpp
index b3b37d1..b18b8c9 100644
--- a/msm8974/mm-video-v4l2/vidc/venc/src/video_encoder_device_v4l2.cpp
+++ b/msm8974/mm-video-v4l2/vidc/venc/src/video_encoder_device_v4l2.cpp
@@ -547,7 +547,7 @@ bool venc_dev::handle_extradata(void *buffer, int index)
             extradata_info.uaddr + index * extradata_info.buffer_size);
 
         switch (p_extradata->type) {
-            case MSM_VIDC_EXTRADATA_METADATA_MBI:
+            case EXTRADATA_METADATA_MBI:
             {
                 OMX_U32 payloadSize = append_mbi_extradata(&p_extra->data, p_extradata);
                 p_extra->nSize = ALIGN(sizeof(OMX_OTHER_EXTRADATATYPE) + payloadSize, 4);
@@ -567,7 +567,7 @@ bool venc_dev::handle_extradata(void *buffer, int index)
                 p_extra->nDataSize = p_extradata->data_size;
                 break;
             }
-            case MSM_VIDC_EXTRADATA_NONE:
+            case EXTRADATA_NONE:
                 p_extra->nSize = ALIGN(sizeof(OMX_OTHER_EXTRADATATYPE), 4);
                 p_extra->nVersion.nVersion = OMX_SPEC_VERSION;
                 p_extra->nPortIndex = OMX_DirOutput;
@@ -582,7 +582,7 @@ bool venc_dev::handle_extradata(void *buffer, int index)
         }
 
         p_extra = (OMX_OTHER_EXTRADATATYPE *)(((char *)p_extra) + p_extra->nSize);
-    } while (p_extradata->type != MSM_VIDC_EXTRADATA_NONE);
+    } while (p_extradata->type != EXTRADATA_NONE);
 
     /* Just for debugging: Traverse the list of extra datas  and spit it out onto log */
     p_extra = (OMX_OTHER_EXTRADATATYPE *)ALIGN(p_bufhdr->pBuffer +
@@ -897,12 +897,6 @@ bool venc_dev::venc_open(OMX_U32 codec)
         profile_level.level = V4L2_MPEG_VIDC_VIDEO_VP8_VERSION_0;
         session_qp_range.minqp = 1;
         session_qp_range.maxqp = 128;
-    } else if (codec == OMX_VIDEO_CodingHEVC) {
-        m_sVenc_cfg.codectype = V4L2_PIX_FMT_HEVC;
-        session_qp_range.minqp = 1;
-        session_qp_range.maxqp = 51;
-        codec_profile.profile = V4L2_MPEG_VIDC_VIDEO_HEVC_PROFILE_MAIN;
-        profile_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_1;
     }
     session_qp_values.minqp = session_qp_range.minqp;
     session_qp_values.maxqp = session_qp_range.maxqp;
@@ -1354,11 +1348,6 @@ bool venc_dev::venc_set_param(void *paramData,OMX_INDEXTYPE index )
 
                     DEBUG_PRINT_LOW("input: actual: %u, min: %u, count_req: %u",
                             (unsigned int)portDefn->nBufferCountActual, (unsigned int)m_sInput_buff_property.mincount, bufreq.count);
-                    if (m_sVenc_cfg.input_width * m_sVenc_cfg.input_height >= 3840 * 2160) {
-                        if (venc_set_perf_mode(V4L2_MPEG_VIDC_VIDEO_PERF_POWER_SAVE) == false) {
-                            DEBUG_PRINT_ERROR("ERROR: Failed to set Power save mode");
-                        }
-                    }
                 } else if (portDefn->nPortIndex == PORT_INDEX_OUT) {
                     m_sVenc_cfg.dvs_height = portDefn->format.video.nFrameHeight;
                     m_sVenc_cfg.dvs_width = portDefn->format.video.nFrameWidth;
@@ -2320,14 +2309,6 @@ unsigned venc_dev::venc_start(void)
 
     streaming[CAPTURE_PORT] = true;
 
-    control.id = V4L2_CID_MPEG_VIDC_VIDEO_REQUEST_SEQ_HEADER;
-    control.value = 1;
-    ret = ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control);
-    if (ret) {
-        DEBUG_PRINT_ERROR("failed to request seq header");
-        return 1;
-    }
-
     stopped = 0;
     return 0;
 }
@@ -2672,6 +2653,7 @@ bool venc_dev::venc_empty_buf(void *buffer, void *pmem_data_buf, unsigned index,
         // surface encode (RBG)  1            GrallocSource  1              bufhdr (color-converted)
         // CPU (Eg: MediaCodec)  0            --             0              bufhdr
         // ---------------------------------------------------------------------------------------
+        int color_space = 0;
         if (metadatamode) {
             plane.m.userptr = index;
             meta_buf = (encoder_media_buffer_type *)bufhdr->pBuffer;
@@ -2687,15 +2669,6 @@ bool venc_dev::venc_empty_buf(void *buffer, void *pmem_data_buf, unsigned index,
                     return false;
                 }
             } else if (!color_format) {
-		int color_space = 0;
-
-                if (meta_buf->buffer_type == kMetadataBufferTypeCameraSource) {
-                    if (meta_buf->meta_handle->numFds + meta_buf->meta_handle->numInts > 3 &&
-                        meta_buf->meta_handle->data[3] & private_handle_t::PRIV_FLAGS_ITU_R_709) {
-                        buf.flags = V4L2_MSM_BUF_FLAG_YUV_601_709_CLAMP;
-			color_space = V4L2_COLORSPACE_REC709;
-		    }
-
                     if (meta_buf->meta_handle->numFds + meta_buf->meta_handle->numInts > 2) {
                     plane.data_offset = meta_buf->meta_handle->data[1];
                     plane.length = meta_buf->meta_handle->data[2];
@@ -2735,11 +2708,7 @@ bool venc_dev::venc_empty_buf(void *buffer, void *pmem_data_buf, unsigned index,
                                 reinterpret_cast<MetaData_t*>(handle->base_metadata);
                         ColorSpace_t csc = pMeta->operation & UPDATE_COLOR_SPACE ?
                                 pMeta->colorSpace : (ColorSpace_t)-1;
-                        if (csc == ITU_R_709) {
-                            buf.flags |= V4L2_MSM_BUF_FLAG_YUV_601_709_CLAMP;
-                            DEBUG_PRINT_LOW("venc_empty_buf: force 601 -> 709 clamping");
-			    color_space = V4L2_COLORSPACE_REC709;
-                        } else if (csc == ITU_R_601_FR) {
+                        if (csc == ITU_R_601_FR) {
                             DEBUG_PRINT_LOW("venc_empty_buf: 601 full-range");
                             color_space = V4L2_COLORSPACE_470_SYSTEM_BG;
                         } else if (csc == ITU_R_601) {
@@ -2766,13 +2735,6 @@ bool venc_dev::venc_empty_buf(void *buffer, void *pmem_data_buf, unsigned index,
 				return false;
 			}
 		}
-            } else {
-                plane.data_offset = bufhdr->nOffset;
-                plane.length = bufhdr->nAllocLen;
-                plane.bytesused = bufhdr->nFilledLen;
-                DEBUG_PRINT_LOW("venc_empty_buf: Opaque non-camera buf: fd = %d "
-                        ": filled %d of %d", fd, plane.bytesused, plane.length);
-            }
         } else {
             plane.data_offset = bufhdr->nOffset;
             plane.length = bufhdr->nAllocLen;
@@ -2950,52 +2912,9 @@ bool venc_dev::venc_validate_hybridhp_params(OMX_U32 layers, OMX_U32 bFrames, OM
 bool venc_dev::venc_set_hier_layers(QOMX_VIDEO_HIERARCHICALCODINGTYPE type,
                                     OMX_U32 num_layers)
 {
-    struct v4l2_control control;
-
-    if (!venc_validate_hybridhp_params(num_layers, 0, 0, (int)type)){
-        DEBUG_PRINT_ERROR("Invalid settings, Hier-pLayers enabled with HybridHP");
-        return false;
-    }
-
-    if (type == QOMX_HIERARCHICALCODING_P) {
-        // Reduce layer count by 1 before sending to driver. This avoids
-        // driver doing the same in multiple places.
-        control.id = V4L2_CID_MPEG_VIDC_VIDEO_HIER_P_NUM_LAYERS;
-        control.value = num_layers - 1;
-        DEBUG_PRINT_HIGH("Set Hier P num layers: %u", (unsigned int)num_layers);
-        if (ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control)) {
-            DEBUG_PRINT_ERROR("Request to set Hier P num layers failed");
-            return false;
-        }
-        if (m_sVenc_cfg.codectype == V4L2_PIX_FMT_H264) {
-            DEBUG_PRINT_LOW("Set H264_SVC_NAL");
-            control.id = V4L2_CID_MPEG_VIDC_VIDEO_H264_NAL_SVC;
-            control.value = V4L2_CID_MPEG_VIDC_VIDEO_H264_NAL_SVC_ENABLED;
-            if (ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control)) {
-                DEBUG_PRINT_ERROR("Failed to enable SVC_NAL");
-                return false;
-            }
-        }
-        hier_layers.hier_mode = HIER_P;
-    } else if (type == QOMX_HIERARCHICALCODING_B) {
-        if (m_sVenc_cfg.codectype != V4L2_PIX_FMT_HEVC) {
-            DEBUG_PRINT_ERROR("Failed : Hier B layers supported only for HEVC encode");
-            return false;
-        }
-        control.id = V4L2_CID_MPEG_VIDC_VIDEO_HIER_B_NUM_LAYERS;
-        control.value = num_layers - 1;
-        DEBUG_PRINT_INFO("Set Hier B num layers: %u", (unsigned int)num_layers);
-        if (ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control)) {
-            DEBUG_PRINT_ERROR("Request to set Hier P num layers failed");
-            return false;
-        }
-        hier_layers.hier_mode = HIER_B;
-    } else {
-        DEBUG_PRINT_ERROR("Request to set hier num layers failed for type: %d", type);
-        return false;
-    }
-    hier_layers.numlayers = num_layers;
-    return true;
+    // not supported on 8974
+    DEBUG_PRINT_ERROR("set_hier_layers not supported on 8974");
+    return false;
 }
 
 bool venc_dev::venc_set_extradata(OMX_U32 extra_data, OMX_BOOL enable)
@@ -3454,95 +3373,8 @@ bool venc_dev::venc_set_profile_level(OMX_U32 eProfile,OMX_U32 eLevel)
                 break;
         }
     }  else if (m_sVenc_cfg.codectype == V4L2_PIX_FMT_HEVC) {
-        if (eProfile == OMX_VIDEO_HEVCProfileMain) {
-            requested_profile.profile = V4L2_MPEG_VIDC_VIDEO_HEVC_PROFILE_MAIN;
-        } else if(eProfile == OMX_VIDEO_HEVCProfileMain10) {
-            requested_profile.profile = V4L2_MPEG_VIDC_VIDEO_HEVC_PROFILE_MAIN10;
-        } else {
-            DEBUG_PRINT_ERROR("ERROR: Unsupported HEVC profile = %lu",
-                    requested_profile.profile);
-            return false;
-        }
-
-        //profile level
-        switch (eLevel) {
-            case OMX_VIDEO_HEVCMainTierLevel1:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_1;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel1:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_1;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel2:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_2;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel2:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_2;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel21:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_2_1;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel21:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_2_1;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel3:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_3;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel3:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_3;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel31:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_3_1;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel31:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_3_1;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel4:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_4;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel4:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_4;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel41:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_4_1;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel41:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_4_1;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel5:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_5;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel5:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_5;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel51:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_5_1;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel51:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_5_1;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel52:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_5_2;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel52:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_5_2;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel6:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_6;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel6:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_6;
-                break;
-            case OMX_VIDEO_HEVCMainTierLevel61:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_6_1;
-                break;
-            case OMX_VIDEO_HEVCHighTierLevel61:
-                requested_level.level = V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_6_1;
-                break;
-            default :
-                DEBUG_PRINT_ERROR("ERROR: Unsupported HEVC level= %lu",
-                        requested_level.level);
+                DEBUG_PRINT_ERROR("ERROR: HEVC is not supported on 8974");
                 return false;
-        }
     }
 
     if (!m_profile_set) {
@@ -3555,8 +3387,6 @@ bool venc_dev::venc_set_profile_level(OMX_U32 eProfile,OMX_U32 eLevel)
             control.id = V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE;
         } else if (m_sVenc_cfg.codectype == V4L2_PIX_FMT_H263) {
             control.id = V4L2_CID_MPEG_VIDC_VIDEO_H263_PROFILE;
-        } else if (m_sVenc_cfg.codectype == V4L2_PIX_FMT_HEVC) {
-            control.id = V4L2_CID_MPEG_VIDC_VIDEO_HEVC_PROFILE;
         } else {
             DEBUG_PRINT_ERROR("Wrong CODEC");
             return false;
@@ -3590,8 +3420,6 @@ bool venc_dev::venc_set_profile_level(OMX_U32 eProfile,OMX_U32 eLevel)
             control.id = V4L2_CID_MPEG_VIDC_VIDEO_H263_LEVEL;
         } else if (m_sVenc_cfg.codectype == V4L2_PIX_FMT_VP8) {
             control.id = V4L2_CID_MPEG_VIDC_VIDEO_VP8_PROFILE_LEVEL;
-        } else if (m_sVenc_cfg.codectype == V4L2_PIX_FMT_HEVC) {
-            control.id = V4L2_CID_MPEG_VIDC_VIDEO_HEVC_TIER_LEVEL;
         } else {
             DEBUG_PRINT_ERROR("Wrong CODEC");
             return false;
@@ -3640,8 +3468,6 @@ bool venc_dev::venc_set_intra_period(OMX_U32 nPFrames, OMX_U32 nBFrames)
 
     if ((codec_profile.profile != V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE) &&
             (codec_profile.profile != V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) &&
-            (codec_profile.profile != V4L2_MPEG_VIDC_VIDEO_HEVC_PROFILE_MAIN) &&
-            (codec_profile.profile != V4L2_MPEG_VIDC_VIDEO_HEVC_PROFILE_MAIN10) &&
             (codec_profile.profile != V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)) {
         nBFrames=0;
     }
@@ -4263,67 +4089,8 @@ bool venc_dev::venc_calibrate_gop()
 
 bool venc_dev::venc_set_hybrid_hierp(OMX_U32 layers)
 {
-    DEBUG_PRINT_LOW("venc_set_hybrid_hierp layers: %u", layers);
-    struct v4l2_control control;
-    int rc;
-
-    if (!venc_validate_hybridhp_params(layers, 0, 0, (int) HIER_P_HYBRID)) {
-        DEBUG_PRINT_ERROR("Invalid settings, Hybrid HP enabled with LTR OR Hier-pLayers OR bframes");
-        return false;
-    }
-
-    if (!layers || layers > MAX_HYB_HIERP_LAYERS) {
-        DEBUG_PRINT_ERROR("Invalid numbers of layers set: %d (max supported is 6)", layers);
-        return false;
-    }
-
-    hier_layers.numlayers = layers;
-    hier_layers.hier_mode = HIER_P_HYBRID;
-    if (venc_calibrate_gop()) {
-     // Update the driver with the new nPframes and nBframes
-        control.id = V4L2_CID_MPEG_VIDC_VIDEO_NUM_P_FRAMES;
-        control.value = intra_period.num_pframes;
-        rc = ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control);
-        if (rc) {
-            DEBUG_PRINT_ERROR("Failed to set control");
-            return false;
-        }
-
-        control.id = V4L2_CID_MPEG_VIDC_VIDEO_NUM_B_FRAMES;
-        control.value = intra_period.num_bframes;
-        rc = ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control);
-        if (rc) {
-            DEBUG_PRINT_ERROR("Failed to set control");
-            return false;
-        }
-        DEBUG_PRINT_LOW("Updated nPframes (%ld) and nBframes (%ld)",
-                         intra_period.num_pframes, intra_period.num_bframes);
-    } else {
-        DEBUG_PRINT_ERROR("Invalid settings, Hybrid HP enabled with LTR OR Hier-pLayers OR bframes");
-        return false;
-    }
-
-    control.id = V4L2_CID_MPEG_VIDC_VIDEO_HYBRID_HIERP_MODE;
-    control.value = layers - 1;
-
-    DEBUG_PRINT_LOW("Calling IOCTL set control for id=%x, val=%d",
-                    control.id, control.value);
-
-    rc = ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control);
-    if (rc) {
-        DEBUG_PRINT_ERROR("Failed to set hybrid hierp %d", rc);
-        return false;
-    }
-
-    DEBUG_PRINT_LOW("SUCCESS IOCTL set control for id=%x, val=%d",
-                    control.id, control.value);
-    control.id = V4L2_CID_MPEG_VIDC_VIDEO_H264_NAL_SVC;
-    control.value = V4L2_CID_MPEG_VIDC_VIDEO_H264_NAL_SVC_ENABLED;
-    if (ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control)) {
-        DEBUG_PRINT_ERROR("Failed to enable SVC_NAL");
-        return false;
-    }
-    return true;
+    DEBUG_PRINT_ERROR("venc_set_hybrid_hierp not supported on 8974");
+    return false;
 }
 
 bool venc_dev::venc_set_ltrmode(OMX_U32 enable, OMX_U32 count)
@@ -4487,77 +4254,8 @@ bool venc_dev::venc_set_vpe_rotation(OMX_S32 rotation_angle)
 
 bool venc_dev::venc_set_searchrange()
 {
-    DEBUG_PRINT_LOW("venc_set_searchrange");
-    struct v4l2_control control;
-    struct v4l2_ext_control ctrl[6];
-    struct v4l2_ext_controls controls;
-    int rc;
-
-    if (m_sVenc_cfg.codectype == V4L2_PIX_FMT_MPEG4) {
-        ctrl[0].id = V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_X_RANGE;
-        ctrl[0].value = 16;
-        ctrl[1].id = V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_Y_RANGE;
-        ctrl[1].value = 4;
-        ctrl[2].id = V4L2_CID_MPEG_VIDC_VIDEO_PFRAME_X_RANGE;
-        ctrl[2].value = 16;
-        ctrl[3].id = V4L2_CID_MPEG_VIDC_VIDEO_PFRAME_Y_RANGE;
-        ctrl[3].value = 4;
-        ctrl[4].id = V4L2_CID_MPEG_VIDC_VIDEO_BFRAME_X_RANGE;
-        ctrl[4].value = 12;
-        ctrl[5].id = V4L2_CID_MPEG_VIDC_VIDEO_BFRAME_Y_RANGE;
-        ctrl[5].value = 4;
-    } else if ((m_sVenc_cfg.codectype == V4L2_PIX_FMT_H264) ||
-               (m_sVenc_cfg.codectype == V4L2_PIX_FMT_VP8)) {
-        ctrl[0].id = V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_X_RANGE;
-        ctrl[0].value = 16;
-        ctrl[1].id = V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_Y_RANGE;
-        ctrl[1].value = 4;
-        ctrl[2].id = V4L2_CID_MPEG_VIDC_VIDEO_PFRAME_X_RANGE;
-        ctrl[2].value = 16;
-        ctrl[3].id = V4L2_CID_MPEG_VIDC_VIDEO_PFRAME_Y_RANGE;
-        ctrl[3].value = 4;
-        ctrl[4].id = V4L2_CID_MPEG_VIDC_VIDEO_BFRAME_X_RANGE;
-        ctrl[4].value = 12;
-        ctrl[5].id = V4L2_CID_MPEG_VIDC_VIDEO_BFRAME_Y_RANGE;
-        ctrl[5].value = 4;
-    } else if (m_sVenc_cfg.codectype == V4L2_PIX_FMT_H263) {
-        ctrl[0].id = V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_X_RANGE;
-        ctrl[0].value = 4;
-        ctrl[1].id = V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_Y_RANGE;
-        ctrl[1].value = 4;
-        ctrl[2].id = V4L2_CID_MPEG_VIDC_VIDEO_PFRAME_X_RANGE;
-        ctrl[2].value = 4;
-        ctrl[3].id = V4L2_CID_MPEG_VIDC_VIDEO_PFRAME_Y_RANGE;
-        ctrl[3].value = 4;
-        ctrl[4].id = V4L2_CID_MPEG_VIDC_VIDEO_BFRAME_X_RANGE;
-        ctrl[4].value = 4;
-        ctrl[5].id = V4L2_CID_MPEG_VIDC_VIDEO_BFRAME_Y_RANGE;
-        ctrl[5].value = 4;
-    } else {
-        DEBUG_PRINT_ERROR("Invalid codec type");
-        return false;
-    }
-    controls.count = 6;
-    controls.ctrl_class = V4L2_CTRL_CLASS_MPEG;
-    controls.controls = ctrl;
-
-    DEBUG_PRINT_LOW(" Calling IOCTL set control for"
-        "id=%x, val=%d id=%x, val=%d"
-        "id=%x, val=%d id=%x, val=%d"
-        "id=%x, val=%d id=%x, val=%d",
-        controls.controls[0].id, controls.controls[0].value,
-        controls.controls[1].id, controls.controls[1].value,
-        controls.controls[2].id, controls.controls[2].value,
-        controls.controls[3].id, controls.controls[3].value,
-        controls.controls[4].id, controls.controls[4].value,
-        controls.controls[5].id, controls.controls[5].value);
-
-    rc = ioctl(m_nDriver_fd, VIDIOC_S_EXT_CTRLS, &controls);
-    if (rc) {
-        DEBUG_PRINT_ERROR("Failed to set search range %d", rc);
-        return false;
-    }
-    return true;
+    DEBUG_PRINT_ERROR("venc_set_searchrange not supported on 8974");
+    return false;
 }
 
 bool venc_dev::venc_set_ratectrl_cfg(OMX_VIDEO_CONTROLRATETYPE eControlRate)
@@ -4649,20 +4347,9 @@ bool venc_dev::venc_set_perf_level(QOMX_VIDEO_PERF_LEVEL ePerfLevel)
 
 bool venc_dev::venc_set_perf_mode(OMX_U32 mode)
 {
-    struct v4l2_control control;
-    if (mode && mode <= V4L2_MPEG_VIDC_VIDEO_PERF_POWER_SAVE) {
-        control.id = V4L2_CID_MPEG_VIDC_VIDEO_PERF_MODE;
-        control.value = mode;
-        DEBUG_PRINT_LOW("Going to set V4L2_CID_MPEG_VIDC_VIDEO_PERF_MODE");
-        if (ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control)) {
-            DEBUG_PRINT_ERROR("Failed to set V4L2_CID_MPEG_VIDC_VIDEO_PERF_MODE");
-            return false;
-        }
-        return true;
-    } else {
-        DEBUG_PRINT_ERROR("Invalid mode set for V4L2_CID_MPEG_VIDC_VIDEO_PERF_MODE: %d", mode);
-        return false;
-    }
+    // not supported on 8974
+    DEBUG_PRINT_ERROR("set_perf_mode is not supported on 8974");
+    return false;
 }
 
 bool venc_dev::venc_set_vui_timing_info(OMX_BOOL enable)
@@ -4710,27 +4397,8 @@ bool venc_dev::venc_set_peak_bitrate(OMX_U32 nPeakBitrate)
 
 bool venc_dev::venc_set_vpx_error_resilience(OMX_BOOL enable)
 {
-    struct v4l2_control control;
-    int rc = 0;
-    control.id = V4L2_CID_MPEG_VIDC_VIDEO_VPX_ERROR_RESILIENCE;
-
-    if (enable)
-        control.value = 1;
-    else
-        control.value = 0;
-
-    DEBUG_PRINT_LOW("venc_set_vpx_error_resilience: %d", control.value);
-
-    DEBUG_PRINT_LOW("Calling IOCTL set control for id=%d, val=%d", control.id, control.value);
-
-    rc = ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control);
-    if (rc) {
-        DEBUG_PRINT_ERROR("Failed to set VPX Error Resilience");
-        return false;
-    }
-    vpx_err_resilience.enable = 1;
-    DEBUG_PRINT_LOW("Success IOCTL set control for id=%d, value=%d", control.id, control.value);
-    return true;
+    DEBUG_PRINT_ERROR("set_vpx_error_resilience not supported on 8974");
+    return false;
 }
 
 bool venc_dev::venc_set_session_priority(OMX_U32 priority) {
@@ -4997,103 +4665,9 @@ bool venc_dev::venc_get_profile_level(OMX_U32 *eProfile,OMX_U32 *eLevel)
                 break;
         }
     } else if (m_sVenc_cfg.codectype == V4L2_PIX_FMT_HEVC) {
-        switch (codec_profile.profile) {
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_PROFILE_MAIN:
-                *eProfile = OMX_VIDEO_HEVCProfileMain;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_PROFILE_MAIN10:
-                *eProfile = OMX_VIDEO_HEVCProfileMain10;
-                break;
-            default:
-                *eProfile = OMX_VIDEO_HEVCProfileMax;
-                status = false;
-                break;
-        }
-        if (!status) {
-            return status;
-        }
-
-        switch (profile_level.level) {
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_1:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel1;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_1:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel1;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_2:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel2;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_2:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel2;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_2_1:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel21;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_2_1:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel21;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_3:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel3;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_3:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel3;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_3_1:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel31;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_3_1:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel31;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_4:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel4;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_4:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel4;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_4_1:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel41;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_4_1:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel41;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_5:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel5;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_5:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel5;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_5_1:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel51;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_5_1:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel51;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_5_2:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel52;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_5_2:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel52;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_6:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel6;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_6:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel6;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_6_1:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel61;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_HIGH_TIER_LEVEL_6_1:
-                *eLevel = OMX_VIDEO_HEVCHighTierLevel61;
-                break;
-            case V4L2_MPEG_VIDC_VIDEO_HEVC_LEVEL_MAIN_TIER_LEVEL_6_2:
-                *eLevel = OMX_VIDEO_HEVCMainTierLevel62;
-                break;
-            default:
-                *eLevel = OMX_VIDEO_HEVCLevelMax;
-                status = false;
-                break;
-        }
+        // not supported on 8974
+        DEBUG_PRINT_ERROR("HEVC not supported on 8974");
+        return false;
     }
 
     return status;
@@ -5254,13 +4828,6 @@ bool venc_dev::venc_validate_profile_level(OMX_U32 *eProfile, OMX_U32 *eLevel)
                 *eProfile = OMX_VIDEO_HEVCProfileMain;
     } else {
                 switch (codec_profile.profile) {
-                    case V4L2_MPEG_VIDC_VIDEO_HEVC_PROFILE_MAIN:
-                        *eProfile = OMX_VIDEO_HEVCProfileMain;
-                        break;
-                    case V4L2_MPEG_VIDC_VIDEO_HEVC_PROFILE_MAIN10:
-                        *eProfile = OMX_VIDEO_HEVCProfileMain10;
-                        break;
-                    default:
                         DEBUG_PRINT_ERROR("%s(): Unknown Error", __func__);
                         return false;
                 }
-- 
2.1.4

