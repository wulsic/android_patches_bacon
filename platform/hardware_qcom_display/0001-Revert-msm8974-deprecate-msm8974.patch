From 7fd012768ca2381e1c6c47c5d05adddb7a8eabda Mon Sep 17 00:00:00 2001
From: Hamster Tian <haotia@gmail.com>
Date: Wed, 24 Aug 2016 14:52:16 +0800
Subject: [PATCH 1/5] Revert "msm8974: deprecate msm8974"

This reverts commit a8a53d301806a2134e72b55797378e6f7cf63e14.
---
 msm8974/Android.mk                          |   11 +
 msm8974/common.mk                           |   52 +
 msm8974/libcopybit/Android.mk               |   48 +
 msm8974/libcopybit/MODULE_LICENSE_APACHE2   |    0
 msm8974/libcopybit/NOTICE                   |  189 +++
 msm8974/libcopybit/c2d2.h                   |  683 +++++++++++
 msm8974/libcopybit/copybit.cpp              |  627 ++++++++++
 msm8974/libcopybit/copybit.h                |  287 +++++
 msm8974/libcopybit/copybit_c2d.cpp          | 1748 +++++++++++++++++++++++++++
 msm8974/libcopybit/copybit_priv.h           |   56 +
 msm8974/libcopybit/software_converter.cpp   |  262 ++++
 msm8974/libcopybit/software_converter.h     |   62 +
 msm8974/libexternal/Android.mk              |   14 +
 msm8974/libexternal/external.cpp            |  817 +++++++++++++
 msm8974/libexternal/external.h              |  105 ++
 msm8974/libgralloc/Android.mk               |   48 +
 msm8974/libgralloc/MODULE_LICENSE_APACHE2   |    0
 msm8974/libgralloc/NOTICE                   |  190 +++
 msm8974/libgralloc/alloc_controller.cpp     |  402 ++++++
 msm8974/libgralloc/alloc_controller.h       |   71 ++
 msm8974/libgralloc/fb_priv.h                |   59 +
 msm8974/libgralloc/framebuffer.cpp          |  410 +++++++
 msm8974/libgralloc/gpu.cpp                  |  401 ++++++
 msm8974/libgralloc/gpu.h                    |   75 ++
 msm8974/libgralloc/gr.h                     |  104 ++
 msm8974/libgralloc/gralloc.cpp              |  113 ++
 msm8974/libgralloc/gralloc_priv.h           |  248 ++++
 msm8974/libgralloc/ionalloc.cpp             |  231 ++++
 msm8974/libgralloc/ionalloc.h               |   74 ++
 msm8974/libgralloc/mapper.cpp               |  411 +++++++
 msm8974/libgralloc/memalloc.h               |   89 ++
 msm8974/libhwcomposer/Android.mk            |   27 +
 msm8974/libhwcomposer/hwc.cpp               |  734 +++++++++++
 msm8974/libhwcomposer/hwc_ad.cpp            |  262 ++++
 msm8974/libhwcomposer/hwc_ad.h              |   67 +
 msm8974/libhwcomposer/hwc_copybit.cpp       |  637 ++++++++++
 msm8974/libhwcomposer/hwc_copybit.h         |   90 ++
 msm8974/libhwcomposer/hwc_fbupdate.cpp      |  337 ++++++
 msm8974/libhwcomposer/hwc_fbupdate.h        |   85 ++
 msm8974/libhwcomposer/hwc_mdpcomp.cpp       | 1313 ++++++++++++++++++++
 msm8974/libhwcomposer/hwc_mdpcomp.h         |  242 ++++
 msm8974/libhwcomposer/hwc_qclient.cpp       |  111 ++
 msm8974/libhwcomposer/hwc_qclient.h         |   68 ++
 msm8974/libhwcomposer/hwc_uevents.cpp       |  213 ++++
 msm8974/libhwcomposer/hwc_utils.cpp         | 1217 +++++++++++++++++++
 msm8974/libhwcomposer/hwc_utils.h           |  419 +++++++
 msm8974/libhwcomposer/hwc_vsync.cpp         |  183 +++
 msm8974/liblight/Android.mk                 |   27 +
 msm8974/liblight/NOTICE                     |  190 +++
 msm8974/liblight/lights.c                   |  329 +++++
 msm8974/libmemtrack/Android.mk              |   26 +
 msm8974/libmemtrack/kgsl.c                  |  129 ++
 msm8974/libmemtrack/memtrack_msm.c          |   59 +
 msm8974/libmemtrack/memtrack_msm.h          |   24 +
 msm8974/liboverlay/Android.mk               |   22 +
 msm8974/liboverlay/mdpWrapper.h             |  361 ++++++
 msm8974/liboverlay/overlay.cpp              |  397 ++++++
 msm8974/liboverlay/overlay.h                |  279 +++++
 msm8974/liboverlay/overlayCtrl.cpp          |   90 ++
 msm8974/liboverlay/overlayCtrlData.h        |  274 +++++
 msm8974/liboverlay/overlayMdp.cpp           |  344 ++++++
 msm8974/liboverlay/overlayMdp.h             |  438 +++++++
 msm8974/liboverlay/overlayMdpRot.cpp        |  265 ++++
 msm8974/liboverlay/overlayMdssRot.cpp       |  294 +++++
 msm8974/liboverlay/overlayMem.h             |  211 ++++
 msm8974/liboverlay/overlayRotator.cpp       |  187 +++
 msm8974/liboverlay/overlayRotator.h         |  250 ++++
 msm8974/liboverlay/overlayUtils.cpp         |  487 ++++++++
 msm8974/liboverlay/overlayUtils.h           |  834 +++++++++++++
 msm8974/liboverlay/overlayWriteback.cpp     |  255 ++++
 msm8974/liboverlay/overlayWriteback.h       |  118 ++
 msm8974/liboverlay/pipes/overlay3DPipe.h    |  465 +++++++
 msm8974/liboverlay/pipes/overlayGenPipe.cpp |  179 +++
 msm8974/liboverlay/pipes/overlayGenPipe.h   |  101 ++
 msm8974/libqdutils/Android.mk               |   30 +
 msm8974/libqdutils/comptype.cpp             |   33 +
 msm8974/libqdutils/comptype.h               |   81 ++
 msm8974/libqdutils/idle_invalidator.cpp     |   92 ++
 msm8974/libqdutils/idle_invalidator.h       |   60 +
 msm8974/libqdutils/mdp_version.cpp          |  170 +++
 msm8974/libqdutils/mdp_version.h            |  120 ++
 msm8974/libqdutils/profiler.cpp             |  190 +++
 msm8974/libqdutils/profiler.h               |  108 ++
 msm8974/libqdutils/qdMetaData.cpp           |   95 ++
 msm8974/libqdutils/qdMetaData.h             |   94 ++
 msm8974/libqservice/Android.mk              |   20 +
 msm8974/libqservice/IQClient.cpp            |   75 ++
 msm8974/libqservice/IQClient.h              |   53 +
 msm8974/libqservice/IQService.cpp           |  163 +++
 msm8974/libqservice/IQService.h             |   69 ++
 msm8974/libqservice/QService.cpp            |   87 ++
 msm8974/libqservice/QService.h              |   59 +
 92 files changed, 22126 insertions(+)
 create mode 100644 msm8974/Android.mk
 create mode 100644 msm8974/common.mk
 create mode 100644 msm8974/libcopybit/Android.mk
 create mode 100644 msm8974/libcopybit/MODULE_LICENSE_APACHE2
 create mode 100644 msm8974/libcopybit/NOTICE
 create mode 100644 msm8974/libcopybit/c2d2.h
 create mode 100644 msm8974/libcopybit/copybit.cpp
 create mode 100644 msm8974/libcopybit/copybit.h
 create mode 100644 msm8974/libcopybit/copybit_c2d.cpp
 create mode 100644 msm8974/libcopybit/copybit_priv.h
 create mode 100644 msm8974/libcopybit/software_converter.cpp
 create mode 100644 msm8974/libcopybit/software_converter.h
 create mode 100644 msm8974/libexternal/Android.mk
 create mode 100644 msm8974/libexternal/external.cpp
 create mode 100644 msm8974/libexternal/external.h
 create mode 100644 msm8974/libgralloc/Android.mk
 create mode 100644 msm8974/libgralloc/MODULE_LICENSE_APACHE2
 create mode 100644 msm8974/libgralloc/NOTICE
 create mode 100644 msm8974/libgralloc/alloc_controller.cpp
 create mode 100644 msm8974/libgralloc/alloc_controller.h
 create mode 100644 msm8974/libgralloc/fb_priv.h
 create mode 100644 msm8974/libgralloc/framebuffer.cpp
 create mode 100644 msm8974/libgralloc/gpu.cpp
 create mode 100644 msm8974/libgralloc/gpu.h
 create mode 100644 msm8974/libgralloc/gr.h
 create mode 100644 msm8974/libgralloc/gralloc.cpp
 create mode 100644 msm8974/libgralloc/gralloc_priv.h
 create mode 100644 msm8974/libgralloc/ionalloc.cpp
 create mode 100644 msm8974/libgralloc/ionalloc.h
 create mode 100644 msm8974/libgralloc/mapper.cpp
 create mode 100644 msm8974/libgralloc/memalloc.h
 create mode 100644 msm8974/libhwcomposer/Android.mk
 create mode 100644 msm8974/libhwcomposer/hwc.cpp
 create mode 100644 msm8974/libhwcomposer/hwc_ad.cpp
 create mode 100644 msm8974/libhwcomposer/hwc_ad.h
 create mode 100644 msm8974/libhwcomposer/hwc_copybit.cpp
 create mode 100644 msm8974/libhwcomposer/hwc_copybit.h
 create mode 100644 msm8974/libhwcomposer/hwc_fbupdate.cpp
 create mode 100644 msm8974/libhwcomposer/hwc_fbupdate.h
 create mode 100644 msm8974/libhwcomposer/hwc_mdpcomp.cpp
 create mode 100644 msm8974/libhwcomposer/hwc_mdpcomp.h
 create mode 100644 msm8974/libhwcomposer/hwc_qclient.cpp
 create mode 100644 msm8974/libhwcomposer/hwc_qclient.h
 create mode 100644 msm8974/libhwcomposer/hwc_uevents.cpp
 create mode 100644 msm8974/libhwcomposer/hwc_utils.cpp
 create mode 100644 msm8974/libhwcomposer/hwc_utils.h
 create mode 100644 msm8974/libhwcomposer/hwc_vsync.cpp
 create mode 100644 msm8974/liblight/Android.mk
 create mode 100644 msm8974/liblight/NOTICE
 create mode 100644 msm8974/liblight/lights.c
 create mode 100644 msm8974/libmemtrack/Android.mk
 create mode 100644 msm8974/libmemtrack/kgsl.c
 create mode 100644 msm8974/libmemtrack/memtrack_msm.c
 create mode 100644 msm8974/libmemtrack/memtrack_msm.h
 create mode 100644 msm8974/liboverlay/Android.mk
 create mode 100644 msm8974/liboverlay/mdpWrapper.h
 create mode 100644 msm8974/liboverlay/overlay.cpp
 create mode 100644 msm8974/liboverlay/overlay.h
 create mode 100644 msm8974/liboverlay/overlayCtrl.cpp
 create mode 100644 msm8974/liboverlay/overlayCtrlData.h
 create mode 100644 msm8974/liboverlay/overlayMdp.cpp
 create mode 100644 msm8974/liboverlay/overlayMdp.h
 create mode 100755 msm8974/liboverlay/overlayMdpRot.cpp
 create mode 100644 msm8974/liboverlay/overlayMdssRot.cpp
 create mode 100644 msm8974/liboverlay/overlayMem.h
 create mode 100644 msm8974/liboverlay/overlayRotator.cpp
 create mode 100644 msm8974/liboverlay/overlayRotator.h
 create mode 100644 msm8974/liboverlay/overlayUtils.cpp
 create mode 100644 msm8974/liboverlay/overlayUtils.h
 create mode 100644 msm8974/liboverlay/overlayWriteback.cpp
 create mode 100644 msm8974/liboverlay/overlayWriteback.h
 create mode 100644 msm8974/liboverlay/pipes/overlay3DPipe.h
 create mode 100644 msm8974/liboverlay/pipes/overlayGenPipe.cpp
 create mode 100644 msm8974/liboverlay/pipes/overlayGenPipe.h
 create mode 100644 msm8974/libqdutils/Android.mk
 create mode 100644 msm8974/libqdutils/comptype.cpp
 create mode 100644 msm8974/libqdutils/comptype.h
 create mode 100644 msm8974/libqdutils/idle_invalidator.cpp
 create mode 100644 msm8974/libqdutils/idle_invalidator.h
 create mode 100644 msm8974/libqdutils/mdp_version.cpp
 create mode 100644 msm8974/libqdutils/mdp_version.h
 create mode 100644 msm8974/libqdutils/profiler.cpp
 create mode 100644 msm8974/libqdutils/profiler.h
 create mode 100644 msm8974/libqdutils/qdMetaData.cpp
 create mode 100644 msm8974/libqdutils/qdMetaData.h
 create mode 100644 msm8974/libqservice/Android.mk
 create mode 100644 msm8974/libqservice/IQClient.cpp
 create mode 100644 msm8974/libqservice/IQClient.h
 create mode 100644 msm8974/libqservice/IQService.cpp
 create mode 100644 msm8974/libqservice/IQService.h
 create mode 100644 msm8974/libqservice/QService.cpp
 create mode 100644 msm8974/libqservice/QService.h

diff --git a/msm8974/Android.mk b/msm8974/Android.mk
new file mode 100644
index 0000000..9deff29
--- /dev/null
+++ b/msm8974/Android.mk
@@ -0,0 +1,11 @@
+display-hals := libgralloc libgenlock libcopybit liblight
+display-hals += libhwcomposer liboverlay libqdutils libexternal libqservice
+display-hals += libmemtrack
+ifeq ($(call is-vendor-board-platform,QCOM),true)
+    include $(call all-named-subdir-makefiles,$(display-hals))
+else
+ifneq ($(filter msm8960 msm8974 msm8x74,$(TARGET_BOARD_PLATFORM)),)
+    #This is for mako since it doesn't have the QCOM make functions
+    include $(call all-named-subdir-makefiles,$(display-hals))
+endif
+endif
diff --git a/msm8974/common.mk b/msm8974/common.mk
new file mode 100644
index 0000000..10e4316
--- /dev/null
+++ b/msm8974/common.mk
@@ -0,0 +1,52 @@
+#Common headers
+common_includes := hardware/qcom/display/msm8974/libgralloc
+common_includes += hardware/qcom/display/msm8974/liboverlay
+common_includes += hardware/qcom/display/msm8974/libcopybit
+common_includes += hardware/qcom/display/msm8974/libqdutils
+common_includes += hardware/qcom/display/msm8974/libhwcomposer
+common_includes += hardware/qcom/display/msm8974/libexternal
+common_includes += hardware/qcom/display/msm8974/libqservice
+
+common_header_export_path := qcom/display
+
+#Common libraries external to display HAL
+common_libs := liblog libutils libcutils libhardware
+
+#Common C flags
+common_flags := -DDEBUG_CALC_FPS -Wno-missing-field-initializers
+common_flags += -Werror -Wno-unused-parameter
+
+ifeq ($(ARCH_ARM_HAVE_NEON),true)
+    common_flags += -D__ARM_HAVE_NEON
+endif
+
+ifneq ($(filter msm8974 msm8x74 msm8610 apq8084,$(TARGET_BOARD_PLATFORM)),)
+    common_flags += -DVENUS_COLOR_FORMAT
+    common_flags += -DMDSS_TARGET
+endif
+
+ifeq ($(TARGET_FORCE_HWC_FOR_VIRTUAL_DISPLAYS), true)
+    common_flags += -DFORCE_HWC_FOR_VIRTUAL_DISPLAYS
+endif
+
+common_deps  :=
+kernel_includes :=
+
+# Executed only on QCOM BSPs
+ifeq ($(TARGET_USES_QCOM_BSP),true)
+# On jb_mr2- dont enable QCOM Display features
+ifneq ($(call is-platform-sdk-version-at-least,18),true)
+# This flag is used to compile out any features that depend on framework changes
+    common_flags += -DQCOM_BSP
+    common_flags += -DANDROID_JELLYBEAN_MR1=1
+endif
+endif
+ifeq ($(call is-vendor-board-platform,QCOM),true)
+# This check is to pick the kernel headers from the right location.
+# If the macro above is defined, we make the assumption that we have the kernel
+# available in the build tree.
+# If the macro is not present, the headers are picked from hardware/qcom/msmXXXX
+# failing which, they are picked from bionic.
+    common_deps += $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
+    kernel_includes += $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
+endif
diff --git a/msm8974/libcopybit/Android.mk b/msm8974/libcopybit/Android.mk
new file mode 100644
index 0000000..7ec99da
--- /dev/null
+++ b/msm8974/libcopybit/Android.mk
@@ -0,0 +1,48 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH:= $(call my-dir)
+include $(LOCAL_PATH)/../common.mk
+
+include $(CLEAR_VARS)
+LOCAL_COPY_HEADERS_TO         := $(common_header_export_path)
+LOCAL_COPY_HEADERS            := copybit.h copybit_priv.h c2d2.h
+include $(BUILD_COPY_HEADERS)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE                  := copybit.$(TARGET_BOARD_PLATFORM)
+LOCAL_MODULE_PATH             := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_MODULE_TAGS             := optional
+LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)
+LOCAL_SHARED_LIBRARIES        := $(common_libs) libdl libmemalloc
+LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"qdcopybit\"
+LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
+
+ifeq ($(TARGET_USES_C2D_COMPOSITION),true)
+    LOCAL_CFLAGS += -DCOPYBIT_Z180=1 -DC2D_SUPPORT_DISPLAY=1
+    LOCAL_SRC_FILES := copybit_c2d.cpp software_converter.cpp
+    include $(BUILD_SHARED_LIBRARY)
+else
+    ifneq ($(call is-chipset-in-board-platform,msm7630),true)
+        ifeq ($(call is-board-platform-in-list,$(MSM7K_BOARD_PLATFORMS)),true)
+            LOCAL_CFLAGS += -DCOPYBIT_MSM7K=1
+            LOCAL_SRC_FILES := software_converter.cpp copybit.cpp
+            include $(BUILD_SHARED_LIBRARY)
+        endif
+        ifeq ($(call is-board-platform-in-list,msm8610),true)
+            LOCAL_SRC_FILES := software_converter.cpp copybit.cpp
+            include $(BUILD_SHARED_LIBRARY)
+        endif
+    endif
+endif
diff --git a/msm8974/libcopybit/MODULE_LICENSE_APACHE2 b/msm8974/libcopybit/MODULE_LICENSE_APACHE2
new file mode 100644
index 0000000..e69de29
diff --git a/msm8974/libcopybit/NOTICE b/msm8974/libcopybit/NOTICE
new file mode 100644
index 0000000..9c1e63a
--- /dev/null
+++ b/msm8974/libcopybit/NOTICE
@@ -0,0 +1,189 @@
+
+   Copyright (c) 2008, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
diff --git a/msm8974/libcopybit/c2d2.h b/msm8974/libcopybit/c2d2.h
new file mode 100644
index 0000000..886f38a
--- /dev/null
+++ b/msm8974/libcopybit/c2d2.h
@@ -0,0 +1,683 @@
+/* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation. nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __c2d2_h_
+#define __c2d2_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef C2D_API
+#define C2D_API /* define API export as needed */
+#endif
+#if !defined(int32) && !defined(_INT32_DEFINED)
+typedef int                     int32;
+#define _INT32_DEFINED
+#endif
+#if !defined(uint32) && !defined(_UINT32_DEFINED)
+typedef unsigned int            uint32;
+#define _UINT32_DEFINED
+#endif
+
+/*****************************************************************************/
+/*********************** Blit definitions *****************************/
+/*****************************************************************************/
+
+/* Status codes, returned by any blit function */
+typedef enum {
+    C2D_STATUS_OK              = 0,
+    C2D_STATUS_NOT_SUPPORTED   = 1,
+    C2D_STATUS_OUT_OF_MEMORY   = 2,
+    C2D_STATUS_INVALID_PARAM   = 3,
+    C2D_STATUS_SURFACE_IN_USE  = 4,
+} C2D_STATUS;
+
+
+/* Definitions of color format modes, used together with color formats */
+typedef enum {
+    C2D_FORMAT_PACK_INTO_32BIT   = (1 <<  8), /* pack into dword if set */
+    C2D_FORMAT_SWAP_ENDIANNESS   = (1 <<  9), /* swaps the order */
+    C2D_FORMAT_LINEAR_SPACE      = (1 << 10), /* linear color space */
+    C2D_FORMAT_PREMULTIPLIED     = (1 << 11), /* alpha premultiplied */
+    C2D_FORMAT_INVERT_ALPHA      = (1 << 12), /* inverts alpha */
+    C2D_FORMAT_DISABLE_ALPHA     = (1 << 13), /* disables alpha */
+    C2D_FORMAT_INTERLACED        = (1 << 14), /* YUV line-interlaced */
+    C2D_FORMAT_TRANSPARENT       = (1 << 15), /* YUV 1-bit alpha in Y */
+    C2D_FORMAT_MACROTILED        = (1 << 16), /* tiled in macro level */
+    C2D_FORMAT_TILED_4x4         = (1 << 17), /* 4x4 tiled format */
+    C2D_FORMAT_SWAP_RB           = (1 << 18), /* Swap R & B color components */
+} C2D_FORMAT_MODE;
+
+/* Definitions of supported RGB formats, used in C2D_RGB_SURFACE_DEF.
+ * The bits of each color channel are packed into a machine word
+ * representing a single pixel from left to right (MSB to LSB) in the
+ * order indicated by format name. For the sub-byte formats the pixels
+ * are packed into bytes from left to right (MSbit to LSBit).
+ * If the C2D_FORMAT_PACK_INTO_32BIT bit is set, the minimal
+ * machine word used for pixel storage is 32-bit and the whole word
+ * is reversed if endianness is swapped.
+ * If the C2D_FORMAT_SWAP_ENDIANNESS bit is set, the order within a
+ * minimal machine word representing a pixel
+ * is reversed for both sub-byte and multi-byte formats.
+ * If the C2D_FORMAT_LINEAR_SPACE bit is set, the color space of
+ * the formats below is considered linear, if applicable.
+ * If the C2D_FORMAT_PREMULTIPLIED bit is set, the color channels
+ * are premultiplied with the alpha, if applicable.
+ * If the C2D_FORMAT_INVERT_ALPHA bit is set, the alpha interpretation
+ * is inverted: 0 - opaque, 1 - transparent, if applicable.
+ * If the C2D_FORMAT_DISABLE_ALPHA bit is set, the alpha channel serves
+ * as a placeholder and is ignored during blit, if applicable.
+ * If the C2D_FORMAT_MACROTILED bit is set, the surface is in the
+ * tiled format : 64x32 for 8bpp, 32x32 for 16bpp formats  */
+typedef enum {
+    C2D_COLOR_FORMAT_1            = 0,   /* 1-bit alpha/color expansion */
+
+    C2D_COLOR_FORMAT_2_PALETTE    = 1,   /* 2-bit indices for palette */
+    C2D_COLOR_FORMAT_4_PALETTE    = 2,   /* 4-bit indices for palette */
+    C2D_COLOR_FORMAT_8_PALETTE    = 3,   /* 8-bit indices for palette */
+
+    C2D_COLOR_FORMAT_2_L          = 4,   /* 2-bit grayscale */
+    C2D_COLOR_FORMAT_4_L          = 5,   /* 4-bit grayscale */
+    C2D_COLOR_FORMAT_8_L          = 6,   /* 8-bit grayscale */
+
+    C2D_COLOR_FORMAT_2_A          = 7,   /* 2-bit alpha only */
+    C2D_COLOR_FORMAT_4_A          = 8,   /* 4-bit alpha only */
+    C2D_COLOR_FORMAT_8_A          = 9,   /* 8-bit alpha only */
+
+    C2D_COLOR_FORMAT_444_RGB      = 10,  /* 12-bit colors */
+    C2D_COLOR_FORMAT_565_RGB      = 11,  /* 16-bit colors */
+    C2D_COLOR_FORMAT_888_RGB      = 12,  /* 24-bit colors */
+
+    C2D_COLOR_FORMAT_1555_ARGB    = 13,  /* 16-bit colors (1-bit alpha) */
+    C2D_COLOR_FORMAT_4444_ARGB    = 14,  /* 16-bit colors (4-bit alpha) */
+    C2D_COLOR_FORMAT_8565_ARGB    = 15,  /* 24-bit colors (8-bit alpha) */
+    C2D_COLOR_FORMAT_8888_ARGB    = 16,  /* 32-bit colors (8-bit alpha) */
+
+    C2D_COLOR_FORMAT_5551_RGBA    = 17,  /* 16-bit colors (1-bit alpha) */
+    C2D_COLOR_FORMAT_4444_RGBA    = 18,  /* 16-bit colors (4-bit alpha) */
+    C2D_COLOR_FORMAT_5658_RGBA    = 19,  /* 24-bit colors (8-bit alpha) */
+    C2D_COLOR_FORMAT_8888_RGBA    = 20,  /* 32-bit colors (8-bit alpha) */
+
+    /* derived RGB color formats (base format + mode bits) */
+
+} C2D_RGB_FORMAT;
+
+/* Definitions of supported YUV formats, used in C2D_YUV_SURFACE_DEF.
+ * Each of Y,U,V channels usually takes 1 byte and therefore is
+ * individually addressable. The definitions below show how Y,U,V
+ * channels are packed into macropixels for each particular format.
+ * The order is from left (smaller byte addresses) to right (larger
+ * byte addresses). The first three digits (4xx) denote the chroma
+ * subsampling in standard YUV notation. The digits in the macropixel
+ * denote that the whole block (from the previous digit or from the
+ * beginning) has to be repeated the number of times. Underscores
+ * between Y,U,V channels are used to describe separate planes for
+ * planar YUV formats. Formats are mapped to numbers so that future
+ * versions with various YUV permutations are easy to add.
+ * If the C2D_FORMAT_INTERLACED bit is set, the line order is
+ * interlaced: 0,2,4,...1,3,5... if applicable.
+ * If the C2D_FORMAT_TRANSPARENT bit is set, the least significant
+ * bit of Y channel serves as alpha: 0 - transparent, 1 - opaque. */
+typedef enum {
+    C2D_COLOR_FORMAT_411_YYUYYV   = 110, /* packed, 12-bit         */
+    C2D_COLOR_FORMAT_411_YUYYVY   = 111, /* packed, 12-bit         */
+    C2D_COLOR_FORMAT_411_UYYVYY   = 112, /* packed, 12-bit, "Y411" */
+    C2D_COLOR_FORMAT_411_YUYV2Y4  = 116, /* packed, 12-bit         */
+    C2D_COLOR_FORMAT_411_UYVY2Y4  = 117, /* packed, 12-bit, "Y41P" */
+
+    C2D_COLOR_FORMAT_422_YUYV     = 120, /* packed, 16-bit, "YUY2" */
+    C2D_COLOR_FORMAT_422_UYVY     = 121, /* packed, 16-bit, "UYVY" */
+    C2D_COLOR_FORMAT_422_YVYU     = 122, /* packed, 16-bit, "YVYU" */
+    C2D_COLOR_FORMAT_422_VYUY     = 123, /* packed, 16-bit         */
+
+    C2D_COLOR_FORMAT_444_YUV      = 130, /* packed, 24-bit         */
+    C2D_COLOR_FORMAT_444_UYV      = 131, /* packed, 24-bit, "IYU2" */
+    C2D_COLOR_FORMAT_444_AYUV     = 136, /* packed, 24-bit, "AYUV" */
+
+    C2D_COLOR_FORMAT_410_Y_UV     = 150, /* planar, Y + interleaved UV */
+    C2D_COLOR_FORMAT_411_Y_UV     = 151, /* planar, Y + interleaved UV */
+    C2D_COLOR_FORMAT_420_Y_UV     = 152, /* planar, Y + interleaved UV */
+    C2D_COLOR_FORMAT_422_Y_UV     = 153, /* planar, Y + interleaved UV */
+    C2D_COLOR_FORMAT_444_Y_UV     = 154, /* planar, Y + interleaved UV */
+
+    C2D_COLOR_FORMAT_410_Y_VU     = 160, /* planar, Y + interleaved VU */
+    C2D_COLOR_FORMAT_411_Y_VU     = 161, /* planar, Y + interleaved VU */
+    C2D_COLOR_FORMAT_420_Y_VU     = 162, /* planar, Y + interleaved VU */
+    C2D_COLOR_FORMAT_422_Y_VU     = 163, /* planar, Y + interleaved VU */
+    C2D_COLOR_FORMAT_444_Y_VU     = 164, /* planar, Y + interleaved VU */
+
+    C2D_COLOR_FORMAT_410_Y_U_V    = 170, /* planar, Y + U + V separate */
+    C2D_COLOR_FORMAT_411_Y_U_V    = 171, /* planar, Y + U + V separate */
+    C2D_COLOR_FORMAT_420_Y_V_U    = 172, /* planar, Y + V + U separate */
+    C2D_COLOR_FORMAT_420_Y_U_V    = 173, /* planar, Y + U + V separate */
+    C2D_COLOR_FORMAT_422_Y_U_V    = 174, /* planar, Y + U + V separate */
+    C2D_COLOR_FORMAT_444_Y_U_V    = 175, /* planar, Y + U + V separate */
+
+    C2D_COLOR_FORMAT_800_Y        = 190, /* planar, Y only, grayscale */
+
+    /* derived YUV color formats (base format + mode bits), FOURCC */
+
+    C2D_COLOR_FORMAT_411_Y411     = 112,
+    C2D_COLOR_FORMAT_411_Y41P     = 117,
+    C2D_COLOR_FORMAT_411_IY41     = 117 | (1 << 14),
+    C2D_COLOR_FORMAT_411_Y41T     = 117 | (1 << 15),
+
+    C2D_COLOR_FORMAT_422_YUY2     = 120,
+    C2D_COLOR_FORMAT_422_IUYV     = 121 | (1 << 14),
+    C2D_COLOR_FORMAT_422_Y42T     = 121 | (1 << 15),
+    C2D_COLOR_FORMAT_444_IYU2     = 131,
+
+    C2D_COLOR_FORMAT_420_NV12     = 152,
+    C2D_COLOR_FORMAT_420_NV21     = 162,
+
+    C2D_COLOR_FORMAT_410_YUV9     = 170,
+    C2D_COLOR_FORMAT_410_YVU9     = 170,
+    C2D_COLOR_FORMAT_411_Y41B     = 171,
+    C2D_COLOR_FORMAT_420_YV12     = 172,
+    C2D_COLOR_FORMAT_420_IYUV     = 173,
+    C2D_COLOR_FORMAT_420_I420     = 173,
+    C2D_COLOR_FORMAT_422_YV16     = 174,
+    C2D_COLOR_FORMAT_422_Y42B     = 174,
+
+    C2D_COLOR_FORMAT_800_Y800     = 190,
+
+} C2D_YUV_FORMAT;
+
+
+/* Configuration bits, used in the config_mask field of C2D_OBJECT struct */
+typedef enum {
+    C2D_SOURCE_RECT_BIT      = (1 <<  0), /* enables source_rect field */
+    C2D_MIRROR_H_BIT         = (1 <<  1), /* enables horizontal flipping */
+    C2D_MIRROR_V_BIT         = (1 <<  2), /* enables vertical flipping */
+    C2D_SOURCE_TILE_BIT      = (1 <<  3), /* enables source surface tiling */
+    C2D_TARGET_RECT_BIT      = (1 <<  4), /* enables target_rect field */
+    C2D_ROTATE_BIT           = (1 <<  5), /* enables all rotation fields */
+    C2D_SCISSOR_RECT_BIT     = (1 <<  6), /* enables scissor_rect field */
+    C2D_MASK_SURFACE_BIT     = (1 <<  7), /* enables mask_surface_id field */
+    C2D_MASK_ALIGN_BIT       = (1 <<  8), /* aligns mask to source_rect */
+    C2D_MASK_SCALE_BIT       = (1 <<  9), /* enables mask surface scaling */
+    C2D_MASK_TILE_BIT        = (1 << 10), /* enables mask surface tiling */
+    C2D_GLOBAL_ALPHA_BIT     = (1 << 11), /* enables global_alpha field */
+    C2D_COLOR_KEY_BIT        = (1 << 12), /* enables color_key field */
+    C2D_NO_PIXEL_ALPHA_BIT   = (1 << 13), /* disables source alpha channel */
+    C2D_NO_BILINEAR_BIT      = (1 << 14), /* disables bilinear on scaling */
+    C2D_NO_ANTIALIASING_BIT  = (1 << 15), /* disables antialiasing on edges */
+    C2D_DRAW_LINE_BIT        = (1 << 16), /* enables line drawing with source rectangle */
+    C2D_DRAW_LINE_NOLAST     = (1 << 17), /* disable last pixel draw for line */
+} C2D_SOURCE_CONFIG;
+
+
+/* Target configuration bits, defines rotation + mirroring.
+ * Mirror is applied prior to rotation if enabled. */
+typedef enum {
+    C2D_TARGET_MIRROR_H        = (1 << 0), /* horizontal flip */
+    C2D_TARGET_MIRROR_V        = (1 << 1), /* vertical flip */
+    C2D_TARGET_ROTATE_0        = (0 << 2), /* no rotation */
+    C2D_TARGET_ROTATE_90       = (1 << 2), /* 90 degree rotation */
+    C2D_TARGET_ROTATE_180      = (2 << 2), /* 180 degree rotation */
+    C2D_TARGET_ROTATE_270      = (3 << 2), /* 270 degree rotation, 90 + 180 */
+    C2D_TARGET_MASK_ALIGN      = (1 << 4), /* aligns mask to target scissor */
+    C2D_TARGET_MASK_SCALE      = (1 << 5), /* enables mask scaling */
+    C2D_TARGET_MASK_TILE       = (1 << 6), /* enables mask tiling */
+    C2D_TARGET_COLOR_KEY       = (1 << 7), /* enables target_color_key */
+    C2D_TARGET_NO_PIXEL_ALPHA  = (1 << 8), /* disables target alpha channel */
+} C2D_TARGET_CONFIG;
+
+#define C2D_TARGET_ROTATION_MASK  (C2D_TARGET_ROTATE_90*3)
+
+/* Additional blend modes, can be used with both source and target configs.
+   If none of the below is set, the default "SRC over DST" is applied. */
+typedef enum {
+    C2D_ALPHA_BLEND_SRC_OVER   = (0  << 20), /* Default, Porter-Duff "SRC over DST" */
+    C2D_ALPHA_BLEND_SRC        = (1  << 20), /* Porter-Duff "SRC" */
+    C2D_ALPHA_BLEND_SRC_IN     = (2  << 20), /* Porter-Duff "SRC in DST" */
+    C2D_ALPHA_BLEND_DST_IN     = (3  << 20), /* Porter-Duff "DST in SRC" */
+    C2D_ALPHA_BLEND_SRC_OUT    = (4  << 20), /* Porter-Duff "SRC out DST" */
+    C2D_ALPHA_BLEND_DST_OUT    = (5  << 20), /* Porter-Duff "DST out SRC" */
+    C2D_ALPHA_BLEND_DST_OVER   = (6  << 20), /* Porter-Duff "DST over SRC" */
+    C2D_ALPHA_BLEND_SRC_ATOP   = (7  << 20), /* Porter-Duff "SRC ATOP" */
+    C2D_ALPHA_BLEND_DST_ATOP   = (8  << 20), /* Porter-Duff "DST ATOP" */
+    C2D_ALPHA_BLEND_XOR        = (9  << 20), /* Xor */
+    C2D_ALPHA_BLEND_MULTIPLY   = (10 << 20), /* OpenVG "MULTIPLY" */
+    C2D_ALPHA_BLEND_SCREEN     = (11 << 20), /* OpenVG "SCREEN" */
+    C2D_ALPHA_BLEND_DARKEN     = (12 << 20), /* OpenVG "DARKEN" */
+    C2D_ALPHA_BLEND_LIGHTEN    = (13 << 20), /* OpenVG "LIGHTEN" */
+    C2D_ALPHA_BLEND_ADDITIVE   = (14 << 20), /* OpenVG "ADDITIVE" */
+    C2D_ALPHA_BLEND_DIRECT     = (15 << 20), /* Direct alpha blitting */
+    C2D_ALPHA_BLEND_INVERTC    = (16 << 20), /* Invert color */
+    C2D_ALPHA_BLEND_NONE       = (1  << 25), /* disables alpha blending */
+} C2D_ALPHA_BLEND_MODE;
+
+/* Configuration bits, used in the config_mask field of C2D_OBJECT struct */
+typedef enum {
+    C2D_OVERRIDE_GLOBAL_TARGET_ROTATE_CONFIG = (1 << 27), /* Overrides TARGET Config */
+    C2D_OVERRIDE_TARGET_ROTATE_0             = (0 << 28), /* no rotation             */
+    C2D_OVERRIDE_TARGET_ROTATE_90            = (1 << 28), /* 90 degree rotation      */
+    C2D_OVERRIDE_TARGET_ROTATE_180           = (2 << 28), /* 180 degree rotation     */
+    C2D_OVERRIDE_TARGET_ROTATE_270           = (3 << 28), /* 270 degree rotation     */
+} C2D_SOURCE_TARGET_CONFIG;
+
+#define C2D_OVERRIDE_SOURCE_CONFIG_TARGET_ROTATION_SHIFT_MASK  28
+#define C2D_OVERRIDE_TARGET_CONFIG_TARGET_ROTATION_SHIFT_MASK  2
+
+
+/* Surface caps enumeration */
+typedef enum {
+    C2D_SOURCE          = (1 << 0), /* allows to use as a source */
+    C2D_TARGET          = (1 << 1), /* allows to use as a target */
+    C2D_MASK            = (1 << 2), /* allows to use as a mask */
+    C2D_PALETTE         = (1 << 3), /* allows to use as a palette */
+} C2D_SURFACE_BITS;
+
+/* Surface type enumeration */
+typedef enum {
+    C2D_SURFACE_RGB_HOST        = 1, /* Host memory RGB surface */
+    C2D_SURFACE_RGB_EXT         = 2, /* External memory RGB surface */
+    C2D_SURFACE_YUV_HOST        = 3, /* Host memory YUV surface */
+    C2D_SURFACE_YUV_EXT         = 4, /* External memory YUV surface */
+    C2D_SURFACE_WITH_PHYS       = (1<<3), /* physical address already mapped */
+                                        /* this bit is valid with HOST types */
+    C2D_SURFACE_WITH_PHYS_DUMMY = (1<<4), /* physical address already mapped */
+                                        /* this bit is valid with HOST types */
+} C2D_SURFACE_TYPE;
+
+/* Structure for registering a RGB buffer as a blit surface */
+typedef struct {
+    uint32 format;   /* RGB color format plus additional mode bits */
+    uint32 width;    /* defines width in pixels */
+    uint32 height;   /* defines height in pixels */
+    void  *buffer;   /* pointer to the RGB buffer */
+    void  *phys;     /* physical address */
+    int32  stride;   /* defines stride in bytes, negative stride is allowed */
+} C2D_RGB_SURFACE_DEF;
+
+/* Structure for registering a YUV plane(s) as a blit surface */
+typedef struct {
+    uint32 format;   /* YUV color format plus additional mode bits */
+    uint32 width;    /* defines width in pixels */
+    uint32 height;   /* defines height in pixels */
+    void  *plane0;  /* holds the whole buffer if YUV format is not planar */
+    void  *phys0;   /* physical address */
+    int32  stride0; /* stride in bytes if YUV format is not planar */
+    void  *plane1;  /* holds UV or VU plane for planar interleaved */
+    void  *phys1;   /* physical address */
+    int32  stride1; /* stride for UV or VU plane for planar interleaved */
+    void  *plane2;  /* holds the 3. plane, ignored if YUV format is not planar */
+    void  *phys2;    /* physical address */
+    int32  stride2; /* stride for the 3. plane, ignored if YUV format is not planar */
+} C2D_YUV_SURFACE_DEF;
+
+
+/* Rectangle definition */
+typedef struct {
+    int32 x;        /* upper-left x */
+    int32 y;        /* upper-left y */
+    int32 width;    /* width */
+    int32 height;   /* height */
+} C2D_RECT;
+
+/* C2D_OBJECT encapsulates the blit parameters for a source surface.
+ * The fg_color defines color in target format for bits equal to 1
+ * in the source C2D_COLOR_FORMAT_1 format. It also defines rendering
+ * color for all alpha-only source formats. If the surface_id is 0
+ * the fg_color defines a constant fill color used instead of the surface.
+ * The bg_color defines color in target format for bits equal to 0
+ * in the source C2D_COLOR_FORMAT_1 format, otherwise both are ignored.
+ * The palette_id is used for all palette source formats, otherwise ignored.
+
+ * The source_rect first defines the content of the source surface,
+ * it is then horizontally/vertically flipped if C2D_MIRROR_*_BIT is set,
+ * then scaled with bilinear interpolation to exactly fit target_rect
+ * or repeated across target_rect if C2D_SOURCE_TILE_BIT is set,
+ * target_rect is then rotated clockwise by an arbitrary angle in degrees
+ * around the rot_orig_x/y, defined relative to target_rect's top left point,
+ * and then clipped to scissor_rect defined in target coordinate system.
+
+ * Finally alpha blending is applied before pixels get written into the target.
+ * Surface's pixel alpha is combined with mask alpha and with global alpha.
+ * Mask surface follows all transformations applied to the source surface.
+ * Source color key defines transparent color, applied together with alpha. */
+typedef struct C2D_OBJECT_STR {
+    uint32 surface_id;      /* source surface */
+
+    uint32 fg_color;        /* foreground color */
+    uint32 bg_color;        /* background color */
+    uint32 palette_id;      /* one-dimensional horizontal palette surface */
+
+    uint32 config_mask;     /* defines which fields below are enabled */
+
+    C2D_RECT source_rect;  /* region of the source surface,   16.16 fp */
+    C2D_RECT target_rect;  /* position and scaling in target, 16.16 fp */
+
+    int32 rot_orig_x;       /* rotation origin relative to target_rect's... */
+    int32 rot_orig_y;       /* ...top left point,     both are 16.16 fp */
+    int32 rotation;         /* clock-wise rotation in degrees, 16.16 fp */
+
+    C2D_RECT scissor_rect; /* defines the clip rectangle in target surface */
+
+    uint32 mask_surface_id; /* source alpha-mask surface */
+    uint32 global_alpha;    /* 0 = fully transparent, 255 = fully opaque */
+    uint32 color_key;       /* transparent color for the source surface */
+
+    struct C2D_OBJECT_STR *next; /* pointer to the next object or NULL */
+} C2D_OBJECT;
+
+/* Configuration bits, driver capabilities used by 2Dapplications */
+typedef enum {
+    C2D_DRIVER_SUPPORTS_GLOBAL_ALPHA_OP           = (1 << 0),
+    C2D_DRIVER_SUPPORTS_TILE_OP                   = (1 << 1),
+    C2D_DRIVER_SUPPORTS_COLOR_KEY_OP              = (1 << 2),
+    C2D_DRIVER_SUPPORTS_NO_PIXEL_ALPHA_OP         = (1 << 3),
+    C2D_DRIVER_SUPPORTS_TARGET_ROTATE_OP          = (1 << 4),
+    C2D_DRIVER_SUPPORTS_ANTI_ALIASING_OP          = (1 << 5), /* antialiasing */
+    C2D_DRIVER_SUPPORTS_BILINEAR_FILTER_OP        = (1 << 6),
+    C2D_DRIVER_SUPPORTS_LENS_CORRECTION_OP        = (1 << 7),
+    C2D_DRIVER_SUPPORTS_OVERRIDE_TARGET_ROTATE_OP = (1 << 8),
+    C2D_DRIVER_SUPPORTS_SHADER_BLOB_OP            = (1 << 9),
+    C2D_DRIVER_SUPPORTS_MASK_SURFACE_OP           = (1 << 10), /* mask surface */
+    C2D_DRIVER_SUPPORTS_MIRROR_H_OP               = (1 << 11), /* horizontal flip */
+    C2D_DRIVER_SUPPORTS_MIRROR_V_OP               = (1 << 12), /* vertical flip */
+    C2D_DRIVER_SUPPORTS_SCISSOR_RECT_OP           = (1 << 13),
+    C2D_DRIVER_SUPPORTS_SOURCE_RECT_OP            = (1 << 14),
+    C2D_DRIVER_SUPPORTS_TARGET_RECT_OP            = (1 << 15),
+    C2D_DRIVER_SUPPORTS_ROTATE_OP                 = (1 << 16), /* all rotations */
+    C2D_DRIVER_SUPPORTS_FLUSH_WITH_FENCE_FD_OP    = (1 << 17), /* all rotations */
+    C2D_DRIVER_SUPPORTS_ALL_CAPABILITIES_OP       = ((0xFFFFFFFF) >> (31 - 17)) /* mask for all capabilities supported */
+} C2D_DRIVER_CAPABILITIES;
+
+/* 2D driver workaround bits used by the 2D applications */
+typedef enum {
+    C2D_DRIVER_WORKAROUND_NONE  = 0, /* NO workaround */
+    C2D_DRIVER_WORKAROUND_SWAP_UV_FOR_YUV_TARGET  = (1 << 0), /* Swap UV when this flag set */
+} C2D_DRIVER_WORKAROUND;
+
+/* Structure to query Driver information */
+typedef struct {
+    uint32 capabilities_mask;
+    uint32 workaround_mask;
+    uint32 reserved1;
+    uint32 reserved2;
+    uint32 reserved3;
+} C2D_DRIVER_INFO;
+
+/* Structure to query Driver information */
+typedef struct {
+    uint32          max_surface_template_needed;
+    uint32          reserved1;
+    uint32          reserved2;
+    uint32          reserved3;
+} C2D_DRIVER_SETUP_INFO;
+
+/*****************************************************************************/
+/**************************** C2D API 2.0 ********************************/
+/*****************************************************************************/
+
+/******************************************************************************
+ * Functions to create/destroy surfaces */
+
+/* Creates a generic blit surface according to its type.
+ * Pass a combination of desired surface bits according to planned usage.
+ * Accepted values for surface_bits may include bits from C2D_SURFACE_BITS,
+ * and also from C2D_DISPLAY for compatibility with HW display controller.
+ * For host memory types the memory is preallocated outside the API
+ * and should remain valid until surface is destroyed.
+ * For external memory types the memory is allocated within API.
+ * On success, the non-zero surface identifier is returned.
+ * All numbers greater that 0 are valid surface identifiers, 0 is invalid.
+
+ * Host memory RGB surface:
+ * surface_type       = C2D_SURFACE_RGB_HOST
+ * surface_definition = C2D_RGB_SURFACE_DEF
+ * all fields in definition structure should be set
+
+ * External memory RGB surface:
+ * surface_type       = C2D_SURFACE_RGB_EXT
+ * surface_definition = C2D_RGB_SURFACE_DEF
+ * buffer field in definition structure is ignored
+
+ * Host memory YUV surface:
+ * surface_type       = C2D_SURFACE_YUV_HOST
+ * surface_definition = C2D_YUV_SURFACE_DEF
+ * one or all plane and stride fields in definition structure
+ * should be set depending on whether the format is planar or not
+
+ * External memory YUV surface:
+ * surface_type       = C2D_SURFACE_YUV_EXT
+ * surface_definition = C2D_YUV_SURFACE_DEF
+ * all plane and stride fields in definition structure are ignored */
+C2D_API C2D_STATUS c2dCreateSurface( uint32 *surface_id,
+                         uint32 surface_bits,
+                         C2D_SURFACE_TYPE surface_type,
+                         void *surface_definition );
+
+/* Requests properties of the specified surface. */
+C2D_API C2D_STATUS c2dQuerySurface( uint32 surface_id,
+                         uint32 *surface_bits,
+                         C2D_SURFACE_TYPE *surface_type,
+                         uint32 *width, uint32 *height,
+                         uint32 *format );
+
+/* Destroys a generic blit surface.
+ * For external memory surfaces also deallocates the memory.
+ * It is safe to free any external resources associated with a given
+ * surface on c2dCreateSurface call after this function returns. */
+C2D_API C2D_STATUS c2dDestroySurface( uint32 surface_id );
+
+
+/******************************************************************************
+ * Functions to modify/exchange surface data */
+
+/* The format of fill_color is the same as color format being used
+ * for specified surface. If fill_rect is NULL the whole surface is filled.
+ * Alpha-blending is not performed while filling.
+ * The operation is complete when function returns. */
+C2D_API C2D_STATUS c2dFillSurface( uint32 surface_id,
+                         uint32 fill_color,
+                         C2D_RECT *fill_rect );
+
+/* Writes data located in host memory into the specified surface.
+ * The chunk of host memory is identified with surface_type and
+ * surface_definition, no surface registration needed in this case.
+ * Only C2D_SURFACE_RGB_HOST, C2D_SURFACE_YUV_HOST are accepted.
+ * If only part of the host memory buffer should be loaded, it should
+ * be configured in surface_definition using width, height and stride.
+ * The x and y are defined in target surface coordinate space.
+ * Color conversion has to be done, if color formats differ.
+ * Alpha-blending is not performed while writing.
+ * The operation is complete when function returns. */
+C2D_API C2D_STATUS c2dWriteSurface( uint32 surface_id,
+                         C2D_SURFACE_TYPE surface_type,
+                         void *surface_definition,
+                         int32 x, int32 y );
+
+/* Reads data from the specified surface into the host memory.
+ * The chunk of host memory is identified with surface_type and
+ * surface_definition, no surface registration needed in this case.
+ * Only C2D_SURFACE_RGB_HOST, C2D_SURFACE_YUV_HOST are accepted.
+ * If only part of the surface should be read, it should
+ * be configured in surface_definition using width, height and stride.
+ * The x and y are defined in source surface coordinate space.
+ * Color conversion has to be done, if color formats differ.
+ * Alpha-blending is not performed while reading.
+ * The operation is complete when function returns. */
+C2D_API C2D_STATUS c2dReadSurface( uint32 surface_id,
+                         C2D_SURFACE_TYPE surface_type,
+                         void *surface_definition,
+                         int32 x, int32 y );
+
+/* Notifies c2d imlementation that surface has been updated from outside the API,
+ * if updated_rect is NULL then the whole surface has been updated. */
+C2D_API C2D_STATUS c2dSurfaceUpdated( uint32 surface_id,
+                         C2D_RECT *updated_rect );
+
+/* Updates surface information.
+ * Could be called only for host surfaces set with parameter "C2D_SURFACE_WITH_PHYS".
+ * Count for surface planes have to be same than for already allocated surface */
+C2D_API C2D_STATUS c2dUpdateSurface( uint32 surface_id,
+                         uint32 surface_bits,
+                         C2D_SURFACE_TYPE surface_type,
+                         void *surface_definition );
+
+/******************************************************************************
+ * Functions to do actual blit */
+
+/* Draw a list of blit objects into the given target.
+ * The target_config is a bitwise OR of values from C2D_TARGET_CONFIG.
+ * The target transformation creates the effect that target surface
+ * is transformed before the blit and then transformed back
+ * after blit, however no physical target transform is performed.
+ * The objects_list is a linked list of blit objects, no more
+ * than num_objects is drawn from the given list.
+ * If num_objects is 0, the whole list is drawn.
+ * The blit is not guaranteed to complete after function returns. */
+C2D_API C2D_STATUS c2dDraw( uint32 target_id,
+                         uint32 target_config, C2D_RECT *target_scissor,
+                         uint32 target_mask_id, uint32 target_color_key,
+                         C2D_OBJECT *objects_list, uint32 num_objects );
+
+
+/* timstamp set in the blit commands flush */
+typedef void*                   c2d_ts_handle;
+
+/* Forces any pending blit to complete for a given target.
+ * Non-blocking. All input surfaces for this target except those
+ * which are shared with other targets are expected to be immediately
+ * writable after client has been waiting returned timestamp with
+ * c2dWaitTimestamp funtion or c2dFinish has been called for same target */
+C2D_API C2D_STATUS c2dFlush( uint32 target_id, c2d_ts_handle *timestamp);
+
+
+/* Waits the pending timestamp */
+C2D_API C2D_STATUS c2dWaitTimestamp( c2d_ts_handle timestamp );
+
+
+/* Forces any pending blit to complete for a given target.
+ * Blocking version, returns when blit is done.
+ * All input surfaces for this target except those which are shared with
+ * other targets are expected to be immediately
+ * writable after this function returns. */
+C2D_API C2D_STATUS c2dFinish( uint32 target_id );
+
+
+/*****************************************************************************/
+/****************************** Display API **********************************/
+/*****************************************************************************/
+
+
+/* Display input enumeration */
+typedef enum {
+    C2D_DISPLAY_INPUT_0      = 0,       /*!< default input */
+    C2D_DISPLAY_INPUT_1      = (1<<16), /*!< Overlay 1     */
+    C2D_DISPLAY_INPUT_2      = (1<<17), /*!< Overlay 2...    */
+} C2D_DISPLAY_INPUT;
+
+
+/******************************************************************************
+ * Functions for display output. */
+
+/* Functionality described in this section is optional and is
+ * provided only for the cases when blit HW
+ * is tightly bound to the display controller. */
+
+/* Display enumeration, may also be used in surface caps */
+typedef enum {
+    C2D_DISPLAY_MAIN         = (1 << 10), /* main display */
+    C2D_DISPLAY_SECONDARY    = (1 << 11), /* secondary display */
+    C2D_DISPLAY_TV_OUT       = (1 << 12), /* tv-out */
+} C2D_DISPLAY;
+
+/* Display window enumeration */
+typedef enum {
+    C2D_DISPLAY_OVERLAY      = C2D_DISPLAY_INPUT_1, /*!< Overlay window bit. This defines display input.
+                                                When defined the surface is set on the overlay window
+                                                otherwise the surface is set on the background window. */
+} C2D_DISPLAY_WINDOW;                    /*!< Window bit set with display parameter */
+
+
+/* Display update modes */
+typedef enum {
+    C2D_DISPLAY_MODE_TEAR_SYNC   = (1 << 0), /* enables tearing sync */
+    C2D_DISPLAY_MODE_SURF_REMOVE = (1 << 1), /* Remove surface from given display + input */
+} C2D_DISPLAY_MODE;
+
+
+/* Sets the given surface as a current display front buffer.
+ * Several displays can be specified as an output if supported.
+ * Still only one input can be specified at a time fro display/displays.
+ * The surface remains shown until it gets replaced with another one. */
+C2D_API C2D_STATUS c2dDisplaySetSurface( uint32 display,
+                         uint32 surface_id, uint32 mode );
+
+/* Returns the current surface for a particular display.
+ * Only one display can be specified at a time.
+ * The latest surface set with compDisplaySetSurface or
+ * the default pre-allocated surface is returned. */
+C2D_API C2D_STATUS c2dDisplayGetSurface( uint32 display,
+                         uint32 *surface_id );
+
+/* Returns the properties for a particular display.
+ * Only one display can be specified at a time. */
+C2D_API C2D_STATUS c2dDisplayGetProperties( uint32 display,
+                         uint32 *width, uint32 *height,
+                         uint32 *format );
+
+/* Sets the properties for a particular display input.
+ * Only one display + input can be specified at a time.
+ * C2D_OBJECT used to set input rect(target rect),
+ * blending operations, rotation...etc for display source */
+C2D_API C2D_STATUS c2dDisplaySetObject( uint32 display,
+                         uint32 target_config, uint32 target_color_key,
+                         C2D_OBJECT * c2dObject, uint32 mode);
+
+/* allows user to map a memory region to the gpu. only supported on linux
+ * mem_fd is the fd of the memory region, hostptr is the host pointer to the region,
+ * len and offset are the size and offset of the memory.
+ * flags is one of the memory types supported by gsl
+ * gpaddr is passed by refernce back to the user
+ */
+C2D_API C2D_STATUS c2dMapAddr ( int mem_fd, void * hostptr, uint32 len, uint32 offset, uint32 flags, void ** gpuaddr);
+
+/* allows user to unmap memory region mapped by c2dMapAddr.
+ * gpaddr is the gpuaddr to unmap */
+C2D_API C2D_STATUS c2dUnMapAddr (void * gpuaddr);
+
+/* allows user to query driver capabilities.
+ * driver_info is the information about driver */
+C2D_API C2D_STATUS c2dGetDriverCapabilities( C2D_DRIVER_INFO * driver_info);
+
+/* create a fence fd for the timestamp */
+C2D_API C2D_STATUS c2dCreateFenceFD( uint32 target_id, c2d_ts_handle timestamp, int32 *fd);
+
+/*****************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __c2d2_h_ */
diff --git a/msm8974/libcopybit/copybit.cpp b/msm8974/libcopybit/copybit.cpp
new file mode 100644
index 0000000..dc6e6df
--- /dev/null
+++ b/msm8974/libcopybit/copybit.cpp
@@ -0,0 +1,627 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2010 - 2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cutils/log.h>
+
+#include <linux/msm_mdp.h>
+#include <linux/fb.h>
+
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+
+#include <copybit.h>
+
+#include "gralloc_priv.h"
+#include "software_converter.h"
+
+#define DEBUG_MDP_ERRORS 1
+
+/******************************************************************************/
+
+#define MAX_SCALE_FACTOR    (4)
+#define MAX_DIMENSION       (4096)
+
+/******************************************************************************/
+struct blitReq{
+    struct  mdp_buf_sync sync;
+    uint32_t count;
+    struct mdp_blit_req req[10];
+};
+
+/** State information for each device instance */
+struct copybit_context_t {
+    struct copybit_device_t device;
+    int     mFD;
+    uint8_t mAlpha;
+    int     mFlags;
+    bool    mBlitToFB;
+    int     acqFence[MDP_MAX_FENCE_FD];
+    int     relFence;
+    struct  mdp_buf_sync sync;
+    struct  blitReq list;
+};
+
+/**
+ * Common hardware methods
+ */
+
+static int open_copybit(const struct hw_module_t* module, const char* name,
+                        struct hw_device_t** device);
+
+static struct hw_module_methods_t copybit_module_methods = {
+open:  open_copybit
+};
+
+/*
+ * The COPYBIT Module
+ */
+struct copybit_module_t HAL_MODULE_INFO_SYM = {
+common: {
+tag: HARDWARE_MODULE_TAG,
+     version_major: 1,
+     version_minor: 0,
+     id: COPYBIT_HARDWARE_MODULE_ID,
+     name: "QCT MSM7K COPYBIT Module",
+     author: "Google, Inc.",
+     methods: &copybit_module_methods
+        }
+};
+
+/******************************************************************************/
+
+/** min of int a, b */
+static inline int min(int a, int b) {
+    return (a<b) ? a : b;
+}
+
+/** max of int a, b */
+static inline int max(int a, int b) {
+    return (a>b) ? a : b;
+}
+
+/** scale each parameter by mul/div. Assume div isn't 0 */
+static inline void MULDIV(uint32_t *a, uint32_t *b, int mul, int div) {
+    if (mul != div) {
+        *a = (mul * *a) / div;
+        *b = (mul * *b) / div;
+    }
+}
+
+/** Determine the intersection of lhs & rhs store in out */
+static void intersect(struct copybit_rect_t *out,
+                      const struct copybit_rect_t *lhs,
+                      const struct copybit_rect_t *rhs) {
+    out->l = max(lhs->l, rhs->l);
+    out->t = max(lhs->t, rhs->t);
+    out->r = min(lhs->r, rhs->r);
+    out->b = min(lhs->b, rhs->b);
+}
+
+/** convert COPYBIT_FORMAT to MDP format */
+static int get_format(int format) {
+    switch (format) {
+        case HAL_PIXEL_FORMAT_RGB_565:       return MDP_RGB_565;
+        case HAL_PIXEL_FORMAT_RGBX_8888:     return MDP_RGBX_8888;
+        case HAL_PIXEL_FORMAT_RGB_888:       return MDP_RGB_888;
+        case HAL_PIXEL_FORMAT_RGBA_8888:     return MDP_RGBA_8888;
+        case HAL_PIXEL_FORMAT_BGRA_8888:     return MDP_BGRA_8888;
+        case HAL_PIXEL_FORMAT_YCrCb_422_SP:  return MDP_Y_CRCB_H2V1;
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:  return MDP_Y_CRCB_H2V2;
+        case HAL_PIXEL_FORMAT_YCbCr_422_SP:  return MDP_Y_CBCR_H2V1;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:  return MDP_Y_CBCR_H2V2;
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP_ADRENO: return MDP_Y_CBCR_H2V2_ADRENO;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS: return MDP_Y_CBCR_H2V2_VENUS;
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE: return MDP_Y_CBCR_H2V2;
+    }
+    return -1;
+}
+
+/** convert from copybit image to mdp image structure */
+static void set_image(struct mdp_img *img, const struct copybit_image_t *rhs)
+{
+    private_handle_t* hnd = (private_handle_t*)rhs->handle;
+    if(hnd == NULL){
+        ALOGE("copybit: Invalid handle");
+        return;
+    }
+    img->width      = rhs->w;
+    img->height     = rhs->h;
+    img->format     = get_format(rhs->format);
+    img->offset     = hnd->offset;
+    img->memory_id  = hnd->fd;
+}
+/** setup rectangles */
+static void set_rects(struct copybit_context_t *dev,
+                      struct mdp_blit_req *e,
+                      const struct copybit_rect_t *dst,
+                      const struct copybit_rect_t *src,
+                      const struct copybit_rect_t *scissor,
+                      uint32_t horiz_padding,
+                      uint32_t vert_padding) {
+    struct copybit_rect_t clip;
+    intersect(&clip, scissor, dst);
+
+    e->dst_rect.x  = clip.l;
+    e->dst_rect.y  = clip.t;
+    e->dst_rect.w  = clip.r - clip.l;
+    e->dst_rect.h  = clip.b - clip.t;
+
+    uint32_t W, H, delta_x, delta_y;
+    if (dev->mFlags & COPYBIT_TRANSFORM_ROT_90) {
+        delta_x = (clip.t - dst->t);
+        delta_y = (dst->r - clip.r);
+        e->src_rect.w = (clip.b - clip.t);
+        e->src_rect.h = (clip.r - clip.l);
+        W = dst->b - dst->t;
+        H = dst->r - dst->l;
+    } else {
+        delta_x  = (clip.l - dst->l);
+        delta_y  = (clip.t - dst->t);
+        e->src_rect.w  = (clip.r - clip.l);
+        e->src_rect.h  = (clip.b - clip.t);
+        W = dst->r - dst->l;
+        H = dst->b - dst->t;
+    }
+
+    MULDIV(&delta_x, &e->src_rect.w, src->r - src->l, W);
+    MULDIV(&delta_y, &e->src_rect.h, src->b - src->t, H);
+
+    e->src_rect.x = delta_x + src->l;
+    e->src_rect.y = delta_y + src->t;
+
+    if (dev->mFlags & COPYBIT_TRANSFORM_FLIP_V) {
+        if (dev->mFlags & COPYBIT_TRANSFORM_ROT_90) {
+            e->src_rect.x = (src->l + src->r) - (e->src_rect.x + e->src_rect.w);
+        }else{
+            e->src_rect.y = (src->t + src->b) - (e->src_rect.y + e->src_rect.h);
+        }
+    }
+
+    if (dev->mFlags & COPYBIT_TRANSFORM_FLIP_H) {
+        if (dev->mFlags & COPYBIT_TRANSFORM_ROT_90) {
+            e->src_rect.y = (src->t + src->b) - (e->src_rect.y + e->src_rect.h);
+        }else{
+            e->src_rect.x = (src->l + src->r) - (e->src_rect.x + e->src_rect.w);
+        }
+    }
+}
+
+/** setup mdp request */
+static void set_infos(struct copybit_context_t *dev,
+                      struct mdp_blit_req *req, int flags)
+{
+    req->alpha = dev->mAlpha;
+    req->transp_mask = MDP_TRANSP_NOP;
+    req->flags = dev->mFlags | flags;
+    // check if we are blitting to f/b
+    if (COPYBIT_ENABLE == dev->mBlitToFB) {
+        req->flags |= MDP_MEMORY_ID_TYPE_FB;
+    }
+#if defined(COPYBIT_QSD8K)
+    req->flags |= MDP_BLEND_FG_PREMULT;
+#endif
+}
+
+/** copy the bits */
+static int msm_copybit(struct copybit_context_t *dev, void const *list)
+{
+    int err = ioctl(dev->mFD, MSMFB_ASYNC_BLIT,
+                    (struct mdp_async_blit_req_list const*)list);
+    ALOGE_IF(err<0, "copyBits failed (%s)", strerror(errno));
+    if (err == 0) {
+        return 0;
+    } else {
+#if DEBUG_MDP_ERRORS
+        struct mdp_async_blit_req_list const* l =
+            (struct mdp_async_blit_req_list const*)list;
+        for (unsigned int i=0 ; i<l->count ; i++) {
+            ALOGE("%d: src={w=%d, h=%d, f=%d, rect={%d,%d,%d,%d}}\n"
+                  "    dst={w=%d, h=%d, f=%d, rect={%d,%d,%d,%d}}\n"
+                  "    flags=%08x"
+                  ,
+                  i,
+                  l->req[i].src.width,
+                  l->req[i].src.height,
+                  l->req[i].src.format,
+                  l->req[i].src_rect.x,
+                  l->req[i].src_rect.y,
+                  l->req[i].src_rect.w,
+                  l->req[i].src_rect.h,
+                  l->req[i].dst.width,
+                  l->req[i].dst.height,
+                  l->req[i].dst.format,
+                  l->req[i].dst_rect.x,
+                  l->req[i].dst_rect.y,
+                  l->req[i].dst_rect.w,
+                  l->req[i].dst_rect.h,
+                  l->req[i].flags
+                 );
+        }
+#endif
+        return -errno;
+    }
+}
+
+/*****************************************************************************/
+
+/** Set a parameter to value */
+static int set_parameter_copybit(
+    struct copybit_device_t *dev,
+    int name,
+    int value)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    int status = 0;
+    if (ctx) {
+        switch(name) {
+            case COPYBIT_ROTATION_DEG:
+                switch (value) {
+                    case 0:
+                        ctx->mFlags &= ~0x7;
+                        break;
+                    case 90:
+                        ctx->mFlags &= ~0x7;
+                        ctx->mFlags |= MDP_ROT_90;
+                        break;
+                    case 180:
+                        ctx->mFlags &= ~0x7;
+                        ctx->mFlags |= MDP_ROT_180;
+                        break;
+                    case 270:
+                        ctx->mFlags &= ~0x7;
+                        ctx->mFlags |= MDP_ROT_270;
+                        break;
+                    default:
+                        ALOGE("Invalid value for COPYBIT_ROTATION_DEG");
+                        status = -EINVAL;
+                        break;
+                }
+                break;
+            case COPYBIT_PLANE_ALPHA:
+                if (value < 0)      value = MDP_ALPHA_NOP;
+                if (value >= 256)   value = 255;
+                ctx->mAlpha = value;
+                break;
+            case COPYBIT_DITHER:
+                if (value == COPYBIT_ENABLE) {
+                    ctx->mFlags |= MDP_DITHER;
+                } else if (value == COPYBIT_DISABLE) {
+                    ctx->mFlags &= ~MDP_DITHER;
+                }
+                break;
+            case COPYBIT_BLUR:
+                if (value == COPYBIT_ENABLE) {
+                    ctx->mFlags |= MDP_BLUR;
+                } else if (value == COPYBIT_DISABLE) {
+                    ctx->mFlags &= ~MDP_BLUR;
+                }
+                break;
+            case COPYBIT_BLEND_MODE:
+                if(value == COPYBIT_BLENDING_PREMULT) {
+                    ctx->mFlags |= MDP_BLEND_FG_PREMULT;
+                } else {
+                    ctx->mFlags &= ~MDP_BLEND_FG_PREMULT;
+                }
+                break;
+            case COPYBIT_TRANSFORM:
+                ctx->mFlags &= ~0x7;
+                ctx->mFlags |= value & 0x7;
+                break;
+            case COPYBIT_BLIT_TO_FRAMEBUFFER:
+                if (COPYBIT_ENABLE == value) {
+                    ctx->mBlitToFB = value;
+                } else if (COPYBIT_DISABLE == value) {
+                    ctx->mBlitToFB = value;
+                } else {
+                    ALOGE ("%s:Invalid input for COPYBIT_BLIT_TO_FRAMEBUFFER : %d",
+                            __FUNCTION__, value);
+                }
+                break;
+            case COPYBIT_FG_LAYER:
+                if(value == COPYBIT_ENABLE) {
+                     ctx->mFlags |= MDP_IS_FG;
+                } else if (value == COPYBIT_DISABLE) {
+                    ctx->mFlags &= ~MDP_IS_FG;
+                }
+                break ;
+            default:
+                status = -EINVAL;
+                break;
+        }
+    } else {
+        status = -EINVAL;
+    }
+    return status;
+}
+
+/** Get a static info value */
+static int get(struct copybit_device_t *dev, int name)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    int value;
+    if (ctx) {
+        switch(name) {
+            case COPYBIT_MINIFICATION_LIMIT:
+                value = MAX_SCALE_FACTOR;
+                break;
+            case COPYBIT_MAGNIFICATION_LIMIT:
+                value = MAX_SCALE_FACTOR;
+                break;
+            case COPYBIT_SCALING_FRAC_BITS:
+                value = 32;
+                break;
+            case COPYBIT_ROTATION_STEP_DEG:
+                value = 90;
+                break;
+            default:
+                value = -EINVAL;
+        }
+    } else {
+        value = -EINVAL;
+    }
+    return value;
+}
+
+static int set_sync_copybit(struct copybit_device_t *dev,
+    int acquireFenceFd)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    if (acquireFenceFd != -1) {
+        if (ctx->list.sync.acq_fen_fd_cnt < (MDP_MAX_FENCE_FD - 1)) {
+            ctx->acqFence[ctx->list.sync.acq_fen_fd_cnt++] = acquireFenceFd;
+        } else {
+            int ret = -EINVAL;
+            struct blitReq *list = &ctx->list;
+
+            // Since fence is full kick off what is already in the list
+            ret = msm_copybit(ctx, list);
+            if (ret < 0) {
+                ALOGE("%s: Blit call failed", __FUNCTION__);
+                return -EINVAL;
+            }
+            list->count = 0;
+            list->sync.acq_fen_fd_cnt = 0;
+            ctx->acqFence[list->sync.acq_fen_fd_cnt++] = acquireFenceFd;
+            ctx->relFence = -1;
+        }
+    }
+    return 0;
+}
+
+/** do a stretch blit type operation */
+static int stretch_copybit(
+    struct copybit_device_t *dev,
+    struct copybit_image_t const *dst,
+    struct copybit_image_t const *src,
+    struct copybit_rect_t const *dst_rect,
+    struct copybit_rect_t const *src_rect,
+    struct copybit_region_t const *region)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    struct blitReq *list;
+    int status = 0;
+    private_handle_t *yv12_handle = NULL;
+
+    if (ctx) {
+        list = &ctx->list;
+
+        if (ctx->mAlpha < 255) {
+            switch (src->format) {
+                // we don't support plane alpha with RGBA formats
+                case HAL_PIXEL_FORMAT_RGBA_8888:
+                case HAL_PIXEL_FORMAT_BGRA_8888:
+                    ALOGE ("%s : Unsupported Pixel format %d", __FUNCTION__,
+                           src->format);
+                    return -EINVAL;
+            }
+        }
+
+        if (src_rect->l < 0 || (uint32_t)src_rect->r > src->w ||
+            src_rect->t < 0 || (uint32_t)src_rect->b > src->h) {
+            // this is always invalid
+            ALOGE ("%s : Invalid source rectangle : src_rect l %d t %d r %d b %d",\
+                   __FUNCTION__, src_rect->l, src_rect->t, src_rect->r, src_rect->b);
+
+            return -EINVAL;
+        }
+
+        if (src->w > MAX_DIMENSION || src->h > MAX_DIMENSION) {
+            ALOGE ("%s : Invalid source dimensions w %d h %d", __FUNCTION__, src->w, src->h);
+            return -EINVAL;
+        }
+
+        if (dst->w > MAX_DIMENSION || dst->h > MAX_DIMENSION) {
+            ALOGE ("%s : Invalid DST dimensions w %d h %d", __FUNCTION__, dst->w, dst->h);
+            return -EINVAL;
+        }
+
+        if(src->format ==  HAL_PIXEL_FORMAT_YV12) {
+            int usage =
+            GRALLOC_USAGE_PRIVATE_IOMMU_HEAP | GRALLOC_USAGE_PRIVATE_UNCACHED;
+            if (0 == alloc_buffer(&yv12_handle,src->w,src->h,
+                                  src->format, usage)){
+                if(0 == convertYV12toYCrCb420SP(src,yv12_handle)){
+                    (const_cast<copybit_image_t *>(src))->format =
+                        HAL_PIXEL_FORMAT_YCrCb_420_SP;
+                    (const_cast<copybit_image_t *>(src))->handle =
+                        yv12_handle;
+                    (const_cast<copybit_image_t *>(src))->base =
+                        (void *)yv12_handle->base;
+                }
+                else{
+                    ALOGE("Error copybit conversion from yv12 failed");
+                    if(yv12_handle)
+                        free_buffer(yv12_handle);
+                    return -EINVAL;
+                }
+            }
+            else{
+                ALOGE("Error:unable to allocate memeory for yv12 software conversion");
+                return -EINVAL;
+            }
+        }
+        const uint32_t maxCount = sizeof(list->req)/sizeof(list->req[0]);
+        const struct copybit_rect_t bounds = { 0, 0, (int)dst->w, (int)dst->h };
+        struct copybit_rect_t clip;
+        status = 0;
+        while ((status == 0) && region->next(region, &clip)) {
+            intersect(&clip, &bounds, &clip);
+            mdp_blit_req* req = &list->req[list->count];
+            int flags = 0;
+
+            private_handle_t* src_hnd = (private_handle_t*)src->handle;
+            if(src_hnd != NULL && src_hnd->flags & private_handle_t::PRIV_FLAGS_DO_NOT_FLUSH) {
+                flags |=  MDP_BLIT_NON_CACHED;
+            }
+
+            set_infos(ctx, req, flags);
+            set_image(&req->dst, dst);
+            set_image(&req->src, src);
+            set_rects(ctx, req, dst_rect, src_rect, &clip, src->horiz_padding, src->vert_padding);
+
+            if (req->src_rect.w<=0 || req->src_rect.h<=0)
+                continue;
+
+            if (req->dst_rect.w<=0 || req->dst_rect.h<=0)
+                continue;
+
+            if (++list->count == maxCount) {
+                status = msm_copybit(ctx, list);
+                if (ctx->relFence != -1) {
+                    list->sync.acq_fen_fd_cnt = 0;
+                }
+                list->count = 0;
+            }
+        }
+        if(yv12_handle) {
+            //Before freeing the buffer we need buffer passed through blit call
+            if (list->count != 0) {
+                status = msm_copybit(ctx, list);
+                if (ctx->relFence != -1) {
+                    list->sync.acq_fen_fd_cnt = 0;
+                }
+                list->count = 0;
+            }
+            free_buffer(yv12_handle);
+        }
+    } else {
+        ALOGE ("%s : Invalid COPYBIT context", __FUNCTION__);
+        status = -EINVAL;
+    }
+    return status;
+}
+
+/** Perform a blit type operation */
+static int blit_copybit(
+    struct copybit_device_t *dev,
+    struct copybit_image_t const *dst,
+    struct copybit_image_t const *src,
+    struct copybit_region_t const *region)
+{
+    struct copybit_rect_t dr = { 0, 0, (int)dst->w, (int)dst->h };
+    struct copybit_rect_t sr = { 0, 0, (int)src->w, (int)src->h };
+    return stretch_copybit(dev, dst, src, &dr, &sr, region);
+}
+
+static int finish_copybit(struct copybit_device_t *dev)
+{
+    // NOP for MDP copybit
+    return 0;
+}
+
+/*****************************************************************************/
+
+/** Close the copybit device */
+static int close_copybit(struct hw_device_t *dev)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    if (ctx) {
+        close(ctx->mFD);
+        free(ctx);
+    }
+    return 0;
+}
+
+static int flush_get_fence(struct copybit_device_t *dev, int* fd)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    struct blitReq *list = &ctx->list;
+    int ret = -EINVAL;
+
+    if (list->count) {
+        ret = msm_copybit(ctx, list);
+        if (ret < 0)
+            ALOGE("%s: Blit call failed", __FUNCTION__);
+        list->count = 0;
+    }
+    *fd = ctx->relFence;
+    list->sync.acq_fen_fd_cnt = 0;
+    ctx->relFence = -1;
+    return ret;
+}
+
+/** Open a new instance of a copybit device using name */
+static int open_copybit(const struct hw_module_t* module, const char* name,
+                        struct hw_device_t** device)
+{
+    int status = -EINVAL;
+    copybit_context_t *ctx;
+    ctx = (copybit_context_t *)malloc(sizeof(copybit_context_t));
+    memset(ctx, 0, sizeof(*ctx));
+
+    ctx->device.common.tag = HARDWARE_DEVICE_TAG;
+    ctx->device.common.version = 1;
+    ctx->device.common.module = const_cast<hw_module_t*>(module);
+    ctx->device.common.close = close_copybit;
+    ctx->device.set_parameter = set_parameter_copybit;
+    ctx->device.get = get;
+    ctx->device.blit = blit_copybit;
+    ctx->device.set_sync = set_sync_copybit;
+    ctx->device.stretch = stretch_copybit;
+    ctx->device.finish = finish_copybit;
+    ctx->device.flush_get_fence = flush_get_fence;
+    ctx->mAlpha = MDP_ALPHA_NOP;
+    ctx->mFlags = 0;
+    ctx->sync.flags = 0;
+    ctx->sync.acq_fen_fd = ctx->acqFence;
+    ctx->sync.rel_fen_fd = &ctx->relFence;
+    ctx->list.count = 0;
+    ctx->list.sync.acq_fen_fd_cnt = 0;
+    ctx->list.sync.rel_fen_fd = ctx->sync.rel_fen_fd;
+    ctx->list.sync.acq_fen_fd = ctx->sync.acq_fen_fd;
+    ctx->mFD = open("/dev/graphics/fb0", O_RDWR, 0);
+    if (ctx->mFD < 0) {
+        status = errno;
+        ALOGE("Error opening frame buffer errno=%d (%s)",
+              status, strerror(status));
+        status = -status;
+    } else {
+        status = 0;
+        *device = &ctx->device.common;
+    }
+    return status;
+}
diff --git a/msm8974/libcopybit/copybit.h b/msm8974/libcopybit/copybit.h
new file mode 100644
index 0000000..13d78b5
--- /dev/null
+++ b/msm8974/libcopybit/copybit.h
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_COPYBIT_INTERFACE_H
+#define ANDROID_COPYBIT_INTERFACE_H
+
+#include <hardware/hardware.h>
+
+#include <stdint.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+/**
+ * The id of this module
+ */
+#define COPYBIT_HARDWARE_MODULE_ID "copybit"
+
+/**
+ * Name of the graphics device to open
+ */
+#define COPYBIT_HARDWARE_COPYBIT0 "copybit0"
+
+/* supported pixel-formats. these must be compatible with
+ * graphics/PixelFormat.java, ui/PixelFormat.h, pixelflinger/format.h
+ */
+enum {
+    COPYBIT_FORMAT_RGBA_8888    = HAL_PIXEL_FORMAT_RGBA_8888,
+    COPYBIT_FORMAT_RGBX_8888    = HAL_PIXEL_FORMAT_RGBX_8888,
+    COPYBIT_FORMAT_RGB_888      = HAL_PIXEL_FORMAT_RGB_888,
+    COPYBIT_FORMAT_RGB_565      = HAL_PIXEL_FORMAT_RGB_565,
+    COPYBIT_FORMAT_BGRA_8888    = HAL_PIXEL_FORMAT_BGRA_8888,
+    COPYBIT_FORMAT_YCbCr_422_SP = 0x10,
+    COPYBIT_FORMAT_YCrCb_420_SP = 0x11,
+};
+
+/* name for copybit_set_parameter */
+enum {
+    /* Default blit destination is offline buffer */
+    /* clients to set this to '1', if blitting to framebuffer */
+    /* and reset to '0', after calling blit/stretch */
+    COPYBIT_BLIT_TO_FRAMEBUFFER = 0,
+    /* rotation of the source image in degrees (0 to 359) */
+    COPYBIT_ROTATION_DEG    = 1,
+    /* plane alpha value */
+    COPYBIT_PLANE_ALPHA     = 2,
+    /* enable or disable dithering */
+    COPYBIT_DITHER          = 3,
+    /* transformation applied (this is a superset of COPYBIT_ROTATION_DEG) */
+    COPYBIT_TRANSFORM       = 4,
+    /* blurs the copied bitmap. The amount of blurring cannot be changed
+     * at this time. */
+    COPYBIT_BLUR            = 5,
+    /* Blend mode */
+    COPYBIT_BLEND_MODE  = 6,
+    /* FB width */
+    COPYBIT_FRAMEBUFFER_WIDTH = 7,
+    /* FB height */
+    COPYBIT_FRAMEBUFFER_HEIGHT = 8,
+    COPYBIT_FG_LAYER = 9,
+};
+
+/* values for copybit_set_parameter(COPYBIT_TRANSFORM) */
+enum {
+    /* flip source image horizontally */
+    COPYBIT_TRANSFORM_FLIP_H    = HAL_TRANSFORM_FLIP_H,
+    /* flip source image vertically */
+    COPYBIT_TRANSFORM_FLIP_V    = HAL_TRANSFORM_FLIP_V,
+    /* rotate source image 90 degres */
+    COPYBIT_TRANSFORM_ROT_90    = HAL_TRANSFORM_ROT_90,
+    /* rotate source image 180 degres */
+    COPYBIT_TRANSFORM_ROT_180   = HAL_TRANSFORM_ROT_180,
+    /* rotate source image 270 degres */
+    COPYBIT_TRANSFORM_ROT_270   = HAL_TRANSFORM_ROT_270,
+};
+
+/* enable/disable value copybit_set_parameter */
+enum {
+    COPYBIT_DISABLE = 0,
+    COPYBIT_ENABLE  = 1
+};
+
+/*
+ * copybit blending values. same as HWC blending values
+ */
+enum {
+    /* no blending */
+    COPYBIT_BLENDING_NONE     = 0x0100,
+
+    /* ONE / ONE_MINUS_SRC_ALPHA */
+    COPYBIT_BLENDING_PREMULT  = 0x0105,
+
+    /* SRC_ALPHA / ONE_MINUS_SRC_ALPHA */
+    COPYBIT_BLENDING_COVERAGE = 0x0405
+};
+
+/* use get_static_info() to query static informations about the hardware */
+enum {
+    /* Maximum amount of minification supported by the hardware*/
+    COPYBIT_MINIFICATION_LIMIT  = 1,
+    /* Maximum amount of magnification supported by the hardware */
+    COPYBIT_MAGNIFICATION_LIMIT = 2,
+    /* Number of fractional bits support by the scaling engine */
+    COPYBIT_SCALING_FRAC_BITS   = 3,
+    /* Supported rotation step in degres. */
+    COPYBIT_ROTATION_STEP_DEG   = 4,
+};
+
+/* Image structure */
+struct copybit_image_t {
+    /* width */
+    uint32_t    w;
+    /* height */
+    uint32_t    h;
+    /* format COPYBIT_FORMAT_xxx */
+    int32_t     format;
+    /* base of buffer with image */
+    void        *base;
+    /* handle to the image */
+    native_handle_t* handle;
+    /* number of pixels added for the stride */
+    uint32_t    horiz_padding;
+    /* number of pixels added for the vertical stride */
+    uint32_t    vert_padding;
+};
+
+/* Rectangle */
+struct copybit_rect_t {
+    /* left */
+    int l;
+    /* top */
+    int t;
+    /* right */
+    int r;
+    /* bottom */
+    int b;
+};
+
+/* Region */
+struct copybit_region_t {
+    int (*next)(struct copybit_region_t const *region, struct copybit_rect_t *rect);
+};
+
+/**
+ * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM
+ * and the fields of this data structure must begin with hw_module_t
+ * followed by module specific information.
+ */
+struct copybit_module_t {
+    struct hw_module_t common;
+};
+
+/**
+ * Every device data structure must begin with hw_device_t
+ * followed by module specific public methods and attributes.
+ */
+struct copybit_device_t {
+    struct hw_device_t common;
+
+    /**
+     * Set a copybit parameter.
+     *
+     * @param dev from open
+     * @param name one for the COPYBIT_NAME_xxx
+     * @param value one of the COPYBIT_VALUE_xxx
+     *
+     * @return 0 if successful
+     */
+    int (*set_parameter)(struct copybit_device_t *dev, int name, int value);
+
+    /**
+     * Get a static copybit information.
+     *
+     * @param dev from open
+     * @param name one of the COPYBIT_STATIC_xxx
+     *
+     * @return value or -EINVAL if error
+     */
+    int (*get)(struct copybit_device_t *dev, int name);
+
+    /**
+     * Execute the bit blit copy operation
+     *
+     * @param dev from open
+     * @param dst is the destination image
+     * @param src is the source image
+     * @param region the clip region
+     *
+     * @return 0 if successful
+     */
+    int (*blit)(struct copybit_device_t *dev,
+                struct copybit_image_t const *dst,
+                struct copybit_image_t const *src,
+                struct copybit_region_t const *region);
+
+    /**
+     * Give acquire fence to copybit to be used in upcoming stretch
+     * call
+     *
+     * @param dev from open
+     * @param acquireFenceFd is the acquire fence
+     *
+     * @return 0 if successful
+     */
+    int (*set_sync)(struct copybit_device_t *dev,
+                   int acquireFenceFd);
+
+    /**
+     * Execute the stretch bit blit copy operation
+     *
+     * @param dev from open
+     * @param dst is the destination image
+     * @param src is the source image
+     * @param dst_rect is the destination rectangle
+     * @param src_rect is the source rectangle
+     * @param region the clip region
+     *
+     * @return 0 if successful
+     */
+    int (*stretch)(struct copybit_device_t *dev,
+                   struct copybit_image_t const *dst,
+                   struct copybit_image_t const *src,
+                   struct copybit_rect_t const *dst_rect,
+                   struct copybit_rect_t const *src_rect,
+                   struct copybit_region_t const *region);
+
+  /**
+    * Execute the completion of the copybit draw operation.
+    *
+    * @param dev from open
+    *
+    * @return 0 if successful
+    */
+  int (*finish)(struct copybit_device_t *dev);
+
+  /**
+    * Trigger the copybit draw operation(async).
+    *
+    * @param dev from open
+    *
+    * @param fd - gets the fencefd
+    *
+    * @return 0 if successful
+    */
+  int (*flush_get_fence)(struct copybit_device_t *dev, int* fd);
+
+  /* Clears the buffer
+   */
+  int (*clear)(struct copybit_device_t *dev, struct copybit_image_t const *buf,
+               struct copybit_rect_t *rect);
+};
+
+
+/** convenience API for opening and closing a device */
+
+static inline int copybit_open(const struct hw_module_t* module,
+                               struct copybit_device_t** device) {
+    return module->methods->open(module,
+                                 COPYBIT_HARDWARE_COPYBIT0, (struct hw_device_t**)device);
+}
+
+static inline int copybit_close(struct copybit_device_t* device) {
+    return device->common.close(&device->common);
+}
+
+
+__END_DECLS
+
+#endif  // ANDROID_COPYBIT_INTERFACE_H
diff --git a/msm8974/libcopybit/copybit_c2d.cpp b/msm8974/libcopybit/copybit_c2d.cpp
new file mode 100644
index 0000000..914bed7
--- /dev/null
+++ b/msm8974/libcopybit/copybit_c2d.cpp
@@ -0,0 +1,1748 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <cutils/log.h>
+#include <sys/resource.h>
+#include <sys/prctl.h>
+
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+
+#include <linux/msm_kgsl.h>
+
+#include <EGL/eglplatform.h>
+#include <cutils/native_handle.h>
+#include <cutils/ashmem.h>
+#include <linux/ashmem.h>
+#include <gralloc_priv.h>
+
+#include <copybit.h>
+#include <alloc_controller.h>
+#include <memalloc.h>
+
+#include "c2d2.h"
+#include "software_converter.h"
+
+#include <dlfcn.h>
+
+using gralloc::IMemAlloc;
+using gralloc::IonController;
+using gralloc::alloc_data;
+
+C2D_STATUS (*LINK_c2dCreateSurface)( uint32 *surface_id,
+                                     uint32 surface_bits,
+                                     C2D_SURFACE_TYPE surface_type,
+                                     void *surface_definition );
+
+C2D_STATUS (*LINK_c2dUpdateSurface)( uint32 surface_id,
+                                     uint32 surface_bits,
+                                     C2D_SURFACE_TYPE surface_type,
+                                     void *surface_definition );
+
+C2D_STATUS (*LINK_c2dReadSurface)( uint32 surface_id,
+                                   C2D_SURFACE_TYPE surface_type,
+                                   void *surface_definition,
+                                   int32 x, int32 y );
+
+C2D_STATUS (*LINK_c2dDraw)( uint32 target_id,
+                            uint32 target_config, C2D_RECT *target_scissor,
+                            uint32 target_mask_id, uint32 target_color_key,
+                            C2D_OBJECT *objects_list, uint32 num_objects );
+
+C2D_STATUS (*LINK_c2dFinish)( uint32 target_id);
+
+C2D_STATUS (*LINK_c2dFlush)( uint32 target_id, c2d_ts_handle *timestamp);
+
+C2D_STATUS (*LINK_c2dWaitTimestamp)( c2d_ts_handle timestamp );
+
+C2D_STATUS (*LINK_c2dDestroySurface)( uint32 surface_id );
+
+C2D_STATUS (*LINK_c2dMapAddr) ( int mem_fd, void * hostptr, uint32 len,
+                                uint32 offset, uint32 flags, void ** gpuaddr);
+
+C2D_STATUS (*LINK_c2dUnMapAddr) ( void * gpuaddr);
+
+C2D_STATUS (*LINK_c2dGetDriverCapabilities) ( C2D_DRIVER_INFO * driver_info);
+
+/* create a fence fd for the timestamp */
+C2D_STATUS (*LINK_c2dCreateFenceFD) ( uint32 target_id, c2d_ts_handle timestamp,
+                                                            int32 *fd);
+
+C2D_STATUS (*LINK_c2dFillSurface) ( uint32 surface_id, uint32 fill_color,
+                                    C2D_RECT * fill_rect);
+
+/******************************************************************************/
+
+#if defined(COPYBIT_Z180)
+#define MAX_SCALE_FACTOR    (4096)
+#define MAX_DIMENSION       (4096)
+#else
+#error "Unsupported HW version"
+#endif
+
+// The following defines can be changed as required i.e. as we encounter
+// complex use cases.
+#define MAX_RGB_SURFACES 32       // Max. RGB layers currently supported per draw
+#define MAX_YUV_2_PLANE_SURFACES 4// Max. 2-plane YUV layers currently supported per draw
+#define MAX_YUV_3_PLANE_SURFACES 1// Max. 3-plane YUV layers currently supported per draw
+// +1 for the destination surface. We cannot have multiple destination surfaces.
+#define MAX_SURFACES (MAX_RGB_SURFACES + MAX_YUV_2_PLANE_SURFACES + MAX_YUV_3_PLANE_SURFACES + 1)
+#define NUM_SURFACE_TYPES 3      // RGB_SURFACE + YUV_SURFACE_2_PLANES + YUV_SURFACE_3_PLANES
+#define MAX_BLIT_OBJECT_COUNT 50 // Max. blit objects that can be passed per draw
+
+enum {
+    RGB_SURFACE,
+    YUV_SURFACE_2_PLANES,
+    YUV_SURFACE_3_PLANES
+};
+
+enum eConversionType {
+    CONVERT_TO_ANDROID_FORMAT,
+    CONVERT_TO_C2D_FORMAT
+};
+
+enum eC2DFlags {
+    FLAGS_PREMULTIPLIED_ALPHA  = 1<<0,
+    FLAGS_YUV_DESTINATION      = 1<<1,
+    FLAGS_TEMP_SRC_DST         = 1<<2
+};
+
+static gralloc::IAllocController* sAlloc = 0;
+/******************************************************************************/
+
+/** State information for each device instance */
+struct copybit_context_t {
+    struct copybit_device_t device;
+    // Templates for the various source surfaces. These templates are created
+    // to avoid the expensive create/destroy C2D Surfaces
+    C2D_OBJECT_STR blit_rgb_object[MAX_RGB_SURFACES];
+    C2D_OBJECT_STR blit_yuv_2_plane_object[MAX_YUV_2_PLANE_SURFACES];
+    C2D_OBJECT_STR blit_yuv_3_plane_object[MAX_YUV_3_PLANE_SURFACES];
+    C2D_OBJECT_STR blit_list[MAX_BLIT_OBJECT_COUNT]; // Z-ordered list of blit objects
+    C2D_DRIVER_INFO c2d_driver_info;
+    void *libc2d2;
+    alloc_data temp_src_buffer;
+    alloc_data temp_dst_buffer;
+    unsigned int dst[NUM_SURFACE_TYPES]; // dst surfaces
+    unsigned int mapped_gpu_addr[MAX_SURFACES]; // GPU addresses mapped inside copybit
+    int blit_rgb_count;         // Total RGB surfaces being blit
+    int blit_yuv_2_plane_count; // Total 2 plane YUV surfaces being
+    int blit_yuv_3_plane_count; // Total 3 plane YUV  surfaces being blit
+    int blit_count;             // Total blit objects.
+    unsigned int trg_transform;      /* target transform */
+    int fb_width;
+    int fb_height;
+    int src_global_alpha;
+    int config_mask;
+    int dst_surface_type;
+    bool is_premultiplied_alpha;
+    void* time_stamp;
+    bool dst_surface_mapped; // Set when dst surface is mapped to GPU addr
+    void* dst_surface_base; // Stores the dst surface addr
+
+    // used for signaling the wait thread
+    bool wait_timestamp;
+    pthread_t wait_thread_id;
+    bool stop_thread;
+    pthread_mutex_t wait_cleanup_lock;
+    pthread_cond_t wait_cleanup_cond;
+
+};
+
+struct bufferInfo {
+    int width;
+    int height;
+    int format;
+};
+
+struct yuvPlaneInfo {
+    int yStride;       //luma stride
+    int plane1_stride;
+    int plane2_stride;
+    int plane1_offset;
+    int plane2_offset;
+};
+
+/**
+ * Common hardware methods
+ */
+
+static int open_copybit(const struct hw_module_t* module, const char* name,
+                        struct hw_device_t** device);
+
+static struct hw_module_methods_t copybit_module_methods = {
+open:  open_copybit
+};
+
+/*
+ * The COPYBIT Module
+ */
+struct copybit_module_t HAL_MODULE_INFO_SYM = {
+common: {
+tag: HARDWARE_MODULE_TAG,
+     version_major: 1,
+     version_minor: 0,
+     id: COPYBIT_HARDWARE_MODULE_ID,
+     name: "QCT COPYBIT C2D 2.0 Module",
+     author: "Qualcomm",
+     methods: &copybit_module_methods
+        }
+};
+
+
+/* thread function which waits on the timeStamp and cleans up the surfaces */
+static void* c2d_wait_loop(void* ptr) {
+    copybit_context_t* ctx = (copybit_context_t*)(ptr);
+    char thread_name[64] = "copybitWaitThr";
+    prctl(PR_SET_NAME, (unsigned long) &thread_name, 0, 0, 0);
+    setpriority(PRIO_PROCESS, 0, HAL_PRIORITY_URGENT_DISPLAY);
+
+    while(ctx->stop_thread == false) {
+        pthread_mutex_lock(&ctx->wait_cleanup_lock);
+        while(ctx->wait_timestamp == false && !ctx->stop_thread) {
+            pthread_cond_wait(&(ctx->wait_cleanup_cond),
+                              &(ctx->wait_cleanup_lock));
+        }
+        if(ctx->wait_timestamp) {
+            if(LINK_c2dWaitTimestamp(ctx->time_stamp)) {
+                ALOGE("%s: LINK_c2dWaitTimeStamp ERROR!!", __FUNCTION__);
+            }
+            ctx->wait_timestamp = false;
+            // Unmap any mapped addresses.
+            for (int i = 0; i < MAX_SURFACES; i++) {
+                if (ctx->mapped_gpu_addr[i]) {
+                    LINK_c2dUnMapAddr( (void*)ctx->mapped_gpu_addr[i]);
+                    ctx->mapped_gpu_addr[i] = 0;
+                }
+            }
+            // Reset the counts after the draw.
+            ctx->blit_rgb_count = 0;
+            ctx->blit_yuv_2_plane_count = 0;
+            ctx->blit_yuv_3_plane_count = 0;
+            ctx->blit_count = 0;
+            ctx->dst_surface_mapped = false;
+            ctx->dst_surface_base = 0;
+        }
+        pthread_mutex_unlock(&ctx->wait_cleanup_lock);
+        if(ctx->stop_thread)
+            break;
+    }
+    pthread_exit(NULL);
+    return NULL;
+}
+
+
+/* convert COPYBIT_FORMAT to C2D format */
+static int get_format(int format) {
+    switch (format) {
+        case HAL_PIXEL_FORMAT_RGB_565:        return C2D_COLOR_FORMAT_565_RGB;
+        case HAL_PIXEL_FORMAT_RGBX_8888:      return C2D_COLOR_FORMAT_8888_ARGB |
+                                              C2D_FORMAT_SWAP_RB |
+                                                  C2D_FORMAT_DISABLE_ALPHA;
+        case HAL_PIXEL_FORMAT_RGBA_8888:      return C2D_COLOR_FORMAT_8888_ARGB |
+                                              C2D_FORMAT_SWAP_RB;
+        case HAL_PIXEL_FORMAT_BGRA_8888:      return C2D_COLOR_FORMAT_8888_ARGB;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:   return C2D_COLOR_FORMAT_420_NV12;
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:return C2D_COLOR_FORMAT_420_NV12;
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:   return C2D_COLOR_FORMAT_420_NV21;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED: return C2D_COLOR_FORMAT_420_NV12 |
+                                                  C2D_FORMAT_MACROTILED;
+        default:                              ALOGE("%s: invalid format (0x%x",
+                                                     __FUNCTION__, format);
+                                              return -EINVAL;
+    }
+    return -EINVAL;
+}
+
+/* Get the C2D formats needed for conversion to YUV */
+static int get_c2d_format_for_yuv_destination(int halFormat) {
+    switch (halFormat) {
+        // We do not swap the RB when the target is YUV
+        case HAL_PIXEL_FORMAT_RGBX_8888:      return C2D_COLOR_FORMAT_8888_ARGB |
+                                              C2D_FORMAT_DISABLE_ALPHA;
+        case HAL_PIXEL_FORMAT_RGBA_8888:      return C2D_COLOR_FORMAT_8888_ARGB;
+        // The U and V need to be interchanged when the target is YUV
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:   return C2D_COLOR_FORMAT_420_NV21;
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:return C2D_COLOR_FORMAT_420_NV21;
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:   return C2D_COLOR_FORMAT_420_NV12;
+        default:                              return get_format(halFormat);
+    }
+    return -EINVAL;
+}
+
+/* ------------------------------------------------------------------- *//*!
+ * \internal
+ * \brief Get the bpp for a particular color format
+ * \param color format
+ * \return bits per pixel
+ *//* ------------------------------------------------------------------- */
+int c2diGetBpp(int32 colorformat)
+{
+
+    int c2dBpp = 0;
+
+    switch(colorformat&0xFF)
+    {
+        case C2D_COLOR_FORMAT_4444_RGBA:
+        case C2D_COLOR_FORMAT_4444_ARGB:
+        case C2D_COLOR_FORMAT_1555_ARGB:
+        case C2D_COLOR_FORMAT_565_RGB:
+        case C2D_COLOR_FORMAT_5551_RGBA:
+            c2dBpp = 16;
+            break;
+        case C2D_COLOR_FORMAT_8888_RGBA:
+        case C2D_COLOR_FORMAT_8888_ARGB:
+            c2dBpp = 32;
+            break;
+        case C2D_COLOR_FORMAT_8_L:
+        case C2D_COLOR_FORMAT_8_A:
+            c2dBpp = 8;
+            break;
+        case C2D_COLOR_FORMAT_4_A:
+            c2dBpp = 4;
+            break;
+        case C2D_COLOR_FORMAT_1:
+            c2dBpp = 1;
+            break;
+        default:
+            ALOGE("%s ERROR", __func__);
+            break;
+    }
+    return c2dBpp;
+}
+
+static uint32 c2d_get_gpuaddr(copybit_context_t* ctx,
+                              struct private_handle_t *handle, int &mapped_idx)
+{
+    uint32 memtype, *gpuaddr = 0;
+    C2D_STATUS rc;
+    int freeindex = 0;
+    bool mapaddr = false;
+
+    if(!handle)
+        return 0;
+
+    if (handle->flags & (private_handle_t::PRIV_FLAGS_USES_PMEM |
+                         private_handle_t::PRIV_FLAGS_USES_PMEM_ADSP))
+        memtype = KGSL_USER_MEM_TYPE_PMEM;
+    else if (handle->flags & private_handle_t::PRIV_FLAGS_USES_ASHMEM)
+        memtype = KGSL_USER_MEM_TYPE_ASHMEM;
+    else if (handle->flags & private_handle_t::PRIV_FLAGS_USES_ION)
+        memtype = KGSL_USER_MEM_TYPE_ION;
+    else {
+        ALOGE("Invalid handle flags: 0x%x", handle->flags);
+        return 0;
+    }
+
+    // Check for a freeindex in the mapped_gpu_addr list
+    for (freeindex = 0; freeindex < MAX_SURFACES; freeindex++) {
+        if (ctx->mapped_gpu_addr[freeindex] == 0) {
+            // free index is available
+            // map GPU addr and use this as mapped_idx
+            mapaddr = true;
+            break;
+        }
+    }
+
+    if(mapaddr) {
+        rc = LINK_c2dMapAddr(handle->fd, (void*)handle->base, handle->size,
+                             handle->offset, memtype, (void**)&gpuaddr);
+
+        if (rc == C2D_STATUS_OK) {
+            // We have mapped the GPU address inside copybit. We need to unmap
+            // this address after the blit. Store this address
+            ctx->mapped_gpu_addr[freeindex] = (uint32) gpuaddr;
+            mapped_idx = freeindex;
+        }
+    }
+    return (uint32) gpuaddr;
+}
+
+static void unmap_gpuaddr(copybit_context_t* ctx, int mapped_idx)
+{
+    if (!ctx || (mapped_idx == -1))
+        return;
+
+    if (ctx->mapped_gpu_addr[mapped_idx]) {
+        LINK_c2dUnMapAddr( (void*)ctx->mapped_gpu_addr[mapped_idx]);
+        ctx->mapped_gpu_addr[mapped_idx] = 0;
+    }
+}
+
+static int is_supported_rgb_format(int format)
+{
+    switch(format) {
+        case HAL_PIXEL_FORMAT_RGBA_8888:
+        case HAL_PIXEL_FORMAT_RGBX_8888:
+        case HAL_PIXEL_FORMAT_RGB_565:
+        case HAL_PIXEL_FORMAT_BGRA_8888: {
+            return COPYBIT_SUCCESS;
+        }
+        default:
+            return COPYBIT_FAILURE;
+    }
+}
+
+static int get_num_planes(int format)
+{
+    switch(format) {
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED: {
+            return 2;
+        }
+        case HAL_PIXEL_FORMAT_YV12: {
+            return 3;
+        }
+        default:
+            return COPYBIT_FAILURE;
+    }
+}
+
+static int is_supported_yuv_format(int format)
+{
+    switch(format) {
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED: {
+            return COPYBIT_SUCCESS;
+        }
+        default:
+            return COPYBIT_FAILURE;
+    }
+}
+
+static int is_valid_destination_format(int format)
+{
+    if (format == HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED) {
+        // C2D does not support NV12Tile as a destination format.
+        return COPYBIT_FAILURE;
+    }
+    return COPYBIT_SUCCESS;
+}
+
+static int calculate_yuv_offset_and_stride(const bufferInfo& info,
+                                           yuvPlaneInfo& yuvInfo)
+{
+    int width  = info.width;
+    int height = info.height;
+    int format = info.format;
+
+    int aligned_height = 0;
+    int aligned_width = 0, size = 0;
+
+    switch (format) {
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED: {
+            /* NV12 Tile buffers have their luma height aligned to 32bytes and width
+             * aligned to 128 bytes. The chroma offset starts at an 8K boundary
+             */
+            aligned_height = ALIGN(height, 32);
+            aligned_width  = ALIGN(width, 128);
+            size = aligned_width * aligned_height;
+            yuvInfo.plane1_offset = ALIGN(size,8192);
+            yuvInfo.yStride = aligned_width;
+            yuvInfo.plane1_stride = aligned_width;
+            break;
+        }
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP: {
+            aligned_width = ALIGN(width, 32);
+            yuvInfo.yStride = aligned_width;
+            yuvInfo.plane1_stride = aligned_width;
+            if (HAL_PIXEL_FORMAT_NV12_ENCODEABLE == format) {
+                // The encoder requires a 2K aligned chroma offset
+                yuvInfo.plane1_offset = ALIGN(aligned_width * height, 2048);
+            } else
+                yuvInfo.plane1_offset = aligned_width * height;
+
+            break;
+        }
+        default: {
+            return COPYBIT_FAILURE;
+        }
+    }
+    return COPYBIT_SUCCESS;
+}
+
+/** create C2D surface from copybit image */
+static int set_image(copybit_context_t* ctx, uint32 surfaceId,
+                      const struct copybit_image_t *rhs,
+                      const eC2DFlags flags, int &mapped_idx)
+{
+    struct private_handle_t* handle = (struct private_handle_t*)rhs->handle;
+    C2D_SURFACE_TYPE surfaceType;
+    int status = COPYBIT_SUCCESS;
+    uint32 gpuaddr = 0;
+    int c2d_format;
+    mapped_idx = -1;
+
+    if (flags & FLAGS_YUV_DESTINATION) {
+        c2d_format = get_c2d_format_for_yuv_destination(rhs->format);
+    } else {
+        c2d_format = get_format(rhs->format);
+    }
+
+    if(c2d_format == -EINVAL) {
+        ALOGE("%s: invalid format", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    if(handle == NULL) {
+        ALOGE("%s: invalid handle", __func__);
+        return -EINVAL;
+    }
+
+    if (handle->gpuaddr == 0) {
+        gpuaddr = c2d_get_gpuaddr(ctx, handle, mapped_idx);
+        if(!gpuaddr) {
+            ALOGE("%s: c2d_get_gpuaddr failed", __FUNCTION__);
+            return COPYBIT_FAILURE;
+        }
+    } else {
+        gpuaddr = handle->gpuaddr;
+    }
+
+    /* create C2D surface */
+    if(is_supported_rgb_format(rhs->format) == COPYBIT_SUCCESS) {
+        /* RGB */
+        C2D_RGB_SURFACE_DEF surfaceDef;
+
+        surfaceType = (C2D_SURFACE_TYPE) (C2D_SURFACE_RGB_HOST | C2D_SURFACE_WITH_PHYS);
+
+        surfaceDef.phys = (void*) gpuaddr;
+        surfaceDef.buffer = (void*) (handle->base);
+
+        surfaceDef.format = c2d_format |
+            ((flags & FLAGS_PREMULTIPLIED_ALPHA) ? C2D_FORMAT_PREMULTIPLIED : 0);
+        surfaceDef.width = rhs->w;
+        surfaceDef.height = rhs->h;
+        int aligned_width = ALIGN(surfaceDef.width,32);
+        surfaceDef.stride = (aligned_width * c2diGetBpp(surfaceDef.format))>>3;
+
+        if(LINK_c2dUpdateSurface( surfaceId,C2D_TARGET | C2D_SOURCE, surfaceType,
+                                  &surfaceDef)) {
+            ALOGE("%s: RGB Surface c2dUpdateSurface ERROR", __FUNCTION__);
+            unmap_gpuaddr(ctx, mapped_idx);
+            status = COPYBIT_FAILURE;
+        }
+    } else if (is_supported_yuv_format(rhs->format) == COPYBIT_SUCCESS) {
+        C2D_YUV_SURFACE_DEF surfaceDef;
+        memset(&surfaceDef, 0, sizeof(surfaceDef));
+        surfaceType = (C2D_SURFACE_TYPE)(C2D_SURFACE_YUV_HOST | C2D_SURFACE_WITH_PHYS);
+        surfaceDef.format = c2d_format;
+
+        bufferInfo info;
+        info.width = rhs->w;
+        info.height = rhs->h;
+        info.format = rhs->format;
+
+        yuvPlaneInfo yuvInfo = {0};
+        status = calculate_yuv_offset_and_stride(info, yuvInfo);
+        if(status != COPYBIT_SUCCESS) {
+            ALOGE("%s: calculate_yuv_offset_and_stride error", __FUNCTION__);
+            unmap_gpuaddr(ctx, mapped_idx);
+        }
+
+        surfaceDef.width = rhs->w;
+        surfaceDef.height = rhs->h;
+        surfaceDef.plane0 = (void*) (handle->base);
+        surfaceDef.phys0 = (void*) (gpuaddr);
+        surfaceDef.stride0 = yuvInfo.yStride;
+
+        surfaceDef.plane1 = (void*) (handle->base + yuvInfo.plane1_offset);
+        surfaceDef.phys1 = (void*) (gpuaddr + yuvInfo.plane1_offset);
+        surfaceDef.stride1 = yuvInfo.plane1_stride;
+        if (3 == get_num_planes(rhs->format)) {
+            surfaceDef.plane2 = (void*) (handle->base + yuvInfo.plane2_offset);
+            surfaceDef.phys2 = (void*) (gpuaddr + yuvInfo.plane2_offset);
+            surfaceDef.stride2 = yuvInfo.plane2_stride;
+        }
+
+        if(LINK_c2dUpdateSurface( surfaceId,C2D_TARGET | C2D_SOURCE, surfaceType,
+                                  &surfaceDef)) {
+            ALOGE("%s: YUV Surface c2dUpdateSurface ERROR", __FUNCTION__);
+            unmap_gpuaddr(ctx, mapped_idx);
+            status = COPYBIT_FAILURE;
+        }
+    } else {
+        ALOGE("%s: invalid format 0x%x", __FUNCTION__, rhs->format);
+        unmap_gpuaddr(ctx, mapped_idx);
+        status = COPYBIT_FAILURE;
+    }
+
+    return status;
+}
+
+/** copy the bits */
+static int msm_copybit(struct copybit_context_t *ctx, unsigned int target)
+{
+    if (ctx->blit_count == 0) {
+        return COPYBIT_SUCCESS;
+    }
+
+    for (int i = 0; i < ctx->blit_count; i++)
+    {
+        ctx->blit_list[i].next = &(ctx->blit_list[i+1]);
+    }
+    ctx->blit_list[ctx->blit_count-1].next = NULL;
+    uint32_t target_transform = ctx->trg_transform;
+    if (ctx->c2d_driver_info.capabilities_mask &
+        C2D_DRIVER_SUPPORTS_OVERRIDE_TARGET_ROTATE_OP) {
+        // For A3xx - set 0x0 as the transform is set in the config_mask
+        target_transform = 0x0;
+    }
+    if(LINK_c2dDraw(target, target_transform, 0x0, 0, 0, ctx->blit_list,
+                    ctx->blit_count)) {
+        ALOGE("%s: LINK_c2dDraw ERROR", __FUNCTION__);
+        return COPYBIT_FAILURE;
+    }
+    return COPYBIT_SUCCESS;
+}
+
+
+
+static int flush_get_fence_copybit (struct copybit_device_t *dev, int* fd)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    int status = COPYBIT_FAILURE;
+    if (!ctx)
+        return COPYBIT_FAILURE;
+    pthread_mutex_lock(&ctx->wait_cleanup_lock);
+    status = msm_copybit(ctx, ctx->dst[ctx->dst_surface_type]);
+
+    if(LINK_c2dFlush(ctx->dst[ctx->dst_surface_type], &ctx->time_stamp)) {
+        ALOGE("%s: LINK_c2dFlush ERROR", __FUNCTION__);
+        // unlock the mutex and return failure
+        pthread_mutex_unlock(&ctx->wait_cleanup_lock);
+        return COPYBIT_FAILURE;
+    }
+    if(LINK_c2dCreateFenceFD(ctx->dst[ctx->dst_surface_type], ctx->time_stamp,
+                                                                        fd)) {
+        ALOGE("%s: LINK_c2dCreateFenceFD ERROR", __FUNCTION__);
+        status = COPYBIT_FAILURE;
+    }
+    if(status == COPYBIT_SUCCESS) {
+        //signal the wait_thread
+        ctx->wait_timestamp = true;
+        pthread_cond_signal(&ctx->wait_cleanup_cond);
+    }
+    pthread_mutex_unlock(&ctx->wait_cleanup_lock);
+    return status;
+}
+
+static int finish_copybit(struct copybit_device_t *dev)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    if (!ctx)
+        return COPYBIT_FAILURE;
+
+   int status = msm_copybit(ctx, ctx->dst[ctx->dst_surface_type]);
+
+   if(LINK_c2dFinish(ctx->dst[ctx->dst_surface_type])) {
+        ALOGE("%s: LINK_c2dFinish ERROR", __FUNCTION__);
+        return COPYBIT_FAILURE;
+    }
+
+    // Unmap any mapped addresses.
+    for (int i = 0; i < MAX_SURFACES; i++) {
+        if (ctx->mapped_gpu_addr[i]) {
+            LINK_c2dUnMapAddr( (void*)ctx->mapped_gpu_addr[i]);
+            ctx->mapped_gpu_addr[i] = 0;
+        }
+    }
+
+    // Reset the counts after the draw.
+    ctx->blit_rgb_count = 0;
+    ctx->blit_yuv_2_plane_count = 0;
+    ctx->blit_yuv_3_plane_count = 0;
+    ctx->blit_count = 0;
+    ctx->dst_surface_mapped = false;
+    ctx->dst_surface_base = 0;
+
+    return status;
+}
+
+static int clear_copybit(struct copybit_device_t *dev,
+                         struct copybit_image_t const *buf,
+                         struct copybit_rect_t *rect)
+{
+    int ret = COPYBIT_SUCCESS;
+    int flags = FLAGS_PREMULTIPLIED_ALPHA;
+    int mapped_dst_idx = -1;
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    C2D_RECT c2drect = {rect->l, rect->t, rect->r - rect->l, rect->b - rect->t};
+    pthread_mutex_lock(&ctx->wait_cleanup_lock);
+    if(!ctx->dst_surface_mapped) {
+        ret = set_image(ctx, ctx->dst[RGB_SURFACE], buf,
+                        (eC2DFlags)flags, mapped_dst_idx);
+        if(ret) {
+            ALOGE("%s: set_image error", __FUNCTION__);
+            unmap_gpuaddr(ctx, mapped_dst_idx);
+            pthread_mutex_unlock(&ctx->wait_cleanup_lock);
+            return COPYBIT_FAILURE;
+        }
+        //clear_copybit is the first call made by HWC for each composition
+        //with the dest surface, hence set dst_surface_mapped.
+        ctx->dst_surface_mapped = true;
+        ctx->dst_surface_base = buf->base;
+        ret = LINK_c2dFillSurface(ctx->dst[RGB_SURFACE], 0x0, &c2drect);
+    }
+    pthread_mutex_unlock(&ctx->wait_cleanup_lock);
+    return ret;
+}
+
+
+/** setup rectangles */
+static void set_rects(struct copybit_context_t *ctx,
+                      C2D_OBJECT *c2dObject,
+                      const struct copybit_rect_t *dst,
+                      const struct copybit_rect_t *src,
+                      const struct copybit_rect_t *scissor)
+{
+    // Set the target rect.
+    if((ctx->trg_transform & C2D_TARGET_ROTATE_90) &&
+       (ctx->trg_transform & C2D_TARGET_ROTATE_180)) {
+        /* target rotation is 270 */
+        c2dObject->target_rect.x        = (dst->t)<<16;
+        c2dObject->target_rect.y        = ctx->fb_width?(ALIGN(ctx->fb_width,32)- dst->r):dst->r;
+        c2dObject->target_rect.y        = c2dObject->target_rect.y<<16;
+        c2dObject->target_rect.height   = ((dst->r) - (dst->l))<<16;
+        c2dObject->target_rect.width    = ((dst->b) - (dst->t))<<16;
+    } else if(ctx->trg_transform & C2D_TARGET_ROTATE_90) {
+        c2dObject->target_rect.x        = ctx->fb_height?(ctx->fb_height - dst->b):dst->b;
+        c2dObject->target_rect.x        = c2dObject->target_rect.x<<16;
+        c2dObject->target_rect.y        = (dst->l)<<16;
+        c2dObject->target_rect.height   = ((dst->r) - (dst->l))<<16;
+        c2dObject->target_rect.width    = ((dst->b) - (dst->t))<<16;
+    } else if(ctx->trg_transform & C2D_TARGET_ROTATE_180) {
+        c2dObject->target_rect.y        = ctx->fb_height?(ctx->fb_height - dst->b):dst->b;
+        c2dObject->target_rect.y        = c2dObject->target_rect.y<<16;
+        c2dObject->target_rect.x        = ctx->fb_width?(ALIGN(ctx->fb_width,32) - dst->r):dst->r;
+        c2dObject->target_rect.x        = c2dObject->target_rect.x<<16;
+        c2dObject->target_rect.height   = ((dst->b) - (dst->t))<<16;
+        c2dObject->target_rect.width    = ((dst->r) - (dst->l))<<16;
+    } else {
+        c2dObject->target_rect.x        = (dst->l)<<16;
+        c2dObject->target_rect.y        = (dst->t)<<16;
+        c2dObject->target_rect.height   = ((dst->b) - (dst->t))<<16;
+        c2dObject->target_rect.width    = ((dst->r) - (dst->l))<<16;
+    }
+    c2dObject->config_mask |= C2D_TARGET_RECT_BIT;
+
+    // Set the source rect
+    c2dObject->source_rect.x        = (src->l)<<16;
+    c2dObject->source_rect.y        = (src->t)<<16;
+    c2dObject->source_rect.height   = ((src->b) - (src->t))<<16;
+    c2dObject->source_rect.width    = ((src->r) - (src->l))<<16;
+    c2dObject->config_mask |= C2D_SOURCE_RECT_BIT;
+
+    // Set the scissor rect
+    c2dObject->scissor_rect.x       = scissor->l;
+    c2dObject->scissor_rect.y       = scissor->t;
+    c2dObject->scissor_rect.height  = (scissor->b) - (scissor->t);
+    c2dObject->scissor_rect.width   = (scissor->r) - (scissor->l);
+    c2dObject->config_mask |= C2D_SCISSOR_RECT_BIT;
+}
+
+/*****************************************************************************/
+
+/** Set a parameter to value */
+static int set_parameter_copybit(
+    struct copybit_device_t *dev,
+    int name,
+    int value)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    int status = COPYBIT_SUCCESS;
+    if (!ctx) {
+        ALOGE("%s: null context", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    pthread_mutex_lock(&ctx->wait_cleanup_lock);
+    switch(name) {
+        case COPYBIT_PLANE_ALPHA:
+        {
+            if (value < 0)      value = 0;
+            if (value >= 256)   value = 255;
+
+            ctx->src_global_alpha = value;
+            if (value < 255)
+                ctx->config_mask |= C2D_GLOBAL_ALPHA_BIT;
+            else
+                ctx->config_mask &= ~C2D_GLOBAL_ALPHA_BIT;
+        }
+        break;
+        case COPYBIT_BLEND_MODE:
+        {
+            if (value == COPYBIT_BLENDING_NONE) {
+                ctx->config_mask |= C2D_ALPHA_BLEND_NONE;
+                ctx->is_premultiplied_alpha = true;
+            } else if (value == COPYBIT_BLENDING_PREMULT) {
+                ctx->is_premultiplied_alpha = true;
+            } else {
+                ctx->config_mask &= ~C2D_ALPHA_BLEND_NONE;
+            }
+        }
+        break;
+        case COPYBIT_TRANSFORM:
+        {
+            unsigned int transform = 0;
+            uint32 config_mask = 0;
+            config_mask |= C2D_OVERRIDE_GLOBAL_TARGET_ROTATE_CONFIG;
+            if((value & 0x7) == COPYBIT_TRANSFORM_ROT_180) {
+                transform = C2D_TARGET_ROTATE_180;
+                config_mask |= C2D_OVERRIDE_TARGET_ROTATE_180;
+            } else if((value & 0x7) == COPYBIT_TRANSFORM_ROT_270) {
+                transform = C2D_TARGET_ROTATE_90;
+                config_mask |= C2D_OVERRIDE_TARGET_ROTATE_90;
+            } else if(value == COPYBIT_TRANSFORM_ROT_90) {
+                transform = C2D_TARGET_ROTATE_270;
+                config_mask |= C2D_OVERRIDE_TARGET_ROTATE_270;
+            } else {
+                config_mask |= C2D_OVERRIDE_TARGET_ROTATE_0;
+                if(value & COPYBIT_TRANSFORM_FLIP_H) {
+                    config_mask |= C2D_MIRROR_H_BIT;
+                } else if(value & COPYBIT_TRANSFORM_FLIP_V) {
+                    config_mask |= C2D_MIRROR_V_BIT;
+                }
+            }
+
+            if (ctx->c2d_driver_info.capabilities_mask &
+                C2D_DRIVER_SUPPORTS_OVERRIDE_TARGET_ROTATE_OP) {
+                ctx->config_mask |= config_mask;
+            } else {
+                // The transform for this surface does not match the current
+                // target transform. Draw all previous surfaces. This will be
+                // changed once we have a new mechanism to send different
+                // target rotations to c2d.
+                finish_copybit(dev);
+            }
+            ctx->trg_transform = transform;
+        }
+        break;
+        case COPYBIT_FRAMEBUFFER_WIDTH:
+            ctx->fb_width = value;
+            break;
+        case COPYBIT_FRAMEBUFFER_HEIGHT:
+            ctx->fb_height = value;
+            break;
+        case COPYBIT_ROTATION_DEG:
+        case COPYBIT_DITHER:
+        case COPYBIT_BLUR:
+        case COPYBIT_BLIT_TO_FRAMEBUFFER:
+            // Do nothing
+            break;
+        default:
+            ALOGE("%s: default case param=0x%x", __FUNCTION__, name);
+            status = -EINVAL;
+            break;
+    }
+    pthread_mutex_unlock(&ctx->wait_cleanup_lock);
+    return status;
+}
+
+/** Get a static info value */
+static int get(struct copybit_device_t *dev, int name)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    int value;
+
+    if (!ctx) {
+        ALOGE("%s: null context error", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    switch(name) {
+        case COPYBIT_MINIFICATION_LIMIT:
+            value = MAX_SCALE_FACTOR;
+            break;
+        case COPYBIT_MAGNIFICATION_LIMIT:
+            value = MAX_SCALE_FACTOR;
+            break;
+        case COPYBIT_SCALING_FRAC_BITS:
+            value = 32;
+            break;
+        case COPYBIT_ROTATION_STEP_DEG:
+            value = 1;
+            break;
+        default:
+            ALOGE("%s: default case param=0x%x", __FUNCTION__, name);
+            value = -EINVAL;
+    }
+    return value;
+}
+
+static int is_alpha(int cformat)
+{
+    int alpha = 0;
+    switch (cformat & 0xFF) {
+        case C2D_COLOR_FORMAT_8888_ARGB:
+        case C2D_COLOR_FORMAT_8888_RGBA:
+        case C2D_COLOR_FORMAT_5551_RGBA:
+        case C2D_COLOR_FORMAT_4444_ARGB:
+            alpha = 1;
+            break;
+        default:
+            alpha = 0;
+            break;
+    }
+
+    if(alpha && (cformat&C2D_FORMAT_DISABLE_ALPHA))
+        alpha = 0;
+
+    return alpha;
+}
+
+/* Function to check if we need a temporary buffer for the blit.
+ * This would happen if the requested destination stride and the
+ * C2D stride do not match. We ignore RGB buffers, since their
+ * stride is always aligned to 32.
+ */
+static bool need_temp_buffer(struct copybit_image_t const *img)
+{
+    if (COPYBIT_SUCCESS == is_supported_rgb_format(img->format))
+        return false;
+
+    struct private_handle_t* handle = (struct private_handle_t*)img->handle;
+
+    // The width parameter in the handle contains the aligned_w. We check if we
+    // need to convert based on this param. YUV formats have bpp=1, so checking
+    // if the requested stride is aligned should suffice.
+    if (0 == (handle->width)%32) {
+        return false;
+    }
+
+    return true;
+}
+
+/* Function to extract the information from the copybit image and set the corresponding
+ * values in the bufferInfo struct.
+ */
+static void populate_buffer_info(struct copybit_image_t const *img, bufferInfo& info)
+{
+    info.width = img->w;
+    info.height = img->h;
+    info.format = img->format;
+}
+
+/* Function to get the required size for a particular format, inorder for C2D to perform
+ * the blit operation.
+ */
+static size_t get_size(const bufferInfo& info)
+{
+    size_t size = 0;
+    int w = info.width;
+    int h = info.height;
+    int aligned_w = ALIGN(w, 32);
+    switch(info.format) {
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:
+            {
+                // Chroma for this format is aligned to 2K.
+                size = ALIGN((aligned_w*h), 2048) +
+                        ALIGN(aligned_w/2, 32) * (h/2) *2;
+                size = ALIGN(size, 4096);
+            } break;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+            {
+                size = aligned_w * h +
+                       ALIGN(aligned_w/2, 32) * (h/2) * 2;
+                size = ALIGN(size, 4096);
+            } break;
+        default: break;
+    }
+    return size;
+}
+
+/* Function to allocate memory for the temporary buffer. This memory is
+ * allocated from Ashmem. It is the caller's responsibility to free this
+ * memory.
+ */
+static int get_temp_buffer(const bufferInfo& info, alloc_data& data)
+{
+    ALOGD("%s E", __FUNCTION__);
+    // Alloc memory from system heap
+    data.base = 0;
+    data.fd = -1;
+    data.offset = 0;
+    data.size = get_size(info);
+    data.align = getpagesize();
+    data.uncached = true;
+    int allocFlags = GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP;
+
+    if (sAlloc == 0) {
+        sAlloc = gralloc::IAllocController::getInstance();
+    }
+
+    if (sAlloc == 0) {
+        ALOGE("%s: sAlloc is still NULL", __FUNCTION__);
+        return COPYBIT_FAILURE;
+    }
+
+    int err = sAlloc->allocate(data, allocFlags);
+    if (0 != err) {
+        ALOGE("%s: allocate failed", __FUNCTION__);
+        return COPYBIT_FAILURE;
+    }
+
+    ALOGD("%s X", __FUNCTION__);
+    return err;
+}
+
+/* Function to free the temporary allocated memory.*/
+static void free_temp_buffer(alloc_data &data)
+{
+    if (-1 != data.fd) {
+        IMemAlloc* memalloc = sAlloc->getAllocator(data.allocType);
+        memalloc->free_buffer(data.base, data.size, 0, data.fd);
+    }
+}
+
+/* Function to perform the software color conversion. Convert the
+ * C2D compatible format to the Android compatible format
+ */
+static int copy_image(private_handle_t *src_handle,
+                      struct copybit_image_t const *rhs,
+                      eConversionType conversionType)
+{
+    if (src_handle->fd == -1) {
+        ALOGE("%s: src_handle fd is invalid", __FUNCTION__);
+        return COPYBIT_FAILURE;
+    }
+
+    // Copy the info.
+    int ret = COPYBIT_SUCCESS;
+    switch(rhs->format) {
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+            {
+                if (CONVERT_TO_ANDROID_FORMAT == conversionType) {
+                    return convert_yuv_c2d_to_yuv_android(src_handle, rhs);
+                } else {
+                    return convert_yuv_android_to_yuv_c2d(src_handle, rhs);
+                }
+
+            } break;
+        default: {
+            ALOGE("%s: invalid format 0x%x", __FUNCTION__, rhs->format);
+            ret = COPYBIT_FAILURE;
+        } break;
+    }
+    return ret;
+}
+
+static void delete_handle(private_handle_t *handle)
+{
+    if (handle) {
+        delete handle;
+        handle = 0;
+    }
+}
+
+static bool need_to_execute_draw(struct copybit_context_t* ctx,
+                                          eC2DFlags flags)
+{
+    if (flags & FLAGS_TEMP_SRC_DST) {
+        return true;
+    }
+    if (flags & FLAGS_YUV_DESTINATION) {
+        return true;
+    }
+    return false;
+}
+
+/** do a stretch blit type operation */
+static int stretch_copybit_internal(
+    struct copybit_device_t *dev,
+    struct copybit_image_t const *dst,
+    struct copybit_image_t const *src,
+    struct copybit_rect_t const *dst_rect,
+    struct copybit_rect_t const *src_rect,
+    struct copybit_region_t const *region,
+    bool enableBlend)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    int status = COPYBIT_SUCCESS;
+    int flags = 0;
+    int src_surface_type;
+    int mapped_src_idx = -1, mapped_dst_idx = -1;
+    C2D_OBJECT_STR src_surface;
+
+    if (!ctx) {
+        ALOGE("%s: null context error", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    if (src->w > MAX_DIMENSION || src->h > MAX_DIMENSION) {
+        ALOGE("%s: src dimension error", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    if (dst->w > MAX_DIMENSION || dst->h > MAX_DIMENSION) {
+        ALOGE("%s : dst dimension error dst w %d h %d",  __FUNCTION__, dst->w,
+                                                         dst->h);
+        return -EINVAL;
+    }
+
+    if (is_valid_destination_format(dst->format) == COPYBIT_FAILURE) {
+        ALOGE("%s: Invalid destination format format = 0x%x", __FUNCTION__,
+                                                              dst->format);
+        return COPYBIT_FAILURE;
+    }
+
+    int dst_surface_type;
+    if (is_supported_rgb_format(dst->format) == COPYBIT_SUCCESS) {
+        dst_surface_type = RGB_SURFACE;
+        flags |= FLAGS_PREMULTIPLIED_ALPHA;
+    } else if (is_supported_yuv_format(dst->format) == COPYBIT_SUCCESS) {
+        int num_planes = get_num_planes(dst->format);
+        flags |= FLAGS_YUV_DESTINATION;
+        if (num_planes == 2) {
+            dst_surface_type = YUV_SURFACE_2_PLANES;
+        } else if (num_planes == 3) {
+            dst_surface_type = YUV_SURFACE_3_PLANES;
+        } else {
+            ALOGE("%s: dst number of YUV planes is invalid dst format = 0x%x",
+                  __FUNCTION__, dst->format);
+            return COPYBIT_FAILURE;
+        }
+    } else {
+        ALOGE("%s: Invalid dst surface format 0x%x", __FUNCTION__,
+                                                     dst->format);
+        return COPYBIT_FAILURE;
+    }
+
+    if (ctx->blit_rgb_count == MAX_RGB_SURFACES ||
+        ctx->blit_yuv_2_plane_count == MAX_YUV_2_PLANE_SURFACES ||
+        ctx->blit_yuv_3_plane_count == MAX_YUV_2_PLANE_SURFACES ||
+        ctx->blit_count == MAX_BLIT_OBJECT_COUNT ||
+        ctx->dst_surface_type != dst_surface_type) {
+        // we have reached the max. limits of our internal structures or
+        // changed the target.
+        // Draw the remaining surfaces. We need to do the finish here since
+        // we need to free up the surface templates.
+        finish_copybit(dev);
+    }
+
+    ctx->dst_surface_type = dst_surface_type;
+
+    // Update the destination
+    copybit_image_t dst_image;
+    dst_image.w = dst->w;
+    dst_image.h = dst->h;
+    dst_image.format = dst->format;
+    dst_image.handle = dst->handle;
+    // Check if we need a temp. copy for the destination. We'd need this the destination
+    // width is not aligned to 32. This case occurs for YUV formats. RGB formats are
+    // aligned to 32.
+    bool need_temp_dst = need_temp_buffer(dst);
+    bufferInfo dst_info;
+    populate_buffer_info(dst, dst_info);
+    private_handle_t* dst_hnd = new private_handle_t(-1, 0, 0, 0, dst_info.format,
+                                                     dst_info.width, dst_info.height);
+    if (dst_hnd == NULL) {
+        ALOGE("%s: dst_hnd is null", __FUNCTION__);
+        return COPYBIT_FAILURE;
+    }
+    if (need_temp_dst) {
+        if (get_size(dst_info) != ctx->temp_dst_buffer.size) {
+            free_temp_buffer(ctx->temp_dst_buffer);
+            // Create a temp buffer and set that as the destination.
+            if (COPYBIT_FAILURE == get_temp_buffer(dst_info, ctx->temp_dst_buffer)) {
+                ALOGE("%s: get_temp_buffer(dst) failed", __FUNCTION__);
+                delete_handle(dst_hnd);
+                return COPYBIT_FAILURE;
+            }
+        }
+        dst_hnd->fd = ctx->temp_dst_buffer.fd;
+        dst_hnd->size = ctx->temp_dst_buffer.size;
+        dst_hnd->flags = ctx->temp_dst_buffer.allocType;
+        dst_hnd->base = (int)(ctx->temp_dst_buffer.base);
+        dst_hnd->offset = ctx->temp_dst_buffer.offset;
+        dst_hnd->gpuaddr = 0;
+        dst_image.handle = dst_hnd;
+    }
+    if(!ctx->dst_surface_mapped) {
+        //map the destination surface to GPU address
+        status = set_image(ctx, ctx->dst[ctx->dst_surface_type], &dst_image,
+                           (eC2DFlags)flags, mapped_dst_idx);
+        if(status) {
+            ALOGE("%s: dst: set_image error", __FUNCTION__);
+            delete_handle(dst_hnd);
+            unmap_gpuaddr(ctx, mapped_dst_idx);
+            return COPYBIT_FAILURE;
+        }
+        ctx->dst_surface_mapped = true;
+        ctx->dst_surface_base = dst->base;
+    } else if(ctx->dst_surface_mapped && ctx->dst_surface_base != dst->base) {
+        // Destination surface for the operation should be same for multiple
+        // requests, this check is catch if there is any case when the
+        // destination changes
+        ALOGE("%s: a different destination surface!!", __FUNCTION__);
+    }
+
+    // Update the source
+    flags = 0;
+    if(is_supported_rgb_format(src->format) == COPYBIT_SUCCESS) {
+        src_surface_type = RGB_SURFACE;
+        src_surface = ctx->blit_rgb_object[ctx->blit_rgb_count];
+    } else if (is_supported_yuv_format(src->format) == COPYBIT_SUCCESS) {
+        int num_planes = get_num_planes(src->format);
+        if (num_planes == 2) {
+            src_surface_type = YUV_SURFACE_2_PLANES;
+            src_surface = ctx->blit_yuv_2_plane_object[ctx->blit_yuv_2_plane_count];
+        } else if (num_planes == 3) {
+            src_surface_type = YUV_SURFACE_3_PLANES;
+            src_surface = ctx->blit_yuv_3_plane_object[ctx->blit_yuv_2_plane_count];
+        } else {
+            ALOGE("%s: src number of YUV planes is invalid src format = 0x%x",
+                  __FUNCTION__, src->format);
+            delete_handle(dst_hnd);
+            unmap_gpuaddr(ctx, mapped_dst_idx);
+            return -EINVAL;
+        }
+    } else {
+        ALOGE("%s: Invalid source surface format 0x%x", __FUNCTION__,
+                                                        src->format);
+        delete_handle(dst_hnd);
+        unmap_gpuaddr(ctx, mapped_dst_idx);
+        return -EINVAL;
+    }
+
+    copybit_image_t src_image;
+    src_image.w = src->w;
+    src_image.h = src->h;
+    src_image.format = src->format;
+    src_image.handle = src->handle;
+
+    bool need_temp_src = need_temp_buffer(src);
+    bufferInfo src_info;
+    populate_buffer_info(src, src_info);
+    private_handle_t* src_hnd = new private_handle_t(-1, 0, 0, 0, src_info.format,
+                                                 src_info.width, src_info.height);
+    if (NULL == src_hnd) {
+        ALOGE("%s: src_hnd is null", __FUNCTION__);
+        delete_handle(dst_hnd);
+        unmap_gpuaddr(ctx, mapped_dst_idx);
+        return COPYBIT_FAILURE;
+    }
+    if (need_temp_src) {
+        if (get_size(src_info) != ctx->temp_src_buffer.size) {
+            free_temp_buffer(ctx->temp_src_buffer);
+            // Create a temp buffer and set that as the destination.
+            if (COPYBIT_SUCCESS != get_temp_buffer(src_info,
+                                               ctx->temp_src_buffer)) {
+                ALOGE("%s: get_temp_buffer(src) failed", __FUNCTION__);
+                delete_handle(dst_hnd);
+                delete_handle(src_hnd);
+                unmap_gpuaddr(ctx, mapped_dst_idx);
+                return COPYBIT_FAILURE;
+            }
+        }
+        src_hnd->fd = ctx->temp_src_buffer.fd;
+        src_hnd->size = ctx->temp_src_buffer.size;
+        src_hnd->flags = ctx->temp_src_buffer.allocType;
+        src_hnd->base = (int)(ctx->temp_src_buffer.base);
+        src_hnd->offset = ctx->temp_src_buffer.offset;
+        src_hnd->gpuaddr = 0;
+        src_image.handle = src_hnd;
+
+        // Copy the source.
+        status = copy_image((private_handle_t *)src->handle, &src_image,
+                                CONVERT_TO_C2D_FORMAT);
+        if (status == COPYBIT_FAILURE) {
+            ALOGE("%s:copy_image failed in temp source",__FUNCTION__);
+            delete_handle(dst_hnd);
+            delete_handle(src_hnd);
+            unmap_gpuaddr(ctx, mapped_dst_idx);
+            return status;
+        }
+
+        // Clean the cache
+        IMemAlloc* memalloc = sAlloc->getAllocator(src_hnd->flags);
+        if (memalloc->clean_buffer((void *)(src_hnd->base), src_hnd->size,
+                                   src_hnd->offset, src_hnd->fd,
+                                   gralloc::CACHE_CLEAN)) {
+            ALOGE("%s: clean_buffer failed", __FUNCTION__);
+            delete_handle(dst_hnd);
+            delete_handle(src_hnd);
+            unmap_gpuaddr(ctx, mapped_dst_idx);
+            return COPYBIT_FAILURE;
+        }
+    }
+
+    flags |= (ctx->is_premultiplied_alpha) ? FLAGS_PREMULTIPLIED_ALPHA : 0;
+    flags |= (ctx->dst_surface_type != RGB_SURFACE) ? FLAGS_YUV_DESTINATION : 0;
+    status = set_image(ctx, src_surface.surface_id, &src_image,
+                       (eC2DFlags)flags, mapped_src_idx);
+    if(status) {
+        ALOGE("%s: set_image (src) error", __FUNCTION__);
+        delete_handle(dst_hnd);
+        delete_handle(src_hnd);
+        unmap_gpuaddr(ctx, mapped_dst_idx);
+        unmap_gpuaddr(ctx, mapped_src_idx);
+        return COPYBIT_FAILURE;
+    }
+
+    src_surface.config_mask = C2D_NO_ANTIALIASING_BIT | ctx->config_mask;
+    src_surface.global_alpha = ctx->src_global_alpha;
+    if (enableBlend) {
+        if(src_surface.config_mask & C2D_GLOBAL_ALPHA_BIT) {
+            src_surface.config_mask &= ~C2D_ALPHA_BLEND_NONE;
+            if(!(src_surface.global_alpha)) {
+                // src alpha is zero
+                delete_handle(dst_hnd);
+                delete_handle(src_hnd);
+                unmap_gpuaddr(ctx, mapped_dst_idx);
+                unmap_gpuaddr(ctx, mapped_src_idx);
+                return COPYBIT_FAILURE;
+            }
+        }
+    } else {
+        src_surface.config_mask |= C2D_ALPHA_BLEND_NONE;
+    }
+
+    if (src_surface_type == RGB_SURFACE) {
+        ctx->blit_rgb_object[ctx->blit_rgb_count] = src_surface;
+        ctx->blit_rgb_count++;
+    } else if (src_surface_type == YUV_SURFACE_2_PLANES) {
+        ctx->blit_yuv_2_plane_object[ctx->blit_yuv_2_plane_count] = src_surface;
+        ctx->blit_yuv_2_plane_count++;
+    } else {
+        ctx->blit_yuv_3_plane_object[ctx->blit_yuv_3_plane_count] = src_surface;
+        ctx->blit_yuv_3_plane_count++;
+    }
+
+    struct copybit_rect_t clip;
+    while ((status == 0) && region->next(region, &clip)) {
+        set_rects(ctx, &(src_surface), dst_rect, src_rect, &clip);
+        if (ctx->blit_count == MAX_BLIT_OBJECT_COUNT) {
+            ALOGW("Reached end of blit count");
+            finish_copybit(dev);
+        }
+        ctx->blit_list[ctx->blit_count] = src_surface;
+        ctx->blit_count++;
+    }
+
+    // Check if we need to perform an early draw-finish.
+    flags |= (need_temp_dst || need_temp_src) ? FLAGS_TEMP_SRC_DST : 0;
+    if (need_to_execute_draw(ctx, (eC2DFlags)flags))
+    {
+        finish_copybit(dev);
+    }
+
+    if (need_temp_dst) {
+        // copy the temp. destination without the alignment to the actual
+        // destination.
+        status = copy_image(dst_hnd, dst, CONVERT_TO_ANDROID_FORMAT);
+        if (status == COPYBIT_FAILURE) {
+            ALOGE("%s:copy_image failed in temp Dest",__FUNCTION__);
+            delete_handle(dst_hnd);
+            delete_handle(src_hnd);
+            unmap_gpuaddr(ctx, mapped_dst_idx);
+            unmap_gpuaddr(ctx, mapped_src_idx);
+            return status;
+        }
+        // Clean the cache.
+        IMemAlloc* memalloc = sAlloc->getAllocator(dst_hnd->flags);
+        memalloc->clean_buffer((void *)(dst_hnd->base), dst_hnd->size,
+                               dst_hnd->offset, dst_hnd->fd,
+                               gralloc::CACHE_CLEAN);
+    }
+    delete_handle(dst_hnd);
+    delete_handle(src_hnd);
+
+    ctx->is_premultiplied_alpha = false;
+    ctx->fb_width = 0;
+    ctx->fb_height = 0;
+    ctx->config_mask = 0;
+    return status;
+}
+
+static int set_sync_copybit(struct copybit_device_t *dev,
+    int acquireFenceFd)
+{
+    return 0;
+}
+
+static int stretch_copybit(
+    struct copybit_device_t *dev,
+    struct copybit_image_t const *dst,
+    struct copybit_image_t const *src,
+    struct copybit_rect_t const *dst_rect,
+    struct copybit_rect_t const *src_rect,
+    struct copybit_region_t const *region)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    int status = COPYBIT_SUCCESS;
+    bool needsBlending = (ctx->src_global_alpha != 0);
+    pthread_mutex_lock(&ctx->wait_cleanup_lock);
+    status = stretch_copybit_internal(dev, dst, src, dst_rect, src_rect,
+                                    region, needsBlending);
+    pthread_mutex_unlock(&ctx->wait_cleanup_lock);
+    return status;
+}
+
+/** Perform a blit type operation */
+static int blit_copybit(
+    struct copybit_device_t *dev,
+    struct copybit_image_t const *dst,
+    struct copybit_image_t const *src,
+    struct copybit_region_t const *region)
+{
+    int status = COPYBIT_SUCCESS;
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    struct copybit_rect_t dr = { 0, 0, (int)dst->w, (int)dst->h };
+    struct copybit_rect_t sr = { 0, 0, (int)src->w, (int)src->h };
+    pthread_mutex_lock(&ctx->wait_cleanup_lock);
+    status = stretch_copybit_internal(dev, dst, src, &dr, &sr, region, false);
+    pthread_mutex_unlock(&ctx->wait_cleanup_lock);
+    return status;
+}
+
+/*****************************************************************************/
+
+static void clean_up(copybit_context_t* ctx)
+{
+    void* ret;
+    if (!ctx)
+        return;
+
+    // stop the wait_cleanup_thread
+    pthread_mutex_lock(&ctx->wait_cleanup_lock);
+    ctx->stop_thread = true;
+    // Signal waiting thread
+    pthread_cond_signal(&ctx->wait_cleanup_cond);
+    pthread_mutex_unlock(&ctx->wait_cleanup_lock);
+    // waits for the cleanup thread to exit
+    pthread_join(ctx->wait_thread_id, &ret);
+    pthread_mutex_destroy(&ctx->wait_cleanup_lock);
+    pthread_cond_destroy (&ctx->wait_cleanup_cond);
+
+    for (int i = 0; i < NUM_SURFACE_TYPES; i++) {
+        if (ctx->dst[i])
+            LINK_c2dDestroySurface(ctx->dst[i]);
+    }
+
+    for (int i = 0; i < MAX_RGB_SURFACES; i++) {
+        if (ctx->blit_rgb_object[i].surface_id)
+            LINK_c2dDestroySurface(ctx->blit_rgb_object[i].surface_id);
+    }
+
+    for (int i = 0; i < MAX_YUV_2_PLANE_SURFACES; i++) {
+        if (ctx->blit_yuv_2_plane_object[i].surface_id)
+            LINK_c2dDestroySurface(ctx->blit_yuv_2_plane_object[i].surface_id);
+    }
+
+    for (int i = 0; i < MAX_YUV_3_PLANE_SURFACES; i++) {
+        if (ctx->blit_yuv_3_plane_object[i].surface_id)
+            LINK_c2dDestroySurface(ctx->blit_yuv_3_plane_object[i].surface_id);
+    }
+
+    if (ctx->libc2d2) {
+        ::dlclose(ctx->libc2d2);
+        ALOGV("dlclose(libc2d2)");
+    }
+
+    free(ctx);
+}
+
+/** Close the copybit device */
+static int close_copybit(struct hw_device_t *dev)
+{
+    struct copybit_context_t* ctx = (struct copybit_context_t*)dev;
+    if (ctx) {
+        free_temp_buffer(ctx->temp_src_buffer);
+        free_temp_buffer(ctx->temp_dst_buffer);
+    }
+    clean_up(ctx);
+    return 0;
+}
+
+/** Open a new instance of a copybit device using name */
+static int open_copybit(const struct hw_module_t* module, const char* name,
+                        struct hw_device_t** device)
+{
+    int status = COPYBIT_SUCCESS;
+    C2D_RGB_SURFACE_DEF surfDefinition = {0};
+    C2D_YUV_SURFACE_DEF yuvSurfaceDef = {0} ;
+    struct copybit_context_t *ctx;
+    char fbName[64];
+
+    ctx = (struct copybit_context_t *)malloc(sizeof(struct copybit_context_t));
+    if(!ctx) {
+        ALOGE("%s: malloc failed", __FUNCTION__);
+        return COPYBIT_FAILURE;
+    }
+
+    /* initialize drawstate */
+    memset(ctx, 0, sizeof(*ctx));
+    ctx->libc2d2 = ::dlopen("libC2D2.so", RTLD_NOW);
+    if (!ctx->libc2d2) {
+        ALOGE("FATAL ERROR: could not dlopen libc2d2.so: %s", dlerror());
+        clean_up(ctx);
+        status = COPYBIT_FAILURE;
+        *device = NULL;
+        return status;
+    }
+    *(void **)&LINK_c2dCreateSurface = ::dlsym(ctx->libc2d2,
+                                               "c2dCreateSurface");
+    *(void **)&LINK_c2dUpdateSurface = ::dlsym(ctx->libc2d2,
+                                               "c2dUpdateSurface");
+    *(void **)&LINK_c2dReadSurface = ::dlsym(ctx->libc2d2,
+                                             "c2dReadSurface");
+    *(void **)&LINK_c2dDraw = ::dlsym(ctx->libc2d2, "c2dDraw");
+    *(void **)&LINK_c2dFlush = ::dlsym(ctx->libc2d2, "c2dFlush");
+    *(void **)&LINK_c2dFinish = ::dlsym(ctx->libc2d2, "c2dFinish");
+    *(void **)&LINK_c2dWaitTimestamp = ::dlsym(ctx->libc2d2,
+                                               "c2dWaitTimestamp");
+    *(void **)&LINK_c2dDestroySurface = ::dlsym(ctx->libc2d2,
+                                                "c2dDestroySurface");
+    *(void **)&LINK_c2dMapAddr = ::dlsym(ctx->libc2d2,
+                                         "c2dMapAddr");
+    *(void **)&LINK_c2dUnMapAddr = ::dlsym(ctx->libc2d2,
+                                           "c2dUnMapAddr");
+    *(void **)&LINK_c2dGetDriverCapabilities = ::dlsym(ctx->libc2d2,
+                                           "c2dGetDriverCapabilities");
+    *(void **)&LINK_c2dCreateFenceFD = ::dlsym(ctx->libc2d2,
+                                           "c2dCreateFenceFD");
+    *(void **)&LINK_c2dFillSurface = ::dlsym(ctx->libc2d2,
+                                           "c2dFillSurface");
+
+    if (!LINK_c2dCreateSurface || !LINK_c2dUpdateSurface || !LINK_c2dReadSurface
+        || !LINK_c2dDraw || !LINK_c2dFlush || !LINK_c2dWaitTimestamp ||
+        !LINK_c2dFinish  || !LINK_c2dDestroySurface ||
+        !LINK_c2dGetDriverCapabilities || !LINK_c2dCreateFenceFD ||
+        !LINK_c2dFillSurface) {
+        ALOGE("%s: dlsym ERROR", __FUNCTION__);
+        clean_up(ctx);
+        status = COPYBIT_FAILURE;
+        *device = NULL;
+        return status;
+    }
+
+    ctx->device.common.tag = HARDWARE_DEVICE_TAG;
+    ctx->device.common.version = 1;
+    ctx->device.common.module = (hw_module_t*)(module);
+    ctx->device.common.close = close_copybit;
+    ctx->device.set_parameter = set_parameter_copybit;
+    ctx->device.get = get;
+    ctx->device.blit = blit_copybit;
+    ctx->device.set_sync = set_sync_copybit;
+    ctx->device.stretch = stretch_copybit;
+    ctx->device.finish = finish_copybit;
+    ctx->device.flush_get_fence = flush_get_fence_copybit;
+    ctx->device.clear = clear_copybit;
+
+    /* Create RGB Surface */
+    surfDefinition.buffer = (void*)0xdddddddd;
+    surfDefinition.phys = (void*)0xdddddddd;
+    surfDefinition.stride = 1 * 4;
+    surfDefinition.width = 1;
+    surfDefinition.height = 1;
+    surfDefinition.format = C2D_COLOR_FORMAT_8888_ARGB;
+    if (LINK_c2dCreateSurface(&(ctx->dst[RGB_SURFACE]), C2D_TARGET | C2D_SOURCE,
+                              (C2D_SURFACE_TYPE)(C2D_SURFACE_RGB_HOST |
+                                                 C2D_SURFACE_WITH_PHYS |
+                                                 C2D_SURFACE_WITH_PHYS_DUMMY ),
+                                                 &surfDefinition)) {
+        ALOGE("%s: create ctx->dst_surface[RGB_SURFACE] failed", __FUNCTION__);
+        ctx->dst[RGB_SURFACE] = 0;
+        clean_up(ctx);
+        status = COPYBIT_FAILURE;
+        *device = NULL;
+        return status;
+    }
+
+    unsigned int surface_id = 0;
+    for (int i = 0; i < MAX_RGB_SURFACES; i++)
+    {
+        if (LINK_c2dCreateSurface(&surface_id, C2D_TARGET | C2D_SOURCE,
+                              (C2D_SURFACE_TYPE)(C2D_SURFACE_RGB_HOST |
+                                                 C2D_SURFACE_WITH_PHYS |
+                                                 C2D_SURFACE_WITH_PHYS_DUMMY ),
+                                                 &surfDefinition)) {
+            ALOGE("%s: create RGB source surface %d failed", __FUNCTION__, i);
+            ctx->blit_rgb_object[i].surface_id = 0;
+            status = COPYBIT_FAILURE;
+            break;
+        } else {
+            ctx->blit_rgb_object[i].surface_id = surface_id;
+            ALOGW("%s i = %d surface_id=%d",  __FUNCTION__, i,
+                                          ctx->blit_rgb_object[i].surface_id);
+        }
+    }
+
+    if (status == COPYBIT_FAILURE) {
+        clean_up(ctx);
+        status = COPYBIT_FAILURE;
+        *device = NULL;
+        return status;
+    }
+
+    // Create 2 plane YUV surfaces
+    yuvSurfaceDef.format = C2D_COLOR_FORMAT_420_NV12;
+    yuvSurfaceDef.width = 4;
+    yuvSurfaceDef.height = 4;
+    yuvSurfaceDef.plane0 = (void*)0xaaaaaaaa;
+    yuvSurfaceDef.phys0 = (void*) 0xaaaaaaaa;
+    yuvSurfaceDef.stride0 = 4;
+
+    yuvSurfaceDef.plane1 = (void*)0xaaaaaaaa;
+    yuvSurfaceDef.phys1 = (void*) 0xaaaaaaaa;
+    yuvSurfaceDef.stride1 = 4;
+    if (LINK_c2dCreateSurface(&(ctx->dst[YUV_SURFACE_2_PLANES]),
+                              C2D_TARGET | C2D_SOURCE,
+                              (C2D_SURFACE_TYPE)(C2D_SURFACE_YUV_HOST |
+                               C2D_SURFACE_WITH_PHYS |
+                               C2D_SURFACE_WITH_PHYS_DUMMY),
+                              &yuvSurfaceDef)) {
+        ALOGE("%s: create ctx->dst[YUV_SURFACE_2_PLANES] failed", __FUNCTION__);
+        ctx->dst[YUV_SURFACE_2_PLANES] = 0;
+        clean_up(ctx);
+        status = COPYBIT_FAILURE;
+        *device = NULL;
+        return status;
+    }
+
+    for (int i=0; i < MAX_YUV_2_PLANE_SURFACES; i++)
+    {
+        if (LINK_c2dCreateSurface(&surface_id, C2D_TARGET | C2D_SOURCE,
+                              (C2D_SURFACE_TYPE)(C2D_SURFACE_YUV_HOST |
+                                                 C2D_SURFACE_WITH_PHYS |
+                                                 C2D_SURFACE_WITH_PHYS_DUMMY ),
+                              &yuvSurfaceDef)) {
+            ALOGE("%s: create YUV source %d failed", __FUNCTION__, i);
+            ctx->blit_yuv_2_plane_object[i].surface_id = 0;
+            status = COPYBIT_FAILURE;
+            break;
+        } else {
+            ctx->blit_yuv_2_plane_object[i].surface_id = surface_id;
+            ALOGW("%s: 2 Plane YUV i=%d surface_id=%d",  __FUNCTION__, i,
+                                   ctx->blit_yuv_2_plane_object[i].surface_id);
+        }
+    }
+
+    if (status == COPYBIT_FAILURE) {
+        clean_up(ctx);
+        status = COPYBIT_FAILURE;
+        *device = NULL;
+        return status;
+    }
+
+    // Create YUV 3 plane surfaces
+    yuvSurfaceDef.format = C2D_COLOR_FORMAT_420_YV12;
+    yuvSurfaceDef.plane2 = (void*)0xaaaaaaaa;
+    yuvSurfaceDef.phys2 = (void*) 0xaaaaaaaa;
+    yuvSurfaceDef.stride2 = 4;
+
+    if (LINK_c2dCreateSurface(&(ctx->dst[YUV_SURFACE_3_PLANES]),
+                              C2D_TARGET | C2D_SOURCE,
+                              (C2D_SURFACE_TYPE)(C2D_SURFACE_YUV_HOST |
+                                                 C2D_SURFACE_WITH_PHYS |
+                                                 C2D_SURFACE_WITH_PHYS_DUMMY),
+                              &yuvSurfaceDef)) {
+        ALOGE("%s: create ctx->dst[YUV_SURFACE_3_PLANES] failed", __FUNCTION__);
+        ctx->dst[YUV_SURFACE_3_PLANES] = 0;
+        clean_up(ctx);
+        status = COPYBIT_FAILURE;
+        *device = NULL;
+        return status;
+    }
+
+    for (int i=0; i < MAX_YUV_3_PLANE_SURFACES; i++)
+    {
+        if (LINK_c2dCreateSurface(&(surface_id),
+                              C2D_TARGET | C2D_SOURCE,
+                              (C2D_SURFACE_TYPE)(C2D_SURFACE_YUV_HOST |
+                                                 C2D_SURFACE_WITH_PHYS |
+                                                 C2D_SURFACE_WITH_PHYS_DUMMY),
+                              &yuvSurfaceDef)) {
+            ALOGE("%s: create 3 plane YUV surface %d failed", __FUNCTION__, i);
+            ctx->blit_yuv_3_plane_object[i].surface_id = 0;
+            status = COPYBIT_FAILURE;
+            break;
+        } else {
+            ctx->blit_yuv_3_plane_object[i].surface_id = surface_id;
+            ALOGW("%s: 3 Plane YUV i=%d surface_id=%d",  __FUNCTION__, i,
+                                   ctx->blit_yuv_3_plane_object[i].surface_id);
+        }
+    }
+
+    if (status == COPYBIT_FAILURE) {
+        clean_up(ctx);
+        status = COPYBIT_FAILURE;
+        *device = NULL;
+        return status;
+    }
+
+    if (LINK_c2dGetDriverCapabilities(&(ctx->c2d_driver_info))) {
+         ALOGE("%s: LINK_c2dGetDriverCapabilities failed", __FUNCTION__);
+         clean_up(ctx);
+         status = COPYBIT_FAILURE;
+        *device = NULL;
+        return status;
+    }
+    // Initialize context variables.
+    ctx->trg_transform = C2D_TARGET_ROTATE_0;
+
+    ctx->temp_src_buffer.fd = -1;
+    ctx->temp_src_buffer.base = 0;
+    ctx->temp_src_buffer.size = 0;
+
+    ctx->temp_dst_buffer.fd = -1;
+    ctx->temp_dst_buffer.base = 0;
+    ctx->temp_dst_buffer.size = 0;
+
+    ctx->fb_width = 0;
+    ctx->fb_height = 0;
+
+    ctx->blit_rgb_count = 0;
+    ctx->blit_yuv_2_plane_count = 0;
+    ctx->blit_yuv_3_plane_count = 0;
+    ctx->blit_count = 0;
+
+    ctx->wait_timestamp = false;
+    ctx->stop_thread = false;
+    pthread_mutex_init(&(ctx->wait_cleanup_lock), NULL);
+    pthread_cond_init(&(ctx->wait_cleanup_cond), NULL);
+    /* Start the wait thread */
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+    pthread_create(&ctx->wait_thread_id, &attr, &c2d_wait_loop,
+                                                            (void *)ctx);
+    pthread_attr_destroy(&attr);
+
+    *device = &ctx->device.common;
+    return status;
+}
diff --git a/msm8974/libcopybit/copybit_priv.h b/msm8974/libcopybit/copybit_priv.h
new file mode 100644
index 0000000..68dfac4
--- /dev/null
+++ b/msm8974/libcopybit/copybit_priv.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <copybit.h>
+struct copybit_iterator : public copybit_region_t {
+    copybit_iterator(const copybit_rect_t& rect) {
+        mRect = rect;
+        mCount = 1;
+        this->next = iterate;
+    }
+private:
+    static int iterate(copybit_region_t const * self, copybit_rect_t* rect) {
+        if (!self || !rect) {
+            return 0;
+        }
+
+        copybit_iterator const* me = static_cast<copybit_iterator const*>(self);
+        if (me->mCount) {
+            rect->l = me->mRect.l;
+            rect->t = me->mRect.t;
+            rect->r = me->mRect.r;
+            rect->b = me->mRect.b;
+            me->mCount--;
+            return 1;
+        }
+        return 0;
+    }
+    copybit_rect_t mRect;
+    mutable int mCount;
+};
diff --git a/msm8974/libcopybit/software_converter.cpp b/msm8974/libcopybit/software_converter.cpp
new file mode 100644
index 0000000..e26b795
--- /dev/null
+++ b/msm8974/libcopybit/software_converter.cpp
@@ -0,0 +1,262 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <cutils/log.h>
+#include <stdlib.h>
+#include <errno.h>
+#include "software_converter.h"
+
+/** Convert YV12 to YCrCb_420_SP */
+int convertYV12toYCrCb420SP(const copybit_image_t *src, private_handle_t *yv12_handle)
+{
+    private_handle_t* hnd = (private_handle_t*)src->handle;
+
+    if(hnd == NULL || yv12_handle == NULL){
+        ALOGE("Invalid handle");
+        return -1;
+    }
+
+    // Please refer to the description of YV12 in hardware.h
+    // for the formulae used to calculate buffer sizes and offsets
+
+    // In a copybit_image_t, w is the stride and
+    // stride - horiz_padding is the actual width
+    // vertical stride is the same as height, so not considered
+    unsigned int   stride  = src->w;
+    unsigned int   width   = src->w - src->horiz_padding;
+    unsigned int   height  = src->h;
+    unsigned int   y_size  = stride * src->h;
+    unsigned int   c_width = ALIGN(stride/2, 16);
+    unsigned int   c_size  = c_width * src->h/2;
+    unsigned int   chromaPadding = c_width - width/2;
+    unsigned int   chromaSize = c_size * 2;
+    unsigned char* newChroma = (unsigned char *)(yv12_handle->base + y_size);
+    unsigned char* oldChroma = (unsigned char*)(hnd->base + y_size);
+    memcpy((char *)yv12_handle->base,(char *)hnd->base,y_size);
+
+#ifdef __ARM_HAVE_NEON
+   /* interleave */
+    if(!chromaPadding) {
+        unsigned char * t1 = newChroma;
+        unsigned char * t2 = oldChroma;
+        unsigned char * t3 = t2 + chromaSize/2;
+        for(unsigned int i=0; i < (chromaSize/2)>>3; i++) {
+            __asm__ __volatile__ (
+                                    "vld1.u8 d0, [%0]! \n"
+                                    "vld1.u8 d1, [%1]! \n"
+                                    "vst2.u8 {d0, d1}, [%2]! \n"
+                                    :"+r"(t2), "+r"(t3), "+r"(t1)
+                                    :
+                                    :"memory","d0","d1"
+                                 );
+
+        }
+    }
+#else  //__ARM_HAVE_NEON
+    if(!chromaPadding) {
+        for(unsigned int i = 0; i< chromaSize/2; i++) {
+            newChroma[i*2]   = oldChroma[i];
+            newChroma[i*2+1] = oldChroma[i+chromaSize/2];
+        }
+
+    }
+#endif
+    // If the image is not aligned to 16 pixels,
+    // convert using the C routine below
+    // r1 tracks the row of the source buffer
+    // r2 tracks the row of the destination buffer
+    // The width/2 checks are to avoid copying
+    // from the padding
+
+    if(chromaPadding) {
+        unsigned int r1 = 0, r2 = 0, i = 0, j = 0;
+        while(r1 < height/2) {
+            if(j == width) {
+                j = 0;
+                r2++;
+                continue;
+            }
+            if (j+1 == width) {
+                newChroma[r2*width + j] = oldChroma[r1*c_width+i];
+                r2++;
+                newChroma[r2*width] = oldChroma[r1*c_width+i+c_size];
+                j = 1;
+            } else {
+                newChroma[r2*width + j] = oldChroma[r1*c_width+i];
+                newChroma[r2*width + j + 1] = oldChroma[r1*c_width+i+c_size];
+                j+=2;
+            }
+            i++;
+            if (i == width/2 ) {
+                i = 0;
+                r1++;
+            }
+        }
+    }
+
+  return 0;
+}
+
+struct copyInfo{
+    int width;
+    int height;
+    int src_stride;
+    int dst_stride;
+    int src_plane1_offset;
+    int src_plane2_offset;
+    int dst_plane1_offset;
+    int dst_plane2_offset;
+};
+
+/* Internal function to do the actual copy of source to destination */
+static int copy_source_to_destination(const int src_base, const int dst_base,
+                                      copyInfo& info)
+{
+    if (!src_base || !dst_base) {
+        ALOGE("%s: invalid memory src_base = 0x%x dst_base=0x%x",
+             __FUNCTION__, src_base, dst_base);
+         return COPYBIT_FAILURE;
+    }
+
+    int width = info.width;
+    int height = info.height;
+    unsigned char *src = (unsigned char*)src_base;
+    unsigned char *dst = (unsigned char*)dst_base;
+
+    // Copy the luma
+    for (int i = 0; i < height; i++) {
+        memcpy(dst, src, width);
+        src += info.src_stride;
+        dst += info.dst_stride;
+    }
+
+    // Copy plane 1
+    src = (unsigned char*)(src_base + info.src_plane1_offset);
+    dst = (unsigned char*)(dst_base + info.dst_plane1_offset);
+    width = width/2;
+    height = height/2;
+    for (int i = 0; i < height; i++) {
+        memcpy(dst, src, info.src_stride);
+        src += info.src_stride;
+        dst += info.dst_stride;
+    }
+    return 0;
+}
+
+
+/*
+ * Function to convert the c2d format into an equivalent Android format
+ *
+ * @param: source buffer handle
+ * @param: destination image
+ *
+ * @return: return status
+ */
+int convert_yuv_c2d_to_yuv_android(private_handle_t *hnd,
+                                   struct copybit_image_t const *rhs)
+{
+    ALOGD("Enter %s", __FUNCTION__);
+    if (!hnd || !rhs) {
+        ALOGE("%s: invalid inputs hnd=%p rhs=%p", __FUNCTION__, hnd, rhs);
+        return COPYBIT_FAILURE;
+    }
+
+    int ret = COPYBIT_SUCCESS;
+    private_handle_t *dst_hnd = (private_handle_t *)rhs->handle;
+
+    copyInfo info;
+    info.width = rhs->w;
+    info.height = rhs->h;
+    info.src_stride = ALIGN(info.width, 32);
+    info.dst_stride = ALIGN(info.width, 16);
+    switch(rhs->format) {
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP: {
+            info.src_plane1_offset = info.src_stride*info.height;
+            info.dst_plane1_offset = info.dst_stride*info.height;
+        } break;
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE: {
+            // Chroma is 2K aligned for the NV12 encodeable format.
+            info.src_plane1_offset = ALIGN(info.src_stride*info.height, 2048);
+            info.dst_plane1_offset = ALIGN(info.dst_stride*info.height, 2048);
+        } break;
+        default:
+            ALOGE("%s: unsupported format (format=0x%x)", __FUNCTION__,
+                 rhs->format);
+            return COPYBIT_FAILURE;
+    }
+
+    ret = copy_source_to_destination(hnd->base, dst_hnd->base, info);
+    return ret;
+}
+
+/*
+ * Function to convert the Android format into an equivalent C2D format
+ *
+ * @param: source buffer handle
+ * @param: destination image
+ *
+ * @return: return status
+ */
+int convert_yuv_android_to_yuv_c2d(private_handle_t *hnd,
+                                   struct copybit_image_t const *rhs)
+{
+    if (!hnd || !rhs) {
+        ALOGE("%s: invalid inputs hnd=%p rhs=%p", __FUNCTION__, hnd, rhs);
+        return COPYBIT_FAILURE;
+    }
+
+    int ret = COPYBIT_SUCCESS;
+    private_handle_t *dst_hnd = (private_handle_t *)rhs->handle;
+
+    copyInfo info;
+    info.width = rhs->w;
+    info.height = rhs->h;
+    info.src_stride = ALIGN(hnd->width, 16);
+    info.dst_stride = ALIGN(info.width, 32);
+    switch(rhs->format) {
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP: {
+            info.src_plane1_offset = info.src_stride*info.height;
+            info.dst_plane1_offset = info.dst_stride*info.height;
+        } break;
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE: {
+            // Chroma is 2K aligned for the NV12 encodeable format.
+            info.src_plane1_offset = ALIGN(info.src_stride*info.height, 2048);
+            info.dst_plane1_offset = ALIGN(info.dst_stride*info.height, 2048);
+        } break;
+        default:
+            ALOGE("%s: unsupported format (format=0x%x)", __FUNCTION__,
+                 rhs->format);
+            return -1;
+    }
+
+    ret = copy_source_to_destination(hnd->base, dst_hnd->base, info);
+    return ret;
+}
diff --git a/msm8974/libcopybit/software_converter.h b/msm8974/libcopybit/software_converter.h
new file mode 100644
index 0000000..6e53e16
--- /dev/null
+++ b/msm8974/libcopybit/software_converter.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2011, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+
+#include <copybit.h>
+#include "gralloc_priv.h"
+#include "gr.h"
+
+#define COPYBIT_SUCCESS 0
+#define COPYBIT_FAILURE -1
+
+int convertYV12toYCrCb420SP(const copybit_image_t *src,private_handle_t *yv12_handle);
+
+/*
+ * Function to convert the c2d format into an equivalent Android format
+ *
+ * @param: source buffer handle
+ * @param: destination image
+ *
+ * @return: return status
+ */
+int convert_yuv_c2d_to_yuv_android(private_handle_t *hnd,
+                                   struct copybit_image_t const *rhs);
+
+
+/*
+ * Function to convert the Android format into an equivalent C2D format
+ *
+ * @param: source buffer handle
+ * @param: destination image
+ *
+ * @return: return status
+ */
+int convert_yuv_android_to_yuv_c2d(private_handle_t *hnd,
+                                   struct copybit_image_t const *rhs);
diff --git a/msm8974/libexternal/Android.mk b/msm8974/libexternal/Android.mk
new file mode 100644
index 0000000..a82037a
--- /dev/null
+++ b/msm8974/libexternal/Android.mk
@@ -0,0 +1,14 @@
+LOCAL_PATH := $(call my-dir)
+include $(LOCAL_PATH)/../common.mk
+include $(CLEAR_VARS)
+
+LOCAL_MODULE                  := libexternal
+LOCAL_MODULE_PATH             := $(TARGET_OUT_SHARED_LIBRARIES)
+LOCAL_MODULE_TAGS             := optional
+LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)
+LOCAL_SHARED_LIBRARIES        := $(common_libs)
+LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"qdexternal\"
+LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
+LOCAL_SRC_FILES               := external.cpp
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/msm8974/libexternal/external.cpp b/msm8974/libexternal/external.cpp
new file mode 100644
index 0000000..fd84003
--- /dev/null
+++ b/msm8974/libexternal/external.cpp
@@ -0,0 +1,817 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define DEBUG 0
+#include <ctype.h>
+#include <fcntl.h>
+#include <media/IAudioPolicyService.h>
+#include <media/AudioSystem.h>
+#include <utils/threads.h>
+#include <utils/Errors.h>
+#include <utils/Log.h>
+
+#include <linux/msm_mdp.h>
+#include <video/msm_hdmi_modes.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <sys/poll.h>
+#include <sys/resource.h>
+#include <cutils/properties.h>
+#include "hwc_utils.h"
+#include "external.h"
+
+using namespace android;
+
+namespace qhwc {
+
+#define MAX_FRAME_BUFFER_NAME_SIZE      (80)
+#define MAX_DISPLAY_DEVICES             (3)
+#define MAX_SYSFS_FILE_PATH             255
+#define UNKNOWN_STRING                  "unknown"
+#define SPD_NAME_LENGTH                 16
+
+const char* msmFbDevicePath[] = {  "/dev/graphics/fb1",
+                                   "/dev/graphics/fb2"};
+
+/*
+ * Updates extDeviceFbIndex Array with the correct frame buffer indices
+ * of avaiable external devices
+ *
+ */
+void ExternalDisplay::updateExtDispDevFbIndex()
+{
+    FILE *displayDeviceFP = NULL;
+    char fbType[MAX_FRAME_BUFFER_NAME_SIZE];
+    char msmFbTypePath[MAX_FRAME_BUFFER_NAME_SIZE];
+
+    for(int j = 1; j < MAX_DISPLAY_DEVICES; j++) {
+        snprintf (msmFbTypePath, sizeof(msmFbTypePath),
+                  "/sys/class/graphics/fb%d/msm_fb_type", j);
+        displayDeviceFP = fopen(msmFbTypePath, "r");
+        if(displayDeviceFP){
+            fread(fbType, sizeof(char), MAX_FRAME_BUFFER_NAME_SIZE,
+                    displayDeviceFP);
+            if(strncmp(fbType, "dtv panel", strlen("dtv panel")) == 0){
+                ALOGD_IF(DEBUG,"hdmi framebuffer index is %d",j);
+                mHdmiFbNum = j;
+            } else if(strncmp(fbType, "writeback panel",
+                                    strlen("writeback panel")) == 0){
+                ALOGD_IF(DEBUG,"wfd framebuffer index is %d",j);
+                mWfdFbNum = j;
+            }
+            fclose(displayDeviceFP);
+        }
+    }
+    ALOGD_IF(DEBUG,"%s: mHdmiFbNum: %d mWfdFbNum: %d ",__FUNCTION__,
+                                                       mHdmiFbNum, mWfdFbNum);
+}
+
+int ExternalDisplay::configureHDMIDisplay() {
+    openFrameBuffer(mHdmiFbNum);
+    if(mFd == -1)
+        return -1;
+    readCEUnderscanInfo();
+    readResolution();
+    // TODO: Move this to activate
+    /* Used for changing the resolution
+     * getUserMode will get the preferred
+     * mode set thru adb shell */
+    int mode = getUserMode();
+    if (mode == -1) {
+        //Get the best mode and set
+        mode = getBestMode();
+    }
+    setResolution(mode);
+    setDpyHdmiAttr();
+    setExternalDisplay(true, mHdmiFbNum);
+    return 0;
+}
+
+int ExternalDisplay::configureWFDDisplay() {
+    int ret = 0;
+    if(mConnectedFbNum == mHdmiFbNum) {
+        ALOGE("%s: Cannot process WFD connection while HDMI is active",
+                     __FUNCTION__);
+        return -1;
+    }
+    openFrameBuffer(mWfdFbNum);
+    if(mFd == -1)
+        return -1;
+    ret = ioctl(mFd, FBIOGET_VSCREENINFO, &mVInfo);
+    if(ret < 0) {
+        ALOGD("In %s: FBIOGET_VSCREENINFO failed Err Str = %s", __FUNCTION__,
+                strerror(errno));
+    }
+    setDpyWfdAttr();
+    setExternalDisplay(true, mWfdFbNum);
+    return 0;
+}
+
+int ExternalDisplay::teardownHDMIDisplay() {
+    if(mConnectedFbNum == mHdmiFbNum) {
+        // hdmi offline event..!
+        closeFrameBuffer();
+        resetInfo();
+        setExternalDisplay(false);
+    }
+    return 0;
+}
+
+int ExternalDisplay::teardownWFDDisplay() {
+    if(mConnectedFbNum == mWfdFbNum) {
+        // wfd offline event..!
+        closeFrameBuffer();
+        memset(&mVInfo, 0, sizeof(mVInfo));
+        setExternalDisplay(false);
+    }
+    return 0;
+}
+
+void ExternalDisplay::processUEventOnline(const char *str) {
+    const char *s1 = str + strlen("change@/devices/virtual/switch/");
+    if(!strncmp(s1,"hdmi",strlen(s1))) {
+        // hdmi online event..!
+        configureHDMIDisplay();
+        // set system property
+        property_set("hw.hdmiON", "1");
+    }else if(!strncmp(s1,"wfd",strlen(s1))) {
+        // wfd online event..!
+        configureWFDDisplay();
+    }
+}
+
+void ExternalDisplay::processUEventOffline(const char *str) {
+    const char *s1 = str + strlen("change@/devices/virtual/switch/");
+    if(!strncmp(s1,"hdmi",strlen(s1))) {
+        teardownHDMIDisplay();
+        // unset system property
+        property_set("hw.hdmiON", "0");
+    }else if(!strncmp(s1,"wfd",strlen(s1))) {
+        teardownWFDDisplay();
+    }
+}
+
+ExternalDisplay::ExternalDisplay(hwc_context_t* ctx):mFd(-1),
+    mCurrentMode(-1), mConnected(0), mConnectedFbNum(0), mModeCount(0),
+    mUnderscanSupported(false), mHwcContext(ctx), mHdmiFbNum(-1),
+    mWfdFbNum(-1), mExtDpyNum(HWC_DISPLAY_EXTERNAL)
+{
+    memset(&mVInfo, 0, sizeof(mVInfo));
+    //Determine the fb index for external display devices.
+    updateExtDispDevFbIndex();
+    // disable HPD at start, it will be enabled later
+    // when the display powers on
+    // This helps for framework reboot or adb shell stop/start
+    writeHPDOption(0);
+
+    // for HDMI - retreive all the modes supported by the driver
+    if(mHdmiFbNum != -1) {
+        supported_video_mode_lut =
+                        new msm_hdmi_mode_timing_info[HDMI_VFRMT_MAX];
+        // Populate the mode table for supported modes
+        MSM_HDMI_MODES_INIT_TIMINGS(supported_video_mode_lut);
+        MSM_HDMI_MODES_SET_SUPP_TIMINGS(supported_video_mode_lut,
+                                        MSM_HDMI_MODES_ALL);
+        // Update the Source Product Information
+        // Vendor Name
+        setSPDInfo("vendor_name", "ro.product.manufacturer");
+        // Product Description
+        setSPDInfo("product_description", "ro.product.name");
+    }
+}
+/* gets the product manufacturer and product name and writes it
+ * to the sysfs node, so that the driver can get that information
+ * Used to show QCOM 8974 instead of Input 1 for example
+ */
+void ExternalDisplay::setSPDInfo(const char* node, const char* property) {
+    int err = -1;
+    char info[PROPERTY_VALUE_MAX];
+    char sysFsSPDFilePath[MAX_SYSFS_FILE_PATH];
+    memset(sysFsSPDFilePath, 0, sizeof(sysFsSPDFilePath));
+    snprintf(sysFsSPDFilePath , sizeof(sysFsSPDFilePath),
+                 "/sys/devices/virtual/graphics/fb%d/%s",
+                 mHdmiFbNum, node);
+    int spdFile = open(sysFsSPDFilePath, O_RDWR, 0);
+    if (spdFile < 0) {
+        ALOGE("%s: file '%s' not found : ret = %d"
+              "err str: %s",  __FUNCTION__, sysFsSPDFilePath,
+              spdFile, strerror(errno));
+    } else {
+        memset(info, 0, sizeof(info));
+        property_get(property, info, UNKNOWN_STRING);
+        ALOGD_IF(DEBUG, "In %s: %s = %s", __FUNCTION__, property, info);
+        if (strncmp(info, UNKNOWN_STRING, SPD_NAME_LENGTH)) {
+            err = write(spdFile, info, strlen(info));
+            if (err <= 0) {
+                ALOGE("%s: file write failed for '%s'"
+                      "err no = %d", __FUNCTION__, sysFsSPDFilePath, errno);
+            }
+        } else {
+            ALOGD_IF(DEBUG, "%s: property_get failed for SPD %s",
+                         __FUNCTION__, node);
+        }
+        close(spdFile);
+    }
+}
+
+void ExternalDisplay::setEDIDMode(int resMode) {
+    ALOGD_IF(DEBUG,"resMode=%d ", resMode);
+    {
+        Mutex::Autolock lock(mExtDispLock);
+        setExternalDisplay(false);
+        openFrameBuffer(mHdmiFbNum);
+        setResolution(resMode);
+    }
+    setExternalDisplay(true, mHdmiFbNum);
+}
+
+void ExternalDisplay::setHPD(uint32_t startEnd) {
+    ALOGD_IF(DEBUG,"HPD enabled=%d", startEnd);
+    writeHPDOption(startEnd);
+}
+
+void ExternalDisplay::setActionSafeDimension(int w, int h) {
+    ALOGD_IF(DEBUG,"ActionSafe w=%d h=%d", w, h);
+    Mutex::Autolock lock(mExtDispLock);
+    char actionsafeWidth[PROPERTY_VALUE_MAX];
+    char actionsafeHeight[PROPERTY_VALUE_MAX];
+    snprintf(actionsafeWidth, sizeof(actionsafeWidth), "%d", w);
+    property_set("persist.sys.actionsafe.width", actionsafeWidth);
+    snprintf(actionsafeHeight, sizeof(actionsafeHeight), "%d", h);
+    property_set("persist.sys.actionsafe.height", actionsafeHeight);
+    setExternalDisplay(true, mHdmiFbNum);
+}
+
+int ExternalDisplay::getModeCount() const {
+    ALOGD_IF(DEBUG,"HPD mModeCount=%d", mModeCount);
+    Mutex::Autolock lock(mExtDispLock);
+    return mModeCount;
+}
+
+void ExternalDisplay::getEDIDModes(int *out) const {
+    Mutex::Autolock lock(mExtDispLock);
+    for(int i = 0;i < mModeCount;i++) {
+        out[i] = mEDIDModes[i];
+    }
+}
+
+void ExternalDisplay::readCEUnderscanInfo()
+{
+    int hdmiScanInfoFile = -1;
+    int len = -1;
+    char scanInfo[17];
+    char *ce_info_str = NULL;
+    const char token[] = ", \n";
+    int ce_info = -1;
+    char sysFsScanInfoFilePath[MAX_SYSFS_FILE_PATH];
+    snprintf(sysFsScanInfoFilePath, sizeof(sysFsScanInfoFilePath),
+            "/sys/devices/virtual/graphics/fb%d/"
+                                   "scan_info", mHdmiFbNum);
+
+    memset(scanInfo, 0, sizeof(scanInfo));
+    hdmiScanInfoFile = open(sysFsScanInfoFilePath, O_RDONLY, 0);
+    if (hdmiScanInfoFile < 0) {
+        ALOGD_IF(DEBUG, "%s: scan_info file '%s' not found",
+                                __FUNCTION__, sysFsScanInfoFilePath);
+        return;
+    } else {
+        len = read(hdmiScanInfoFile, scanInfo, sizeof(scanInfo)-1);
+        ALOGD("%s: Scan Info string: %s length = %d",
+                 __FUNCTION__, scanInfo, len);
+        if (len <= 0) {
+            close(hdmiScanInfoFile);
+            ALOGE("%s: Scan Info file empty '%s'",
+                                __FUNCTION__, sysFsScanInfoFilePath);
+            return;
+        }
+        scanInfo[len] = '\0';  /* null terminate the string */
+    }
+    close(hdmiScanInfoFile);
+
+    /*
+     * The scan_info contains the three fields
+     * PT - preferred video format
+     * IT - video format
+     * CE video format - containing the underscan support information
+     */
+
+    /* PT */
+    ce_info_str = strtok(scanInfo, token);
+    if (ce_info_str) {
+        /* IT */
+        ce_info_str = strtok(NULL, token);
+        if (ce_info_str) {
+            /* CE */
+            ce_info_str = strtok(NULL, token);
+            if (ce_info_str)
+                ce_info = atoi(ce_info_str);
+        }
+    }
+
+    if (ce_info_str) {
+        // ce_info contains the underscan information
+        if (ce_info == EXT_SCAN_ALWAYS_UNDERSCANED ||
+            ce_info == EXT_SCAN_BOTH_SUPPORTED)
+            // if TV supported underscan, then driver will always underscan
+            // hence no need to apply action safe rectangle
+            mUnderscanSupported = true;
+    } else {
+        ALOGE("%s: scan_info string error", __FUNCTION__);
+    }
+
+    // Store underscan support info in a system property
+    const char* prop = (mUnderscanSupported) ? "1" : "0";
+    property_set("hw.underscan_supported", prop);
+    return;
+}
+
+ExternalDisplay::~ExternalDisplay()
+{
+    delete [] supported_video_mode_lut;
+    closeFrameBuffer();
+}
+
+/*
+ * sets the fb_var_screeninfo from the hdmi_mode_timing_info
+ */
+void setDisplayTiming(struct fb_var_screeninfo &info,
+                                const msm_hdmi_mode_timing_info* mode)
+{
+    info.reserved[0] = 0;
+    info.reserved[1] = 0;
+    info.reserved[2] = 0;
+#ifndef FB_METADATA_VIDEO_INFO_CODE_SUPPORT
+    info.reserved[3] = (info.reserved[3] & 0xFFFF) |
+              (mode->video_format << 16);
+#endif
+    info.xoffset = 0;
+    info.yoffset = 0;
+    info.xres = mode->active_h;
+    info.yres = mode->active_v;
+
+    info.pixclock = (mode->pixel_freq)*1000;
+    info.vmode = mode->interlaced ?
+                    FB_VMODE_INTERLACED : FB_VMODE_NONINTERLACED;
+
+    info.right_margin = mode->front_porch_h;
+    info.hsync_len = mode->pulse_width_h;
+    info.left_margin = mode->back_porch_h;
+    info.lower_margin = mode->front_porch_v;
+    info.vsync_len = mode->pulse_width_v;
+    info.upper_margin = mode->back_porch_v;
+}
+
+int ExternalDisplay::parseResolution(char* edidStr, int* edidModes)
+{
+    char delim = ',';
+    int count = 0;
+    char *start, *end;
+    // EDIDs are string delimited by ','
+    // Ex: 16,4,5,3,32,34,1
+    // Parse this string to get mode(int)
+    start = (char*) edidStr;
+    end = &delim;
+    while(*end == delim) {
+        edidModes[count] = (int) strtol(start, &end, 10);
+        start = end+1;
+        count++;
+    }
+    ALOGD_IF(DEBUG, "In %s: count = %d", __FUNCTION__, count);
+    for (int i = 0; i < count; i++)
+        ALOGD_IF(DEBUG, "Mode[%d] = %d", i, edidModes[i]);
+    return count;
+}
+
+bool ExternalDisplay::readResolution()
+{
+    char sysFsEDIDFilePath[MAX_SYSFS_FILE_PATH];
+    snprintf(sysFsEDIDFilePath , sizeof(sysFsEDIDFilePath),
+            "/sys/devices/virtual/graphics/fb%d/edid_modes", mHdmiFbNum);
+
+    int hdmiEDIDFile = open(sysFsEDIDFilePath, O_RDONLY, 0);
+    int len = -1;
+
+    if (hdmiEDIDFile < 0) {
+        ALOGE("%s: edid_modes file '%s' not found",
+                 __FUNCTION__, sysFsEDIDFilePath);
+        return false;
+    } else {
+        len = read(hdmiEDIDFile, mEDIDs, sizeof(mEDIDs)-1);
+        ALOGD_IF(DEBUG, "%s: EDID string: %s length = %d",
+                 __FUNCTION__, mEDIDs, len);
+        if ( len <= 0) {
+            ALOGE("%s: edid_modes file empty '%s'",
+                     __FUNCTION__, sysFsEDIDFilePath);
+        }
+        else {
+            while (len > 1 && isspace(mEDIDs[len-1]))
+                --len;
+            mEDIDs[len] = 0;
+        }
+    }
+    close(hdmiEDIDFile);
+    if(len > 0) {
+        // Get EDID modes from the EDID strings
+        mModeCount = parseResolution(mEDIDs, mEDIDModes);
+        ALOGD_IF(DEBUG, "%s: mModeCount = %d", __FUNCTION__,
+                 mModeCount);
+    }
+
+    return (strlen(mEDIDs) > 0);
+}
+
+bool ExternalDisplay::openFrameBuffer(int fbNum)
+{
+    if (mFd == -1) {
+        mFd = open(msmFbDevicePath[fbNum-1], O_RDWR);
+        if (mFd < 0)
+            ALOGE("%s: %s is not available", __FUNCTION__,
+                                            msmFbDevicePath[fbNum-1]);
+        if(mHwcContext) {
+            mHwcContext->dpyAttr[mExtDpyNum].fd = mFd;
+        }
+    }
+    return (mFd > 0);
+}
+
+bool ExternalDisplay::closeFrameBuffer()
+{
+    int ret = 0;
+    if(mFd >= 0) {
+        ret = close(mFd);
+        mFd = -1;
+    }
+    if(mHwcContext) {
+        mHwcContext->dpyAttr[mExtDpyNum].fd = mFd;
+    }
+    return (ret == 0);
+}
+
+// clears the vinfo, edid, best modes
+void ExternalDisplay::resetInfo()
+{
+    memset(&mVInfo, 0, sizeof(mVInfo));
+    memset(mEDIDs, 0, sizeof(mEDIDs));
+    memset(mEDIDModes, 0, sizeof(mEDIDModes));
+    mModeCount = 0;
+    mCurrentMode = -1;
+    mUnderscanSupported = false;
+    // Reset the underscan supported system property
+    const char* prop = "0";
+    property_set("hw.underscan_supported", prop);
+}
+
+int ExternalDisplay::getModeOrder(int mode)
+{
+    // XXX: We dont support interlaced modes but having
+    // it here for future
+    switch (mode) {
+        default:
+        case HDMI_VFRMT_1440x480i60_4_3:
+            return 1; // 480i 4:3
+        case HDMI_VFRMT_1440x480i60_16_9:
+            return 2; // 480i 16:9
+        case HDMI_VFRMT_1440x576i50_4_3:
+            return 3; // i576i 4:3
+        case HDMI_VFRMT_1440x576i50_16_9:
+            return 4; // 576i 16:9
+        case HDMI_VFRMT_1920x1080i60_16_9:
+            return 5; // 1080i 16:9
+        case HDMI_VFRMT_640x480p60_4_3:
+            return 6; // 640x480 4:3
+        case HDMI_VFRMT_720x480p60_4_3:
+            return 7; // 480p 4:3
+        case HDMI_VFRMT_720x480p60_16_9:
+            return 8; // 480p 16:9
+        case HDMI_VFRMT_720x576p50_4_3:
+            return 9; // 576p 4:3
+        case HDMI_VFRMT_720x576p50_16_9:
+            return 10; // 576p 16:9
+        case HDMI_VFRMT_1024x768p60_4_3:
+            return 11; // 768p 4:3 Vesa format
+        case HDMI_VFRMT_1280x1024p60_5_4:
+            return 12; // 1024p Vesa format
+        case HDMI_VFRMT_1280x720p50_16_9:
+            return 13; // 720p@50Hz
+        case HDMI_VFRMT_1280x720p60_16_9:
+            return 14; // 720p@60Hz
+        case HDMI_VFRMT_1920x1080p24_16_9:
+            return 15; //1080p@24Hz
+        case HDMI_VFRMT_1920x1080p25_16_9:
+            return 16; //108-p@25Hz
+        case HDMI_VFRMT_1920x1080p30_16_9:
+            return 17; //1080p@30Hz
+        case HDMI_VFRMT_1920x1080p50_16_9:
+            return 18; //1080p@50Hz
+        case HDMI_VFRMT_1920x1080p60_16_9:
+            return 19; //1080p@60Hz
+        case HDMI_VFRMT_2560x1600p60_16_9:
+            return 20; //WQXGA@60Hz541
+        case HDMI_VFRMT_3840x2160p24_16_9:
+            return 21;//2160@24Hz
+        case HDMI_VFRMT_3840x2160p25_16_9:
+            return 22;//2160@25Hz
+        case HDMI_VFRMT_3840x2160p30_16_9:
+            return 23; //2160@30Hz
+        case HDMI_VFRMT_4096x2160p24_16_9:
+            return 24; //4kx2k@24Hz
+    }
+}
+
+/// Returns the user mode set(if any) using adb shell
+int ExternalDisplay::getUserMode() {
+    /* Based on the property set the resolution */
+    char property_value[PROPERTY_VALUE_MAX];
+    property_get("hw.hdmi.resolution", property_value, "-1");
+    int mode = atoi(property_value);
+    // We dont support interlaced modes
+    if(isValidMode(mode) && !isInterlacedMode(mode)) {
+        ALOGD_IF(DEBUG, "%s: setting the HDMI mode = %d", __FUNCTION__, mode);
+        return mode;
+    }
+    return -1;
+}
+
+// Get the best mode for the current HD TV
+int ExternalDisplay::getBestMode() {
+    int bestOrder = 0;
+    int bestMode = HDMI_VFRMT_640x480p60_4_3;
+    Mutex::Autolock lock(mExtDispLock);
+    // for all the edid read, get the best mode
+    for(int i = 0; i < mModeCount; i++) {
+        int mode = mEDIDModes[i];
+        int order = getModeOrder(mode);
+        if (order > bestOrder) {
+            bestOrder = order;
+            bestMode = mode;
+        }
+    }
+    return bestMode;
+}
+
+inline bool ExternalDisplay::isValidMode(int ID)
+{
+    bool valid = false;
+    for (int i = 0; i < mModeCount; i++) {
+        if(ID == mEDIDModes[i]) {
+            valid = true;
+            break;
+        }
+    }
+    return valid;
+}
+
+// returns true if the mode(ID) is interlaced mode format
+bool ExternalDisplay::isInterlacedMode(int ID) {
+    bool interlaced = false;
+    switch(ID) {
+        case HDMI_VFRMT_1440x480i60_4_3:
+        case HDMI_VFRMT_1440x480i60_16_9:
+        case HDMI_VFRMT_1440x576i50_4_3:
+        case HDMI_VFRMT_1440x576i50_16_9:
+        case HDMI_VFRMT_1920x1080i60_16_9:
+            interlaced = true;
+            break;
+        default:
+            interlaced = false;
+            break;
+    }
+    return interlaced;
+}
+
+void ExternalDisplay::setResolution(int ID)
+{
+    int ret = 0;
+    ret = ioctl(mFd, FBIOGET_VSCREENINFO, &mVInfo);
+    if(ret < 0) {
+        ALOGD("In %s: FBIOGET_VSCREENINFO failed Err Str = %s", __FUNCTION__,
+                                                            strerror(errno));
+    }
+    ALOGD_IF(DEBUG, "%s: GET Info<ID=%d %dx%d (%d,%d,%d),"
+            "(%d,%d,%d) %dMHz>", __FUNCTION__,
+            mVInfo.reserved[3], mVInfo.xres, mVInfo.yres,
+            mVInfo.right_margin, mVInfo.hsync_len, mVInfo.left_margin,
+            mVInfo.lower_margin, mVInfo.vsync_len, mVInfo.upper_margin,
+            mVInfo.pixclock/1000/1000);
+    //If its a new ID - update var_screeninfo
+    if ((isValidMode(ID)) && mCurrentMode != ID) {
+        const struct msm_hdmi_mode_timing_info *mode =
+            &supported_video_mode_lut[0];
+        for (unsigned int i = 0; i < HDMI_VFRMT_MAX; ++i) {
+            const struct msm_hdmi_mode_timing_info *cur =
+                                        &supported_video_mode_lut[i];
+            if (cur->video_format == (uint32_t)ID) {
+                mode = cur;
+                break;
+            }
+        }
+        setDisplayTiming(mVInfo, mode);
+        ALOGD_IF(DEBUG, "%s: SET Info<ID=%d => Info<ID=%d %dx %d"
+                 "(%d,%d,%d), (%d,%d,%d) %dMHz>", __FUNCTION__, ID,
+                 mode->video_format, mVInfo.xres, mVInfo.yres,
+                 mVInfo.right_margin, mVInfo.hsync_len, mVInfo.left_margin,
+                 mVInfo.lower_margin, mVInfo.vsync_len, mVInfo.upper_margin,
+                 mVInfo.pixclock/1000/1000);
+#ifdef FB_METADATA_VIDEO_INFO_CODE_SUPPORT
+        struct msmfb_metadata metadata;
+        memset(&metadata, 0 , sizeof(metadata));
+        metadata.op = metadata_op_vic;
+        metadata.data.video_info_code = mode->video_format;
+        if (ioctl(mFd, MSMFB_METADATA_SET, &metadata) == -1) {
+            ALOGD("In %s: MSMFB_METADATA_SET failed Err Str = %s",
+                                                 __FUNCTION__, strerror(errno));
+        }
+#endif
+        mVInfo.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_ALL | FB_ACTIVATE_FORCE;
+        ret = ioctl(mFd, FBIOPUT_VSCREENINFO, &mVInfo);
+        if(ret < 0) {
+            ALOGD("In %s: FBIOPUT_VSCREENINFO failed Err Str = %s",
+                                                 __FUNCTION__, strerror(errno));
+        }
+        mCurrentMode = ID;
+    }
+}
+
+void ExternalDisplay::setExternalDisplay(bool connected, int extFbNum)
+{
+    hwc_context_t* ctx = mHwcContext;
+    if(ctx) {
+        ALOGD_IF(DEBUG, "%s: connected = %d", __FUNCTION__, connected);
+        // Store the external display
+        mConnected = connected;
+        mConnectedFbNum = extFbNum;
+        mHwcContext->dpyAttr[mExtDpyNum].connected = connected;
+    }
+}
+
+int ExternalDisplay::getExtFbNum(int &fbNum) {
+    int ret = -1;
+    if(mConnected) {
+        fbNum = mConnectedFbNum;
+        ret = 0;
+    }
+    return ret;
+}
+
+bool ExternalDisplay::writeHPDOption(int userOption) const
+{
+    bool ret = true;
+    if(mHdmiFbNum != -1) {
+        char sysFsHPDFilePath[255];
+        snprintf(sysFsHPDFilePath ,sizeof(sysFsHPDFilePath),
+                 "/sys/devices/virtual/graphics/fb%d/hpd", mHdmiFbNum);
+        int hdmiHPDFile = open(sysFsHPDFilePath,O_RDWR, 0);
+        if (hdmiHPDFile < 0) {
+            ALOGE("%s: state file '%s' not found : ret%d err str: %s", __FUNCTION__,
+                  sysFsHPDFilePath, hdmiHPDFile, strerror(errno));
+            ret = false;
+        } else {
+            int err = -1;
+            ALOGD_IF(DEBUG, "%s: option = %d", __FUNCTION__, userOption);
+            if(userOption)
+                err = write(hdmiHPDFile, "1", 2);
+            else
+                err = write(hdmiHPDFile, "0" , 2);
+            if (err <= 0) {
+                ALOGE("%s: file write failed '%s'", __FUNCTION__, sysFsHPDFilePath);
+                ret = false;
+            }
+            close(hdmiHPDFile);
+        }
+    }
+    return ret;
+}
+
+void ExternalDisplay::setDpyWfdAttr() {
+    if(mHwcContext) {
+        mHwcContext->dpyAttr[mExtDpyNum].xres = mVInfo.xres;
+        mHwcContext->dpyAttr[mExtDpyNum].yres = mVInfo.yres;
+        mHwcContext->dpyAttr[mExtDpyNum].vsync_period =
+                1000000000l /60;
+        ALOGD_IF(DEBUG,"%s: wfd...connected..!",__FUNCTION__);
+    }
+}
+
+void ExternalDisplay::setDpyHdmiAttr() {
+    int width = 0, height = 0, fps = 0;
+    getAttrForMode(width, height, fps);
+    if(mHwcContext) {
+        ALOGD("ExtDisplay setting xres = %d, yres = %d", width, height);
+        mHwcContext->dpyAttr[HWC_DISPLAY_EXTERNAL].xres = width;
+        mHwcContext->dpyAttr[HWC_DISPLAY_EXTERNAL].yres = height;
+        mHwcContext->dpyAttr[HWC_DISPLAY_EXTERNAL].vsync_period =
+            1000000000l / fps;
+    }
+}
+
+void ExternalDisplay::getAttrForMode(int& width, int& height, int& fps) {
+    switch (mCurrentMode) {
+        case HDMI_VFRMT_640x480p60_4_3:
+            width = 640;
+            height = 480;
+            fps = 60;
+            break;
+        case HDMI_VFRMT_720x480p60_4_3:
+        case HDMI_VFRMT_720x480p60_16_9:
+            width = 720;
+            height = 480;
+            fps = 60;
+            break;
+        case HDMI_VFRMT_720x576p50_4_3:
+        case HDMI_VFRMT_720x576p50_16_9:
+            width = 720;
+            height = 576;
+            fps = 50;
+            break;
+        case HDMI_VFRMT_1280x720p50_16_9:
+            width = 1280;
+            height = 720;
+            fps = 50;
+            break;
+        case HDMI_VFRMT_1280x720p60_16_9:
+            width = 1280;
+            height = 720;
+            fps = 60;
+            break;
+        case HDMI_VFRMT_1280x1024p60_5_4:
+            width = 1280;
+            height = 1024;
+            fps = 60;
+            break;
+        case HDMI_VFRMT_1024x768p60_4_3:
+            width = 1024;
+            height = 768;
+            fps = 60;
+            break;
+        case HDMI_VFRMT_1920x1080p24_16_9:
+            width = 1920;
+            height = 1080;
+            fps = 24;
+            break;
+        case HDMI_VFRMT_1920x1080p25_16_9:
+            width = 1920;
+            height = 1080;
+            fps = 25;
+            break;
+        case HDMI_VFRMT_1920x1080p30_16_9:
+            width = 1920;
+            height = 1080;
+            fps = 30;
+            break;
+        case HDMI_VFRMT_1920x1080p50_16_9:
+            width = 1920;
+            height = 1080;
+            fps = 50;
+            break;
+        case HDMI_VFRMT_1920x1080p60_16_9:
+            width = 1920;
+            height = 1080;
+            fps = 60;
+            break;
+        case HDMI_VFRMT_2560x1600p60_16_9:
+            width = 2560;
+            height = 1600;
+            fps = 60;
+            break;
+        case HDMI_VFRMT_3840x2160p24_16_9:
+            width = 3840;
+            height = 2160;
+            fps = 24;
+            break;
+        case HDMI_VFRMT_3840x2160p25_16_9:
+            width = 3840;
+            height = 2160;
+            fps = 25;
+            break;
+        case HDMI_VFRMT_3840x2160p30_16_9:
+            width = 3840;
+            height = 2160;
+            fps = 30;
+            break;
+        case HDMI_VFRMT_4096x2160p24_16_9:
+            width = 4096;
+            height = 2160;
+            fps = 24;
+            break;
+
+    }
+}
+
+};
diff --git a/msm8974/libexternal/external.h b/msm8974/libexternal/external.h
new file mode 100644
index 0000000..7601f17
--- /dev/null
+++ b/msm8974/libexternal/external.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HWC_EXTERNAL_DISPLAY_H
+#define HWC_EXTERNAL_DISPLAY_H
+
+#include <utils/threads.h>
+#include <linux/fb.h>
+
+struct hwc_context_t;
+struct msm_hdmi_mode_timing_info;
+
+namespace qhwc {
+
+//Type of scanning of EDID(Video Capability Data Block)
+enum external_scansupport_type {
+    EXT_SCAN_NOT_SUPPORTED      = 0,
+    EXT_SCAN_ALWAYS_OVERSCANED  = 1,
+    EXT_SCAN_ALWAYS_UNDERSCANED = 2,
+    EXT_SCAN_BOTH_SUPPORTED     = 3
+};
+
+class ExternalDisplay
+{
+public:
+    ExternalDisplay(hwc_context_t* ctx);
+    ~ExternalDisplay();
+    int getModeCount() const;
+    void getEDIDModes(int *out) const;
+    bool isCEUnderscanSupported() { return mUnderscanSupported; }
+    void setExternalDisplay(bool connected, int extFbNum = 0);
+    bool isExternalConnected() { return mConnected;};
+    void  setExtDpyNum(int extDpyNum) { mExtDpyNum = extDpyNum;};
+    void setHPD(uint32_t startEnd);
+    void setEDIDMode(int resMode);
+    void setActionSafeDimension(int w, int h);
+    void processUEventOnline(const char *str);
+    void processUEventOffline(const char *str);
+    int getHDMIIndex() { return mHdmiFbNum; }
+
+private:
+    void setSPDInfo(const char* node, const char* property);
+    void readCEUnderscanInfo();
+    bool readResolution();
+    int  parseResolution(char* edidStr, int* edidModes);
+    void setResolution(int ID);
+    bool openFrameBuffer(int fbNum);
+    bool closeFrameBuffer();
+    bool writeHPDOption(int userOption) const;
+    bool isValidMode(int ID);
+    void handleUEvent(char* str, int len);
+    int  getModeOrder(int mode);
+    int  getUserMode();
+    int  getBestMode();
+    bool isInterlacedMode(int mode);
+    void resetInfo();
+    void setDpyHdmiAttr();
+    void setDpyWfdAttr();
+    void getAttrForMode(int& width, int& height, int& fps);
+    void updateExtDispDevFbIndex();
+    int  configureHDMIDisplay();
+    int  configureWFDDisplay();
+    int  teardownHDMIDisplay();
+    int  teardownWFDDisplay();
+    int  getExtFbNum(int &fbNum);
+
+    mutable android::Mutex mExtDispLock;
+    int mFd;
+    int mCurrentMode;
+    int mConnected;
+    int mConnectedFbNum;
+    int mResolutionMode;
+    char mEDIDs[128];
+    int mEDIDModes[64];
+    int mModeCount;
+    bool mUnderscanSupported;
+    hwc_context_t *mHwcContext;
+    fb_var_screeninfo mVInfo;
+    int mHdmiFbNum;
+    int mWfdFbNum;
+    int mExtDpyNum;
+    // Holds all the HDMI modes and timing info supported by driver
+    msm_hdmi_mode_timing_info* supported_video_mode_lut;
+};
+
+}; //qhwc
+// ---------------------------------------------------------------------------
+#endif //HWC_EXTERNAL_DISPLAY_H
diff --git a/msm8974/libgralloc/Android.mk b/msm8974/libgralloc/Android.mk
new file mode 100644
index 0000000..2f18ee8
--- /dev/null
+++ b/msm8974/libgralloc/Android.mk
@@ -0,0 +1,48 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Gralloc module
+LOCAL_PATH := $(call my-dir)
+include $(LOCAL_PATH)/../common.mk
+include $(CLEAR_VARS)
+
+# gralloc.cpp:87  use of GNU old-style field designator extension.
+LOCAL_CLANG_CFLAGS            += -Wno-gnu-designator
+
+LOCAL_MODULE                  := gralloc.$(TARGET_BOARD_PLATFORM)
+LOCAL_MODULE_PATH             := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_MODULE_TAGS             := optional
+LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)
+LOCAL_SHARED_LIBRARIES        := $(common_libs) libmemalloc
+LOCAL_SHARED_LIBRARIES        += libqdutils libGLESv1_CM
+LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"qdgralloc\"
+LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps) $(kernel_deps)
+LOCAL_SRC_FILES               := gpu.cpp gralloc.cpp framebuffer.cpp mapper.cpp
+LOCAL_COPY_HEADERS_TO         := $(common_header_export_path)
+LOCAL_COPY_HEADERS            := gralloc_priv.h
+
+include $(BUILD_SHARED_LIBRARY)
+
+# MemAlloc Library
+include $(CLEAR_VARS)
+
+LOCAL_MODULE                  := libmemalloc
+LOCAL_MODULE_TAGS             := optional
+LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)
+LOCAL_SHARED_LIBRARIES        := $(common_libs) libqdutils libdl
+LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"qdmemalloc\"
+LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps) $(kernel_deps)
+LOCAL_SRC_FILES               := ionalloc.cpp alloc_controller.cpp
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/msm8974/libgralloc/MODULE_LICENSE_APACHE2 b/msm8974/libgralloc/MODULE_LICENSE_APACHE2
new file mode 100644
index 0000000..e69de29
diff --git a/msm8974/libgralloc/NOTICE b/msm8974/libgralloc/NOTICE
new file mode 100644
index 0000000..3237da6
--- /dev/null
+++ b/msm8974/libgralloc/NOTICE
@@ -0,0 +1,190 @@
+
+   Copyright (c) 2008-2009, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/msm8974/libgralloc/alloc_controller.cpp b/msm8974/libgralloc/alloc_controller.cpp
new file mode 100644
index 0000000..afcc3bf
--- /dev/null
+++ b/msm8974/libgralloc/alloc_controller.cpp
@@ -0,0 +1,402 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <cutils/log.h>
+#include <fcntl.h>
+#include <dlfcn.h>
+#include "gralloc_priv.h"
+#include "alloc_controller.h"
+#include "memalloc.h"
+#include "ionalloc.h"
+#include "gr.h"
+#include "comptype.h"
+
+#ifdef VENUS_COLOR_FORMAT
+#include <media/msm_media_info.h>
+#else
+#define VENUS_Y_STRIDE(args...) 0
+#define VENUS_Y_SCANLINES(args...) 0
+#define VENUS_BUFFER_SIZE(args...) 0
+#endif
+
+using namespace gralloc;
+using namespace qdutils;
+
+ANDROID_SINGLETON_STATIC_INSTANCE(AdrenoMemInfo);
+
+//Common functions
+static bool canFallback(int usage, bool triedSystem)
+{
+    // Fallback to system heap when alloc fails unless
+    // 1. Composition type is MDP
+    // 2. Alloc from system heap was already tried
+    // 3. The heap type is requsted explicitly
+    // 4. The heap type is protected
+    // 5. The buffer is meant for external display only
+
+    if(QCCompositionType::getInstance().getCompositionType() &
+       COMPOSITION_TYPE_MDP)
+        return false;
+    if(triedSystem)
+        return false;
+    if(usage & (GRALLOC_HEAP_MASK | GRALLOC_USAGE_PROTECTED))
+        return false;
+    if(usage & (GRALLOC_HEAP_MASK | GRALLOC_USAGE_PRIVATE_EXTERNAL_ONLY))
+        return false;
+    //Return true by default
+    return true;
+}
+
+static bool useUncached(int usage)
+{
+    if (usage & GRALLOC_USAGE_PRIVATE_UNCACHED)
+        return true;
+    if(((usage & GRALLOC_USAGE_SW_WRITE_MASK) == GRALLOC_USAGE_SW_WRITE_RARELY)
+       ||((usage & GRALLOC_USAGE_SW_READ_MASK) == GRALLOC_USAGE_SW_READ_RARELY))
+        return true;
+    return false;
+}
+
+//-------------- AdrenoMemInfo-----------------------//
+AdrenoMemInfo::AdrenoMemInfo()
+{
+    libadreno_utils = ::dlopen("libadreno_utils.so", RTLD_NOW);
+    if (libadreno_utils) {
+        *(void **)&LINK_adreno_compute_padding = ::dlsym(libadreno_utils,
+                                           "compute_surface_padding");
+    }
+}
+
+AdrenoMemInfo::~AdrenoMemInfo()
+{
+    if (libadreno_utils) {
+        ::dlclose(libadreno_utils);
+    }
+}
+
+int AdrenoMemInfo::getStride(int width, int format)
+{
+    int stride = ALIGN(width, 32);
+    // Currently surface padding is only computed for RGB* surfaces.
+    if (format <= HAL_PIXEL_FORMAT_BGRA_8888) {
+        // Don't add any additional padding if debug.gralloc.map_fb_memory
+        // is enabled
+        char property[PROPERTY_VALUE_MAX];
+        if((property_get("debug.gralloc.map_fb_memory", property, NULL) > 0) &&
+           (!strncmp(property, "1", PROPERTY_VALUE_MAX ) ||
+           (!strncasecmp(property,"true", PROPERTY_VALUE_MAX )))) {
+              return stride;
+        }
+
+        int bpp = 4;
+        switch(format)
+        {
+            case HAL_PIXEL_FORMAT_RGB_888:
+                bpp = 3;
+                break;
+            case HAL_PIXEL_FORMAT_RGB_565:
+                bpp = 2;
+                break;
+            default: break;
+        }
+        if ((libadreno_utils) && (LINK_adreno_compute_padding)) {
+            int surface_tile_height = 1;   // Linear surface
+            int raster_mode         = 0;   // Adreno unknown raster mode.
+            int padding_threshold   = 512; // Threshold for padding surfaces.
+            // the function below expects the width to be a multiple of
+            // 32 pixels, hence we pass stride instead of width.
+            stride = LINK_adreno_compute_padding(stride, bpp,
+                                      surface_tile_height, raster_mode,
+                                      padding_threshold);
+        }
+    } else {
+        switch (format)
+        {
+            case HAL_PIXEL_FORMAT_YCrCb_420_SP_ADRENO:
+                stride = ALIGN(width, 32);
+                break;
+            case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
+                stride = ALIGN(width, 128);
+                break;
+            case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+            case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+            case HAL_PIXEL_FORMAT_YV12:
+            case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+            case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+            case HAL_PIXEL_FORMAT_RAW16:
+            case HAL_PIXEL_FORMAT_RAW_OPAQUE:
+                stride = ALIGN(width, 16);
+                break;
+            case HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS:
+            case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:
+                stride = VENUS_Y_STRIDE(COLOR_FMT_NV12, width);
+                break;
+            case HAL_PIXEL_FORMAT_BLOB:
+                stride = width;
+                break;
+            case HAL_PIXEL_FORMAT_NV21_ZSL:
+                stride = ALIGN(width, 64);
+                break;
+            default: break;
+        }
+    }
+    return stride;
+}
+
+//-------------- IAllocController-----------------------//
+IAllocController* IAllocController::sController = NULL;
+IAllocController* IAllocController::getInstance(void)
+{
+    if(sController == NULL) {
+        sController = new IonController();
+    }
+    return sController;
+}
+
+
+//-------------- IonController-----------------------//
+IonController::IonController()
+{
+    mIonAlloc = new IonAlloc();
+}
+
+int IonController::allocate(alloc_data& data, int usage)
+{
+    int ionFlags = 0;
+    int ret;
+
+    data.uncached = useUncached(usage);
+    data.allocType = 0;
+
+    if(usage & GRALLOC_USAGE_PRIVATE_UI_CONTIG_HEAP)
+        ionFlags |= ION_HEAP(ION_SF_HEAP_ID);
+
+    if(usage & GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP)
+        ionFlags |= ION_HEAP(ION_SYSTEM_HEAP_ID);
+
+    if(usage & GRALLOC_USAGE_PRIVATE_IOMMU_HEAP)
+        ionFlags |= ION_HEAP(ION_IOMMU_HEAP_ID);
+
+    if(usage & GRALLOC_USAGE_PROTECTED) {
+        if (usage & GRALLOC_USAGE_PRIVATE_MM_HEAP) {
+            ionFlags |= ION_HEAP(ION_CP_MM_HEAP_ID);
+            ionFlags |= ION_SECURE;
+        } else {
+            // for targets/OEMs which do not need HW level protection
+            // do not set ion secure flag & MM heap. Fallback to IOMMU heap
+            // and use DRM for such buffers
+            data.allocType |= private_handle_t::PRIV_FLAGS_L3_SECURE_BUFFER;
+            ionFlags |= ION_HEAP(ION_IOMMU_HEAP_ID);
+        }
+    } else if(usage & GRALLOC_USAGE_PRIVATE_MM_HEAP) {
+        //MM Heap is exclusively a secure heap.
+        //If it is used for non secure cases, fallback to IOMMU heap
+        ALOGW("GRALLOC_USAGE_PRIVATE_MM_HEAP \
+                                cannot be used as an insecure heap!\
+                                trying to use IOMMU instead !!");
+        ionFlags |= ION_HEAP(ION_IOMMU_HEAP_ID);
+    }
+
+    if(usage & GRALLOC_USAGE_PRIVATE_CAMERA_HEAP)
+        ionFlags |= ION_HEAP(ION_CAMERA_HEAP_ID);
+
+    if(usage & GRALLOC_USAGE_PRIVATE_ADSP_HEAP)
+        ionFlags |= ION_HEAP(ION_ADSP_HEAP_ID);
+
+    if(ionFlags & ION_SECURE)
+         data.allocType |= private_handle_t::PRIV_FLAGS_SECURE_BUFFER;
+
+    // if no flags are set, default to
+    // SF + IOMMU heaps, so that bypass can work
+    // we can fall back to system heap if
+    // we run out.
+    if(!ionFlags)
+        ionFlags = ION_HEAP(ION_SF_HEAP_ID) | ION_HEAP(ION_IOMMU_HEAP_ID);
+
+    data.flags = ionFlags;
+    ret = mIonAlloc->alloc_buffer(data);
+
+    // Fallback
+    if(ret < 0 && canFallback(usage,
+                              (ionFlags & ION_SYSTEM_HEAP_ID)))
+    {
+        ALOGW("Falling back to system heap");
+        data.flags = ION_HEAP(ION_SYSTEM_HEAP_ID);
+        ret = mIonAlloc->alloc_buffer(data);
+    }
+
+    if(ret >= 0 ) {
+        data.allocType |= private_handle_t::PRIV_FLAGS_USES_ION;
+    }
+
+    return ret;
+}
+
+IMemAlloc* IonController::getAllocator(int flags)
+{
+    IMemAlloc* memalloc = NULL;
+    if (flags & private_handle_t::PRIV_FLAGS_USES_ION) {
+        memalloc = mIonAlloc;
+    } else {
+        ALOGE("%s: Invalid flags passed: 0x%x", __FUNCTION__, flags);
+    }
+
+    return memalloc;
+}
+
+size_t getBufferSizeAndDimensions(int width, int height, int format,
+                                  int& alignedw, int &alignedh)
+{
+    size_t size;
+
+    alignedw = AdrenoMemInfo::getInstance().getStride(width, format);
+    alignedh = ALIGN(height, 32);
+    switch (format) {
+        case HAL_PIXEL_FORMAT_RGBA_8888:
+        case HAL_PIXEL_FORMAT_RGBX_8888:
+        case HAL_PIXEL_FORMAT_BGRA_8888:
+            size = alignedw * alignedh * 4;
+            break;
+        case HAL_PIXEL_FORMAT_RGB_888:
+            size = alignedw * alignedh * 3;
+            break;
+        case HAL_PIXEL_FORMAT_RGB_565:
+        case HAL_PIXEL_FORMAT_RAW16:
+            size = alignedw * alignedh * 2;
+            break;
+
+            // adreno formats
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP_ADRENO:  // NV21
+            size  = ALIGN(alignedw*alignedh, 4096);
+            size += ALIGN(2 * ALIGN(width/2, 32) * ALIGN(height/2, 32), 4096);
+            break;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:   // NV12
+            // The chroma plane is subsampled,
+            // but the pitch in bytes is unchanged
+            // The GPU needs 4K alignment, but the video decoder needs 8K
+            size  = ALIGN( alignedw * alignedh, 8192);
+            size += ALIGN( alignedw * ALIGN(height/2, 32), 8192);
+            break;
+        case HAL_PIXEL_FORMAT_YV12:
+            if ((format == HAL_PIXEL_FORMAT_YV12) && ((width&1) || (height&1))) {
+                ALOGE("w or h is odd for the YV12 format");
+                return -EINVAL;
+            }
+            alignedh = height;
+            size = alignedw*alignedh +
+                    (ALIGN(alignedw/2, 16) * (alignedh/2))*2;
+            size = ALIGN(size, 4096);
+            break;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+            alignedh = height;
+            size = ALIGN((alignedw*alignedh) + (alignedw* alignedh)/2 + 1, 4096);
+            break;
+        case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+        case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+            if(width & 1) {
+                ALOGE("width is odd for the YUV422_SP format");
+                return -EINVAL;
+            }
+            alignedh = height;
+            size = ALIGN(alignedw * alignedh * 2, 4096);
+            break;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS:
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:
+            alignedh = VENUS_Y_SCANLINES(COLOR_FMT_NV12, height);
+            size = VENUS_BUFFER_SIZE(COLOR_FMT_NV12, width, height);
+            break;
+        case HAL_PIXEL_FORMAT_BLOB:
+        case HAL_PIXEL_FORMAT_RAW_OPAQUE:
+            if(height != 1) {
+                ALOGE("%s: Buffers with RAW_OPAQUE/BLOB formats \
+                      must have height==1 ", __FUNCTION__);
+                return -EINVAL;
+            }
+            alignedh = height;
+            alignedw = width;
+            size = width;
+            break;
+        case HAL_PIXEL_FORMAT_NV21_ZSL:
+            alignedh = ALIGN(height, 64);
+            size = ALIGN((alignedw*alignedh) + (alignedw* alignedh)/2, 4096);
+            break;
+        default:
+            ALOGE("%s: unrecognized pixel format: 0x%x", __FUNCTION__, format);
+            return -EINVAL;
+    }
+
+    return size;
+}
+
+// Allocate buffer from width, height and format into a
+// private_handle_t. It is the responsibility of the caller
+// to free the buffer using the free_buffer function
+int alloc_buffer(private_handle_t **pHnd, int w, int h, int format, int usage)
+{
+    alloc_data data;
+    int alignedw, alignedh;
+    gralloc::IAllocController* sAlloc =
+        gralloc::IAllocController::getInstance();
+    data.base = 0;
+    data.fd = -1;
+    data.offset = 0;
+    data.size = getBufferSizeAndDimensions(w, h, format, alignedw, alignedh);
+    data.align = getpagesize();
+    data.uncached = useUncached(usage);
+    int allocFlags = usage;
+
+    int err = sAlloc->allocate(data, allocFlags);
+    if (0 != err) {
+        ALOGE("%s: allocate failed", __FUNCTION__);
+        return -ENOMEM;
+    }
+
+    private_handle_t* hnd = new private_handle_t(data.fd, data.size,
+                                                 data.allocType, 0, format,
+                                                 alignedw, alignedh);
+    hnd->base = (int) data.base;
+    hnd->offset = data.offset;
+    hnd->gpuaddr = 0;
+    *pHnd = hnd;
+    return 0;
+}
+
+void free_buffer(private_handle_t *hnd)
+{
+    gralloc::IAllocController* sAlloc =
+        gralloc::IAllocController::getInstance();
+    if (hnd && hnd->fd > 0) {
+        IMemAlloc* memalloc = sAlloc->getAllocator(hnd->flags);
+        memalloc->free_buffer((void*)hnd->base, hnd->size, hnd->offset, hnd->fd);
+    }
+    if(hnd)
+        delete hnd;
+
+}
diff --git a/msm8974/libgralloc/alloc_controller.h b/msm8974/libgralloc/alloc_controller.h
new file mode 100644
index 0000000..5fe81fa
--- /dev/null
+++ b/msm8974/libgralloc/alloc_controller.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef GRALLOC_ALLOCCONTROLLER_H
+#define GRALLOC_ALLOCCONTROLLER_H
+
+namespace gralloc {
+
+struct alloc_data;
+class IMemAlloc;
+class IonAlloc;
+
+class IAllocController {
+
+    public:
+    /* Allocate using a suitable method
+     * Returns the type of buffer allocated
+     */
+    virtual int allocate(alloc_data& data, int usage) = 0;
+
+    virtual IMemAlloc* getAllocator(int flags) = 0;
+
+    virtual ~IAllocController() {};
+
+    static IAllocController* getInstance(void);
+
+    private:
+    static IAllocController* sController;
+
+};
+
+class IonController : public IAllocController {
+
+    public:
+    virtual int allocate(alloc_data& data, int usage);
+
+    virtual IMemAlloc* getAllocator(int flags);
+
+    IonController();
+
+    private:
+    IonAlloc* mIonAlloc;
+
+};
+} //end namespace gralloc
+#endif // GRALLOC_ALLOCCONTROLLER_H
diff --git a/msm8974/libgralloc/fb_priv.h b/msm8974/libgralloc/fb_priv.h
new file mode 100644
index 0000000..f7a24a0
--- /dev/null
+++ b/msm8974/libgralloc/fb_priv.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FB_PRIV_H
+#define FB_PRIV_H
+#include <linux/fb.h>
+#include <linux/msm_mdp.h>
+
+#define NUM_FRAMEBUFFERS_MIN  2
+#define NUM_FRAMEBUFFERS_MAX  3
+
+#define NO_SURFACEFLINGER_SWAPINTERVAL
+#define COLOR_FORMAT(x) (x & 0xFFF) // Max range for colorFormats is 0 - FFF
+
+struct private_handle_t;
+
+enum {
+    // flag to indicate we'll post this buffer
+    PRIV_USAGE_LOCKED_FOR_POST = 0x80000000,
+    PRIV_MIN_SWAP_INTERVAL = 0,
+    PRIV_MAX_SWAP_INTERVAL = 1,
+};
+
+struct private_module_t {
+    gralloc_module_t base;
+    struct private_handle_t* framebuffer;
+    uint32_t fbFormat;
+    uint32_t flags;
+    uint32_t numBuffers;
+    uint32_t bufferMask;
+    pthread_mutex_t lock;
+    private_handle_t *currentBuffer;
+    struct fb_var_screeninfo info;
+    struct mdp_display_commit commit;
+    struct fb_fix_screeninfo finfo;
+    float xdpi;
+    float ydpi;
+    float fps;
+    uint32_t swapInterval;
+    uint32_t currentOffset;
+};
+
+
+
+#endif /* FB_PRIV_H */
diff --git a/msm8974/libgralloc/framebuffer.cpp b/msm8974/libgralloc/framebuffer.cpp
new file mode 100644
index 0000000..36c883d
--- /dev/null
+++ b/msm8974/libgralloc/framebuffer.cpp
@@ -0,0 +1,410 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2010-2013 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sys/mman.h>
+
+#include <cutils/log.h>
+#include <cutils/properties.h>
+#include <dlfcn.h>
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <cutils/atomic.h>
+
+#include <linux/fb.h>
+#include <linux/msm_mdp.h>
+
+#include <GLES/gl.h>
+
+#include "gralloc_priv.h"
+#include "fb_priv.h"
+#include "gr.h"
+#include <cutils/properties.h>
+#include <profiler.h>
+
+#define EVEN_OUT(x) if (x & 0x0001) {x--;}
+/** min of int a, b */
+static inline int min(int a, int b) {
+    return (a<b) ? a : b;
+}
+/** max of int a, b */
+static inline int max(int a, int b) {
+    return (a>b) ? a : b;
+}
+
+enum {
+    PAGE_FLIP = 0x00000001,
+};
+
+struct fb_context_t {
+    framebuffer_device_t  device;
+};
+
+
+static int fb_setSwapInterval(struct framebuffer_device_t* dev,
+                              int interval)
+{
+    //XXX: Get the value here and implement along with
+    //single vsync in HWC
+    char pval[PROPERTY_VALUE_MAX];
+    property_get("debug.egl.swapinterval", pval, "-1");
+    int property_interval = atoi(pval);
+    if (property_interval >= 0)
+        interval = property_interval;
+
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+        dev->common.module);
+    if (interval < dev->minSwapInterval || interval > dev->maxSwapInterval)
+        return -EINVAL;
+
+    m->swapInterval = interval;
+    return 0;
+}
+
+static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
+{
+    private_module_t* m =
+        reinterpret_cast<private_module_t*>(dev->common.module);
+    private_handle_t *hnd = static_cast<private_handle_t*>
+        (const_cast<native_handle_t*>(buffer));
+    const size_t offset = hnd->base - m->framebuffer->base;
+    m->info.activate = FB_ACTIVATE_VBL;
+    m->info.yoffset = offset / m->finfo.line_length;
+    if (ioctl(m->framebuffer->fd, FBIOPUT_VSCREENINFO, &m->info) == -1) {
+        ALOGE("%s: FBIOPUT_VSCREENINFO for primary failed, str: %s",
+                __FUNCTION__, strerror(errno));
+        return -errno;
+    }
+    return 0;
+}
+
+static int fb_compositionComplete(struct framebuffer_device_t* dev)
+{
+    // TODO: Properly implement composition complete callback
+    glFinish();
+
+    return 0;
+}
+
+int mapFrameBufferLocked(struct private_module_t* module)
+{
+    // already initialized...
+    if (module->framebuffer) {
+        return 0;
+    }
+    char const * const device_template[] = {
+        "/dev/graphics/fb%u",
+        "/dev/fb%u",
+        0 };
+
+    int fd = -1;
+    int i=0;
+    char name[64];
+    char property[PROPERTY_VALUE_MAX];
+
+    while ((fd==-1) && device_template[i]) {
+        snprintf(name, 64, device_template[i], 0);
+        fd = open(name, O_RDWR, 0);
+        i++;
+    }
+    if (fd < 0)
+        return -errno;
+
+    memset(&module->commit, 0, sizeof(struct mdp_display_commit));
+
+    struct fb_fix_screeninfo finfo;
+    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
+        return -errno;
+
+    struct fb_var_screeninfo info;
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
+        return -errno;
+
+    info.reserved[0] = 0;
+    info.reserved[1] = 0;
+    info.reserved[2] = 0;
+    info.xoffset = 0;
+    info.yoffset = 0;
+    info.activate = FB_ACTIVATE_NOW;
+
+    /* Interpretation of offset for color fields: All offsets are from the
+     * right, inside a "pixel" value, which is exactly 'bits_per_pixel' wide
+     * (means: you can use the offset as right argument to <<). A pixel
+     * afterwards is a bit stream and is written to video memory as that
+     * unmodified. This implies big-endian byte order if bits_per_pixel is
+     * greater than 8.
+     */
+
+    if(info.bits_per_pixel == 32) {
+        /*
+         * Explicitly request RGBA_8888
+         */
+        info.bits_per_pixel = 32;
+        info.red.offset     = 24;
+        info.red.length     = 8;
+        info.green.offset   = 16;
+        info.green.length   = 8;
+        info.blue.offset    = 8;
+        info.blue.length    = 8;
+        info.transp.offset  = 0;
+        info.transp.length  = 8;
+
+        /* Note: the GL driver does not have a r=8 g=8 b=8 a=0 config, so if we
+         * do not use the MDP for composition (i.e. hw composition == 0), ask
+         * for RGBA instead of RGBX. */
+        if (property_get("debug.sf.hw", property, NULL) > 0 &&
+                                                           atoi(property) == 0)
+            module->fbFormat = HAL_PIXEL_FORMAT_RGBX_8888;
+        else if(property_get("debug.composition.type", property, NULL) > 0 &&
+                (strncmp(property, "mdp", 3) == 0))
+            module->fbFormat = HAL_PIXEL_FORMAT_RGBX_8888;
+        else
+            module->fbFormat = HAL_PIXEL_FORMAT_RGBA_8888;
+    } else {
+        /*
+         * Explicitly request 5/6/5
+         */
+        info.bits_per_pixel = 16;
+        info.red.offset     = 11;
+        info.red.length     = 5;
+        info.green.offset   = 5;
+        info.green.length   = 6;
+        info.blue.offset    = 0;
+        info.blue.length    = 5;
+        info.transp.offset  = 0;
+        info.transp.length  = 0;
+        module->fbFormat = HAL_PIXEL_FORMAT_RGB_565;
+    }
+
+    //adreno needs 4k aligned offsets. Max hole size is 4096-1
+    int  size = roundUpToPageSize(info.yres * info.xres *
+                                                       (info.bits_per_pixel/8));
+
+    /*
+     * Request NUM_BUFFERS screens (at least 2 for page flipping)
+     */
+    int numberOfBuffers = (int)(finfo.smem_len/size);
+    ALOGV("num supported framebuffers in kernel = %d", numberOfBuffers);
+
+    if (property_get("debug.gr.numframebuffers", property, NULL) > 0) {
+        int num = atoi(property);
+        if ((num >= NUM_FRAMEBUFFERS_MIN) && (num <= NUM_FRAMEBUFFERS_MAX)) {
+            numberOfBuffers = num;
+        }
+    }
+    if (numberOfBuffers > NUM_FRAMEBUFFERS_MAX)
+        numberOfBuffers = NUM_FRAMEBUFFERS_MAX;
+
+    ALOGV("We support %d buffers", numberOfBuffers);
+
+    //consider the included hole by 4k alignment
+    uint32_t line_length = (info.xres * info.bits_per_pixel / 8);
+    info.yres_virtual = (size * numberOfBuffers) / line_length;
+
+    uint32_t flags = PAGE_FLIP;
+
+    if (info.yres_virtual < ((size * 2) / line_length) ) {
+        // we need at least 2 for page-flipping
+        info.yres_virtual = size / line_length;
+        flags &= ~PAGE_FLIP;
+        ALOGW("page flipping not supported (yres_virtual=%d, requested=%d)",
+              info.yres_virtual, info.yres*2);
+    }
+
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
+        return -errno;
+
+    if (int(info.width) <= 0 || int(info.height) <= 0) {
+        // the driver doesn't return that information
+        // default to 160 dpi
+        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f);
+        info.height = ((info.yres * 25.4f)/160.0f + 0.5f);
+    }
+
+    float xdpi = (info.xres * 25.4f) / info.width;
+    float ydpi = (info.yres * 25.4f) / info.height;
+#ifdef MSMFB_METADATA_GET
+    struct msmfb_metadata metadata;
+    memset(&metadata, 0 , sizeof(metadata));
+    metadata.op = metadata_op_frame_rate;
+    if (ioctl(fd, MSMFB_METADATA_GET, &metadata) == -1) {
+        ALOGE("Error retrieving panel frame rate");
+        return -errno;
+    }
+    float fps  = metadata.data.panel_frame_rate;
+#else
+    //XXX: Remove reserved field usage on all baselines
+    //The reserved[3] field is used to store FPS by the driver.
+    float fps  = info.reserved[3] & 0xFF;
+#endif
+    ALOGI("using (fd=%d)\n"
+          "id           = %s\n"
+          "xres         = %d px\n"
+          "yres         = %d px\n"
+          "xres_virtual = %d px\n"
+          "yres_virtual = %d px\n"
+          "bpp          = %d\n"
+          "r            = %2u:%u\n"
+          "g            = %2u:%u\n"
+          "b            = %2u:%u\n",
+          fd,
+          finfo.id,
+          info.xres,
+          info.yres,
+          info.xres_virtual,
+          info.yres_virtual,
+          info.bits_per_pixel,
+          info.red.offset, info.red.length,
+          info.green.offset, info.green.length,
+          info.blue.offset, info.blue.length
+         );
+
+    ALOGI("width        = %d mm (%f dpi)\n"
+          "height       = %d mm (%f dpi)\n"
+          "refresh rate = %.2f Hz\n",
+          info.width,  xdpi,
+          info.height, ydpi,
+          fps
+         );
+
+
+    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
+        return -errno;
+
+    if (finfo.smem_len <= 0)
+        return -errno;
+
+    module->flags = flags;
+    module->info = info;
+    module->finfo = finfo;
+    module->xdpi = xdpi;
+    module->ydpi = ydpi;
+    module->fps = fps;
+    module->swapInterval = 1;
+
+    CALC_INIT();
+
+    /*
+     * map the framebuffer
+     */
+
+    module->numBuffers = info.yres_virtual / info.yres;
+    module->bufferMask = 0;
+    //adreno needs page aligned offsets. Align the fbsize to pagesize.
+    size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres)*
+                    module->numBuffers;
+    module->framebuffer = new private_handle_t(fd, fbSize,
+                                        private_handle_t::PRIV_FLAGS_USES_ION,
+                                        BUFFER_TYPE_UI,
+                                        module->fbFormat, info.xres, info.yres);
+    void* vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+    if (vaddr == MAP_FAILED) {
+        ALOGE("Error mapping the framebuffer (%s)", strerror(errno));
+        return -errno;
+    }
+    module->framebuffer->base = intptr_t(vaddr);
+    memset(vaddr, 0, fbSize);
+    module->currentOffset = 0;
+    //Enable vsync
+    int enable = 1;
+    ioctl(module->framebuffer->fd, MSMFB_OVERLAY_VSYNC_CTRL,
+             &enable);
+    return 0;
+}
+
+static int mapFrameBuffer(struct private_module_t* module)
+{
+    int err = -1;
+    char property[PROPERTY_VALUE_MAX];
+    if((property_get("debug.gralloc.map_fb_memory", property, NULL) > 0) &&
+       (!strncmp(property, "1", PROPERTY_VALUE_MAX ) ||
+        (!strncasecmp(property,"true", PROPERTY_VALUE_MAX )))) {
+        pthread_mutex_lock(&module->lock);
+        err = mapFrameBufferLocked(module);
+        pthread_mutex_unlock(&module->lock);
+    }
+    return err;
+}
+
+/*****************************************************************************/
+
+static int fb_close(struct hw_device_t *dev)
+{
+    fb_context_t* ctx = (fb_context_t*)dev;
+    if (ctx) {
+        free(ctx);
+    }
+    return 0;
+}
+
+int fb_device_open(hw_module_t const* module, const char* name,
+                   hw_device_t** device)
+{
+    int status = -EINVAL;
+    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) {
+        alloc_device_t* gralloc_device;
+        status = gralloc_open(module, &gralloc_device);
+        if (status < 0)
+            return status;
+
+        /* initialize our state here */
+        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev));
+        memset(dev, 0, sizeof(*dev));
+
+        /* initialize the procs */
+        dev->device.common.tag      = HARDWARE_DEVICE_TAG;
+        dev->device.common.version  = 0;
+        dev->device.common.module   = const_cast<hw_module_t*>(module);
+        dev->device.common.close    = fb_close;
+        dev->device.setSwapInterval = fb_setSwapInterval;
+        dev->device.post            = fb_post;
+        dev->device.setUpdateRect   = 0;
+        dev->device.compositionComplete = fb_compositionComplete;
+
+        private_module_t* m = (private_module_t*)module;
+        status = mapFrameBuffer(m);
+        if (status >= 0) {
+            int stride = m->finfo.line_length / (m->info.bits_per_pixel >> 3);
+            const_cast<uint32_t&>(dev->device.flags) = 0;
+            const_cast<uint32_t&>(dev->device.width) = m->info.xres;
+            const_cast<uint32_t&>(dev->device.height) = m->info.yres;
+            const_cast<int&>(dev->device.stride) = stride;
+            const_cast<int&>(dev->device.format) = m->fbFormat;
+            const_cast<float&>(dev->device.xdpi) = m->xdpi;
+            const_cast<float&>(dev->device.ydpi) = m->ydpi;
+            const_cast<float&>(dev->device.fps) = m->fps;
+            const_cast<int&>(dev->device.minSwapInterval) =
+                                                        PRIV_MIN_SWAP_INTERVAL;
+            const_cast<int&>(dev->device.maxSwapInterval) =
+                                                        PRIV_MAX_SWAP_INTERVAL;
+            const_cast<int&>(dev->device.numFramebuffers) = m->numBuffers;
+            dev->device.setUpdateRect = 0;
+
+            *device = &dev->device.common;
+        }
+
+        // Close the gralloc module
+        gralloc_close(gralloc_device);
+    }
+    return status;
+}
diff --git a/msm8974/libgralloc/gpu.cpp b/msm8974/libgralloc/gpu.cpp
new file mode 100644
index 0000000..5e3680b
--- /dev/null
+++ b/msm8974/libgralloc/gpu.cpp
@@ -0,0 +1,401 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (c) 2011-2013 The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <limits.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <cutils/properties.h>
+#include <sys/mman.h>
+
+#include "gr.h"
+#include "gpu.h"
+#include "memalloc.h"
+#include "alloc_controller.h"
+#include <qdMetaData.h>
+
+using namespace gralloc;
+
+#define SZ_1M 0x100000
+
+gpu_context_t::gpu_context_t(const private_module_t* module,
+                             IAllocController* alloc_ctrl ) :
+    mAllocCtrl(alloc_ctrl)
+{
+    // Zero out the alloc_device_t
+    memset(static_cast<alloc_device_t*>(this), 0, sizeof(alloc_device_t));
+
+    // Initialize the procs
+    common.tag     = HARDWARE_DEVICE_TAG;
+    common.version = 0;
+    common.module  = const_cast<hw_module_t*>(&module->base.common);
+    common.close   = gralloc_close;
+    alloc          = gralloc_alloc;
+#ifdef QCOM_BSP
+    allocSize      = gralloc_alloc_size;
+#endif
+    free           = gralloc_free;
+
+}
+
+int gpu_context_t::gralloc_alloc_buffer(size_t size, int usage,
+                                        buffer_handle_t* pHandle, int bufferType,
+                                        int format, int width, int height)
+{
+    int err = 0;
+    int flags = 0;
+    size = roundUpToPageSize(size);
+    alloc_data data;
+    data.offset = 0;
+    data.fd = -1;
+    data.base = 0;
+    if(format == HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED)
+        data.align = 8192;
+    else
+        data.align = getpagesize();
+
+    /* force 1MB alignment selectively for secure buffers, MDP5 onwards */
+#ifdef MDSS_TARGET
+    if (usage & GRALLOC_USAGE_PROTECTED) {
+        data.align = ALIGN(data.align, SZ_1M);
+        size = ALIGN(size, data.align);
+    }
+#endif
+
+    data.size = size;
+    data.pHandle = (unsigned int) pHandle;
+    err = mAllocCtrl->allocate(data, usage);
+
+    if (!err) {
+        /* allocate memory for enhancement data */
+        alloc_data eData;
+        eData.fd = -1;
+        eData.base = 0;
+        eData.offset = 0;
+        eData.size = ROUND_UP_PAGESIZE(sizeof(MetaData_t));
+        eData.pHandle = data.pHandle;
+        eData.align = getpagesize();
+        int eDataUsage = GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP;
+        int eDataErr = mAllocCtrl->allocate(eData, eDataUsage);
+        ALOGE_IF(eDataErr, "gralloc failed for eDataErr=%s",
+                                          strerror(-eDataErr));
+
+        if (usage & GRALLOC_USAGE_PRIVATE_EXTERNAL_ONLY) {
+            flags |= private_handle_t::PRIV_FLAGS_EXTERNAL_ONLY;
+            //The EXTERNAL_BLOCK flag is always an add-on
+            if (usage & GRALLOC_USAGE_PRIVATE_EXTERNAL_BLOCK) {
+                flags |= private_handle_t::PRIV_FLAGS_EXTERNAL_BLOCK;
+            }
+            if (usage & GRALLOC_USAGE_PRIVATE_EXTERNAL_CC) {
+                flags |= private_handle_t::PRIV_FLAGS_EXTERNAL_CC;
+            }
+        }
+
+        if (bufferType == BUFFER_TYPE_VIDEO) {
+            if (usage & GRALLOC_USAGE_HW_CAMERA_WRITE) {
+#ifndef MDSS_TARGET
+                flags |= private_handle_t::PRIV_FLAGS_ITU_R_601_FR;
+#else
+                // Per the camera spec ITU 709 format should be set only for
+                // video encoding.
+                // It should be set to ITU 601 full range format for any other
+                // camera buffer
+                //
+                if (usage & GRALLOC_USAGE_HW_CAMERA_MASK) {
+                    if (usage & GRALLOC_USAGE_HW_VIDEO_ENCODER)
+                        flags |= private_handle_t::PRIV_FLAGS_ITU_R_709;
+                    else
+                        flags |= private_handle_t::PRIV_FLAGS_ITU_R_601_FR;
+                }
+#endif
+            } else {
+                flags |= private_handle_t::PRIV_FLAGS_ITU_R_601;
+            }
+        }
+
+        if (usage & GRALLOC_USAGE_HW_VIDEO_ENCODER ) {
+            flags |= private_handle_t::PRIV_FLAGS_VIDEO_ENCODER;
+        }
+
+        if (usage & GRALLOC_USAGE_HW_CAMERA_WRITE) {
+            flags |= private_handle_t::PRIV_FLAGS_CAMERA_WRITE;
+        }
+
+        if (usage & GRALLOC_USAGE_HW_CAMERA_READ) {
+            flags |= private_handle_t::PRIV_FLAGS_CAMERA_READ;
+        }
+
+        if (usage & GRALLOC_USAGE_HW_COMPOSER) {
+            flags |= private_handle_t::PRIV_FLAGS_HW_COMPOSER;
+        }
+
+        if (usage & GRALLOC_USAGE_HW_TEXTURE) {
+            flags |= private_handle_t::PRIV_FLAGS_HW_TEXTURE;
+        }
+
+        flags |= data.allocType;
+        int eBaseAddr = int(eData.base) + eData.offset;
+        private_handle_t *hnd = new private_handle_t(data.fd, size, flags,
+                bufferType, format, width, height, eData.fd, eData.offset,
+                eBaseAddr);
+
+        hnd->offset = data.offset;
+        hnd->base = int(data.base) + data.offset;
+        hnd->gpuaddr = 0;
+
+        *pHandle = hnd;
+    }
+
+    ALOGE_IF(err, "gralloc failed err=%s", strerror(-err));
+
+    return err;
+}
+
+void gpu_context_t::getGrallocInformationFromFormat(int inputFormat,
+                                                    int *bufferType)
+{
+    *bufferType = BUFFER_TYPE_VIDEO;
+
+    if (inputFormat <= HAL_PIXEL_FORMAT_BGRA_8888) {
+        // RGB formats
+        *bufferType = BUFFER_TYPE_UI;
+    } else if ((inputFormat == HAL_PIXEL_FORMAT_R_8) ||
+               (inputFormat == HAL_PIXEL_FORMAT_RG_88)) {
+        *bufferType = BUFFER_TYPE_UI;
+    }
+}
+
+int gpu_context_t::gralloc_alloc_framebuffer_locked(size_t size, int usage,
+                                                    buffer_handle_t* pHandle)
+{
+    private_module_t* m = reinterpret_cast<private_module_t*>(common.module);
+
+    // we don't support framebuffer allocations with graphics heap flags
+    if (usage & GRALLOC_HEAP_MASK) {
+        return -EINVAL;
+    }
+
+    if (m->framebuffer == NULL) {
+        ALOGE("%s: Invalid framebuffer", __FUNCTION__);
+        return -EINVAL;
+    }
+
+    const uint32_t bufferMask = m->bufferMask;
+    const uint32_t numBuffers = m->numBuffers;
+    size_t bufferSize = m->finfo.line_length * m->info.yres;
+
+    //adreno needs FB size to be page aligned
+    bufferSize = roundUpToPageSize(bufferSize);
+
+    if (numBuffers == 1) {
+        // If we have only one buffer, we never use page-flipping. Instead,
+        // we return a regular buffer which will be memcpy'ed to the main
+        // screen when post is called.
+        int newUsage = (usage & ~GRALLOC_USAGE_HW_FB) | GRALLOC_USAGE_HW_2D;
+        return gralloc_alloc_buffer(bufferSize, newUsage, pHandle, BUFFER_TYPE_UI,
+                                    m->fbFormat, m->info.xres, m->info.yres);
+    }
+
+    if (bufferMask >= ((1LU<<numBuffers)-1)) {
+        // We ran out of buffers.
+        return -ENOMEM;
+    }
+
+    // create a "fake" handle for it
+    intptr_t vaddr = intptr_t(m->framebuffer->base);
+    private_handle_t* hnd = new private_handle_t(
+        dup(m->framebuffer->fd), bufferSize,
+        private_handle_t::PRIV_FLAGS_USES_PMEM |
+        private_handle_t::PRIV_FLAGS_FRAMEBUFFER,
+        BUFFER_TYPE_UI, m->fbFormat, m->info.xres,
+        m->info.yres);
+
+    // find a free slot
+    for (uint32_t i=0 ; i<numBuffers ; i++) {
+        if ((bufferMask & (1LU<<i)) == 0) {
+            m->bufferMask |= (1LU<<i);
+            break;
+        }
+        vaddr += bufferSize;
+    }
+    hnd->base = vaddr;
+    hnd->offset = vaddr - intptr_t(m->framebuffer->base);
+    *pHandle = hnd;
+    return 0;
+}
+
+
+int gpu_context_t::gralloc_alloc_framebuffer(size_t size, int usage,
+                                             buffer_handle_t* pHandle)
+{
+    private_module_t* m = reinterpret_cast<private_module_t*>(common.module);
+    pthread_mutex_lock(&m->lock);
+    int err = gralloc_alloc_framebuffer_locked(size, usage, pHandle);
+    pthread_mutex_unlock(&m->lock);
+    return err;
+}
+
+int gpu_context_t::alloc_impl(int w, int h, int format, int usage,
+                              buffer_handle_t* pHandle, int* pStride,
+                              size_t bufferSize) {
+    if (!pHandle || !pStride)
+        return -EINVAL;
+
+    size_t size;
+    int alignedw, alignedh;
+    int grallocFormat = format;
+    int bufferType;
+
+    //If input format is HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED then based on
+    //the usage bits, gralloc assigns a format.
+    if(format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED ||
+       format == HAL_PIXEL_FORMAT_YCbCr_420_888) {
+        if(usage & GRALLOC_USAGE_HW_VIDEO_ENCODER)
+            grallocFormat = HAL_PIXEL_FORMAT_NV12_ENCODEABLE; //NV12
+        else if((usage & GRALLOC_USAGE_HW_CAMERA_MASK)
+                == GRALLOC_USAGE_HW_CAMERA_ZSL)
+            grallocFormat = HAL_PIXEL_FORMAT_NV21_ZSL; //NV21 ZSL
+        else if(usage & GRALLOC_USAGE_HW_CAMERA_READ)
+            grallocFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP; //NV21
+        else if(usage & GRALLOC_USAGE_HW_CAMERA_WRITE)
+            grallocFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP; //NV21
+        //If flexible yuv is used for sw read/write, need map to NV21
+        else if(format == HAL_PIXEL_FORMAT_YCbCr_420_888 &&
+            (usage & GRALLOC_USAGE_SW_WRITE_MASK ||
+            usage & GRALLOC_USAGE_SW_READ_MASK)) {
+            grallocFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP;
+        }
+
+    }
+
+    if (grallocFormat == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED &&
+            (usage & GRALLOC_USAGE_HW_COMPOSER )) {
+        //XXX: If we still haven't set a format, default to RGBA8888
+        grallocFormat = HAL_PIXEL_FORMAT_RGBA_8888;
+    }
+
+    getGrallocInformationFromFormat(grallocFormat, &bufferType);
+    size = getBufferSizeAndDimensions(w, h, grallocFormat, alignedw, alignedh);
+
+    if ((ssize_t)size <= 0)
+        return -EINVAL;
+    size = (bufferSize >= size)? bufferSize : size;
+
+    // All buffers marked as protected or for external
+    // display need to go to overlay
+    if ((usage & GRALLOC_USAGE_EXTERNAL_DISP) ||
+        (usage & GRALLOC_USAGE_PROTECTED)) {
+        bufferType = BUFFER_TYPE_VIDEO;
+    }
+
+    bool useFbMem = false;
+    char property[PROPERTY_VALUE_MAX];
+    if((usage & GRALLOC_USAGE_HW_FB) &&
+       (property_get("debug.gralloc.map_fb_memory", property, NULL) > 0) &&
+       (!strncmp(property, "1", PROPERTY_VALUE_MAX ) ||
+        (!strncasecmp(property,"true", PROPERTY_VALUE_MAX )))) {
+        useFbMem = true;
+    }
+
+    int err = 0;
+    if(useFbMem) {
+        err = gralloc_alloc_framebuffer(size, usage, pHandle);
+    } else {
+        err = gralloc_alloc_buffer(size, usage, pHandle, bufferType,
+                                   grallocFormat, alignedw, alignedh);
+    }
+
+    if (err < 0) {
+        return err;
+    }
+
+    *pStride = alignedw;
+    return 0;
+}
+
+int gpu_context_t::free_impl(private_handle_t const* hnd) {
+    private_module_t* m = reinterpret_cast<private_module_t*>(common.module);
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
+        const size_t bufferSize = m->finfo.line_length * m->info.yres;
+        int index = (hnd->base - m->framebuffer->base) / bufferSize;
+        m->bufferMask &= ~(1<<index);
+    } else {
+
+        terminateBuffer(&m->base, const_cast<private_handle_t*>(hnd));
+        IMemAlloc* memalloc = mAllocCtrl->getAllocator(hnd->flags);
+        int err = memalloc->free_buffer((void*)hnd->base, (size_t) hnd->size,
+                                        hnd->offset, hnd->fd);
+        if(err)
+            return err;
+        // free the metadata space
+        unsigned long size = ROUND_UP_PAGESIZE(sizeof(MetaData_t));
+        err = memalloc->free_buffer((void*)hnd->base_metadata,
+                                    (size_t) size, hnd->offset_metadata,
+                                    hnd->fd_metadata);
+        if (err)
+            return err;
+    }
+    delete hnd;
+    return 0;
+}
+
+int gpu_context_t::gralloc_alloc(alloc_device_t* dev, int w, int h, int format,
+                                 int usage, buffer_handle_t* pHandle,
+                                 int* pStride)
+{
+    if (!dev) {
+        return -EINVAL;
+    }
+    gpu_context_t* gpu = reinterpret_cast<gpu_context_t*>(dev);
+    return gpu->alloc_impl(w, h, format, usage, pHandle, pStride, 0);
+}
+int gpu_context_t::gralloc_alloc_size(alloc_device_t* dev, int w, int h,
+                                      int format, int usage,
+                                      buffer_handle_t* pHandle, int* pStride,
+                                      int bufferSize)
+{
+    if (!dev) {
+        return -EINVAL;
+    }
+    gpu_context_t* gpu = reinterpret_cast<gpu_context_t*>(dev);
+    return gpu->alloc_impl(w, h, format, usage, pHandle, pStride, bufferSize);
+}
+
+
+int gpu_context_t::gralloc_free(alloc_device_t* dev,
+                                buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(handle);
+    gpu_context_t* gpu = reinterpret_cast<gpu_context_t*>(dev);
+    return gpu->free_impl(hnd);
+}
+
+/*****************************************************************************/
+
+int gpu_context_t::gralloc_close(struct hw_device_t *dev)
+{
+    gpu_context_t* ctx = reinterpret_cast<gpu_context_t*>(dev);
+    if (ctx) {
+        /* TODO: keep a list of all buffer_handle_t created, and free them
+         * all here.
+         */
+        delete ctx;
+    }
+    return 0;
+}
diff --git a/msm8974/libgralloc/gpu.h b/msm8974/libgralloc/gpu.h
new file mode 100644
index 0000000..b391f74
--- /dev/null
+++ b/msm8974/libgralloc/gpu.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GRALLOC_GPU_H_
+#define GRALLOC_GPU_H_
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <cutils/log.h>
+#include <cutils/ashmem.h>
+
+#include "gralloc_priv.h"
+#include "fb_priv.h"
+
+namespace gralloc {
+class IAllocController;
+class gpu_context_t : public alloc_device_t {
+    public:
+    gpu_context_t(const private_module_t* module,
+                  IAllocController* alloc_ctrl);
+
+    int gralloc_alloc_buffer(size_t size, int usage,
+                             buffer_handle_t* pHandle,
+                             int bufferType, int format,
+                             int width, int height);
+
+    int free_impl(private_handle_t const* hnd);
+
+    int alloc_impl(int w, int h, int format, int usage,
+                   buffer_handle_t* pHandle, int* pStride,
+                   size_t bufferSize = 0);
+
+    static int gralloc_alloc(alloc_device_t* dev, int w, int h,
+                             int format, int usage,
+                             buffer_handle_t* pHandle,
+                             int* pStride);
+    int gralloc_alloc_framebuffer_locked(size_t size, int usage,
+                                         buffer_handle_t* pHandle);
+
+    int gralloc_alloc_framebuffer(size_t size, int usage,
+                                  buffer_handle_t* pHandle);
+
+    static int gralloc_free(alloc_device_t* dev, buffer_handle_t handle);
+
+    static int gralloc_alloc_size(alloc_device_t* dev,
+                                  int w, int h, int format,
+                                  int usage, buffer_handle_t* pHandle,
+                                  int* pStride, int bufferSize);
+
+    static int gralloc_close(struct hw_device_t *dev);
+
+    private:
+   IAllocController* mAllocCtrl;
+    void getGrallocInformationFromFormat(int inputFormat,
+                                         int *bufferType);
+};
+}
+#endif  // GRALLOC_GPU_H
diff --git a/msm8974/libgralloc/gr.h b/msm8974/libgralloc/gr.h
new file mode 100644
index 0000000..359b8db
--- /dev/null
+++ b/msm8974/libgralloc/gr.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GR_H_
+#define GR_H_
+
+#include <stdint.h>
+#include <sys/user.h>
+#include <limits.h>
+#include <sys/cdefs.h>
+#include <hardware/gralloc.h>
+#include <pthread.h>
+#include <errno.h>
+
+#include <cutils/native_handle.h>
+#include <utils/Singleton.h>
+
+/*****************************************************************************/
+
+struct private_module_t;
+struct private_handle_t;
+
+inline size_t roundUpToPageSize(size_t x) {
+    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+}
+
+inline size_t ALIGN(size_t x, size_t align) {
+    return (x + align-1) & ~(align-1);
+}
+
+#define FALSE 0
+#define TRUE  1
+
+int mapFrameBufferLocked(struct private_module_t* module);
+int terminateBuffer(gralloc_module_t const* module, private_handle_t* hnd);
+size_t getBufferSizeAndDimensions(int width, int height, int format,
+                                  int& alignedw, int &alignedh);
+
+int decideBufferHandlingMechanism(int format, const char *compositionUsed,
+                                  int hasBlitEngine, int *needConversion,
+                                  int *useBufferDirectly);
+
+// Allocate buffer from width, height, format into a private_handle_t
+// It is the responsibility of the caller to free the buffer
+int alloc_buffer(private_handle_t **pHnd, int w, int h, int format, int usage);
+void free_buffer(private_handle_t *hnd);
+
+/*****************************************************************************/
+
+class Locker {
+    pthread_mutex_t mutex;
+    public:
+    class Autolock {
+        Locker& locker;
+        public:
+        inline Autolock(Locker& locker) : locker(locker) {  locker.lock(); }
+        inline ~Autolock() { locker.unlock(); }
+    };
+    inline Locker()        { pthread_mutex_init(&mutex, 0); }
+    inline ~Locker()       { pthread_mutex_destroy(&mutex); }
+    inline void lock()     { pthread_mutex_lock(&mutex); }
+    inline void unlock()   { pthread_mutex_unlock(&mutex); }
+};
+
+
+class AdrenoMemInfo : public android::Singleton <AdrenoMemInfo>
+{
+    public:
+    AdrenoMemInfo();
+
+    ~AdrenoMemInfo();
+
+    /*
+     * Function to compute the adreno stride based on the width and format.
+     *
+     * @return stride.
+     */
+    int getStride(int width, int format);
+
+    private:
+        // Pointer to the padding library.
+        void *libadreno_utils;
+
+        // link to the surface padding library.
+        int (*LINK_adreno_compute_padding) (int width, int bpp,
+                                                int surface_tile_height,
+                                                int screen_tile_height,
+                                                int padding_threshold);
+};
+#endif /* GR_H_ */
diff --git a/msm8974/libgralloc/gralloc.cpp b/msm8974/libgralloc/gralloc.cpp
new file mode 100644
index 0000000..038c7e0
--- /dev/null
+++ b/msm8974/libgralloc/gralloc.cpp
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2008, The Android Open Source Project
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <cutils/properties.h>
+
+#include "gr.h"
+#include "gpu.h"
+#include "memalloc.h"
+#include "alloc_controller.h"
+
+using namespace gralloc;
+
+int fb_device_open(const hw_module_t* module, const char* name,
+                   hw_device_t** device);
+
+static int gralloc_device_open(const hw_module_t* module, const char* name,
+                               hw_device_t** device);
+
+extern int gralloc_lock(gralloc_module_t const* module,
+                        buffer_handle_t handle, int usage,
+                        int l, int t, int w, int h,
+                        void** vaddr);
+
+extern int gralloc_lock_ycbcr(gralloc_module_t const* module,
+                        buffer_handle_t handle, int usage,
+                        int l, int t, int w, int h,
+                        struct android_ycbcr *ycbcr);
+
+extern int gralloc_unlock(gralloc_module_t const* module,
+                          buffer_handle_t handle);
+
+extern int gralloc_register_buffer(gralloc_module_t const* module,
+                                   buffer_handle_t handle);
+
+extern int gralloc_unregister_buffer(gralloc_module_t const* module,
+                                     buffer_handle_t handle);
+
+extern int gralloc_perform(struct gralloc_module_t const* module,
+                           int operation, ... );
+
+// HAL module methods
+static struct hw_module_methods_t gralloc_module_methods = {
+    open: gralloc_device_open
+};
+
+// HAL module initialize
+struct private_module_t HAL_MODULE_INFO_SYM = {
+    base: {
+        common: {
+            tag: HARDWARE_MODULE_TAG,
+            module_api_version: GRALLOC_MODULE_API_VERSION_0_2,
+            hal_api_version: 0,
+            id: GRALLOC_HARDWARE_MODULE_ID,
+            name: "Graphics Memory Allocator Module",
+            author: "The Android Open Source Project",
+            methods: &gralloc_module_methods,
+            dso: 0,
+        },
+        registerBuffer: gralloc_register_buffer,
+        unregisterBuffer: gralloc_unregister_buffer,
+        lock: gralloc_lock,
+        unlock: gralloc_unlock,
+        perform: gralloc_perform,
+        lock_ycbcr: gralloc_lock_ycbcr,
+    },
+    framebuffer: 0,
+    fbFormat: 0,
+    flags: 0,
+    numBuffers: 0,
+    bufferMask: 0,
+    lock: PTHREAD_MUTEX_INITIALIZER,
+    currentBuffer: 0,
+};
+
+// Open Gralloc device
+int gralloc_device_open(const hw_module_t* module, const char* name,
+                        hw_device_t** device)
+{
+    int status = -EINVAL;
+    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) {
+        const private_module_t* m = reinterpret_cast<const private_module_t*>(
+            module);
+        gpu_context_t *dev;
+        IAllocController* alloc_ctrl = IAllocController::getInstance();
+        dev = new gpu_context_t(m, alloc_ctrl);
+        *device = &dev->common;
+        status = 0;
+    } else {
+        status = fb_device_open(module, name, device);
+    }
+    return status;
+}
diff --git a/msm8974/libgralloc/gralloc_priv.h b/msm8974/libgralloc/gralloc_priv.h
new file mode 100644
index 0000000..94d4334
--- /dev/null
+++ b/msm8974/libgralloc/gralloc_priv.h
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef GRALLOC_PRIV_H_
+#define GRALLOC_PRIV_H_
+
+#include <stdint.h>
+#include <limits.h>
+#include <sys/cdefs.h>
+#include <hardware/gralloc.h>
+#include <pthread.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <cutils/native_handle.h>
+
+#include <cutils/log.h>
+
+#define ROUND_UP_PAGESIZE(x) ( (((unsigned long)(x)) + PAGE_SIZE-1)  & \
+                               (~(PAGE_SIZE-1)) )
+
+enum {
+    /* gralloc usage bits indicating the type
+     * of allocation that should be used */
+
+    /* SYSTEM heap comes from kernel vmalloc,
+     * can never be uncached, is not secured*/
+    GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP     =       GRALLOC_USAGE_PRIVATE_0,
+    /* SF heap is used for application buffers, is not secured */
+    GRALLOC_USAGE_PRIVATE_UI_CONTIG_HEAP  =       GRALLOC_USAGE_PRIVATE_1,
+    /* IOMMU heap comes from manually allocated pages,
+     * can be cached/uncached, is not secured */
+    GRALLOC_USAGE_PRIVATE_IOMMU_HEAP      =       GRALLOC_USAGE_PRIVATE_2,
+    /* MM heap is a carveout heap for video, can be secured*/
+    GRALLOC_USAGE_PRIVATE_MM_HEAP         =       GRALLOC_USAGE_PRIVATE_3,
+    /* ADSP heap is a carveout heap, is not secured*/
+    GRALLOC_USAGE_PRIVATE_ADSP_HEAP       =       0x01000000,
+
+    /* Set this for allocating uncached memory (using O_DSYNC)
+     * cannot be used with noncontiguous heaps */
+    GRALLOC_USAGE_PRIVATE_UNCACHED        =       0x02000000,
+
+    /* Buffer content should be displayed on an external display only */
+    GRALLOC_USAGE_PRIVATE_EXTERNAL_ONLY   =       0x08000000,
+
+    /* Only this buffer content should be displayed on external, even if
+     * other EXTERNAL_ONLY buffers are available. Used during suspend.
+     */
+    GRALLOC_USAGE_PRIVATE_EXTERNAL_BLOCK  =       0x00100000,
+
+    /* Close Caption displayed on an external display only */
+    GRALLOC_USAGE_PRIVATE_EXTERNAL_CC     =       0x00200000,
+
+    /* CAMERA heap is a carveout heap for camera, is not secured*/
+    GRALLOC_USAGE_PRIVATE_CAMERA_HEAP     =       0x00400000,
+};
+
+enum {
+    /* Gralloc perform enums
+    */
+    GRALLOC_MODULE_PERFORM_CREATE_HANDLE_FROM_BUFFER = 1,
+    GRALLOC_MODULE_PERFORM_GET_STRIDE,
+    GRALLOC_MODULE_PERFORM_GET_CUSTOM_STRIDE_FROM_HANDLE,
+};
+
+#define GRALLOC_HEAP_MASK   (GRALLOC_USAGE_PRIVATE_UI_CONTIG_HEAP |\
+                             GRALLOC_USAGE_PRIVATE_SYSTEM_HEAP    |\
+                             GRALLOC_USAGE_PRIVATE_IOMMU_HEAP     |\
+                             GRALLOC_USAGE_PRIVATE_MM_HEAP        |\
+                             GRALLOC_USAGE_PRIVATE_ADSP_HEAP)
+
+#define INTERLACE_MASK 0x80
+#define S3D_FORMAT_MASK 0xFF000
+/*****************************************************************************/
+enum {
+    /* OEM specific HAL formats */
+    HAL_PIXEL_FORMAT_NV12_ENCODEABLE        = 0x102,
+    HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS     = 0x7FA30C04,
+    HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED     = 0x7FA30C03,
+    HAL_PIXEL_FORMAT_YCbCr_420_SP           = 0x109,
+    HAL_PIXEL_FORMAT_YCrCb_420_SP_ADRENO    = 0x7FA30C01,
+    HAL_PIXEL_FORMAT_YCrCb_422_SP           = 0x10B,
+    HAL_PIXEL_FORMAT_R_8                    = 0x10D,
+    HAL_PIXEL_FORMAT_RG_88                  = 0x10E,
+    HAL_PIXEL_FORMAT_YCbCr_444_SP           = 0x10F,
+    HAL_PIXEL_FORMAT_YCrCb_444_SP           = 0x110,
+    HAL_PIXEL_FORMAT_NV21_ZSL               = 0x111,
+    HAL_PIXEL_FORMAT_INTERLACE              = 0x180,
+
+};
+
+/* possible formats for 3D content*/
+enum {
+    HAL_NO_3D                         = 0x0000,
+    HAL_3D_IN_SIDE_BY_SIDE_L_R        = 0x10000,
+    HAL_3D_IN_TOP_BOTTOM              = 0x20000,
+    HAL_3D_IN_INTERLEAVE              = 0x40000,
+    HAL_3D_IN_SIDE_BY_SIDE_R_L        = 0x80000,
+    HAL_3D_OUT_SIDE_BY_SIDE           = 0x1000,
+    HAL_3D_OUT_TOP_BOTTOM             = 0x2000,
+    HAL_3D_OUT_INTERLEAVE             = 0x4000,
+    HAL_3D_OUT_MONOSCOPIC             = 0x8000
+};
+
+enum {
+    BUFFER_TYPE_UI = 0,
+    BUFFER_TYPE_VIDEO
+};
+
+/*****************************************************************************/
+
+#ifdef __cplusplus
+struct private_handle_t : public native_handle {
+#else
+    struct private_handle_t {
+        native_handle_t nativeHandle;
+#endif
+        enum {
+            PRIV_FLAGS_FRAMEBUFFER        = 0x00000001,
+            PRIV_FLAGS_USES_PMEM          = 0x00000002,
+            PRIV_FLAGS_USES_PMEM_ADSP     = 0x00000004,
+            PRIV_FLAGS_USES_ION           = 0x00000008,
+            PRIV_FLAGS_USES_ASHMEM        = 0x00000010,
+            PRIV_FLAGS_NEEDS_FLUSH        = 0x00000020,
+            PRIV_FLAGS_DO_NOT_FLUSH       = 0x00000040,
+            PRIV_FLAGS_SW_LOCK            = 0x00000080,
+            PRIV_FLAGS_NONCONTIGUOUS_MEM  = 0x00000100,
+            // Set by HWC when storing the handle
+            PRIV_FLAGS_HWC_LOCK           = 0x00000200,
+            PRIV_FLAGS_SECURE_BUFFER      = 0x00000400,
+            // For explicit synchronization
+            PRIV_FLAGS_UNSYNCHRONIZED     = 0x00000800,
+            // Not mapped in userspace
+            PRIV_FLAGS_NOT_MAPPED         = 0x00001000,
+            // Display on external only
+            PRIV_FLAGS_EXTERNAL_ONLY      = 0x00002000,
+            // Display only this buffer on external
+            PRIV_FLAGS_EXTERNAL_BLOCK     = 0x00004000,
+            // Display this buffer on external as close caption
+            PRIV_FLAGS_EXTERNAL_CC        = 0x00008000,
+            PRIV_FLAGS_VIDEO_ENCODER      = 0x00010000,
+            PRIV_FLAGS_CAMERA_WRITE       = 0x00020000,
+            PRIV_FLAGS_CAMERA_READ        = 0x00040000,
+            PRIV_FLAGS_HW_COMPOSER        = 0x00080000,
+            PRIV_FLAGS_HW_TEXTURE         = 0x00100000,
+            PRIV_FLAGS_ITU_R_601          = 0x00200000,
+            PRIV_FLAGS_ITU_R_601_FR       = 0x00400000,
+            PRIV_FLAGS_ITU_R_709          = 0x00800000,
+            PRIV_FLAGS_L3_SECURE_BUFFER   = 0x01000000,
+        };
+
+        // file-descriptors
+        int     fd;
+        int     fd_metadata;          // fd for the meta-data
+        // ints
+        int     magic;
+        int     flags;
+        int     size;
+        int     offset;
+        int     bufferType;
+        int     base;
+        int     offset_metadata;
+        // The gpu address mapped into the mmu.
+        int     gpuaddr;
+        int     format;
+        int     width;
+        int     height;
+        int     base_metadata;
+
+#ifdef __cplusplus
+        static const int sNumInts = 12;
+        static const int sNumFds = 2;
+        static const int sMagic = 'gmsm';
+
+        private_handle_t(int fd, int size, int flags, int bufferType,
+                         int format,int width, int height, int eFd = -1,
+                         int eOffset = 0, int eBase = 0) :
+            fd(fd), fd_metadata(eFd), magic(sMagic),
+            flags(flags), size(size), offset(0), bufferType(bufferType),
+            base(0), offset_metadata(eOffset), gpuaddr(0),
+            format(format), width(width), height(height),
+            base_metadata(eBase)
+        {
+            version = sizeof(native_handle);
+            numInts = sNumInts;
+            numFds = sNumFds;
+        }
+        ~private_handle_t() {
+            magic = 0;
+        }
+
+        bool usesPhysicallyContiguousMemory() {
+            return (flags & PRIV_FLAGS_USES_PMEM) != 0;
+        }
+
+        static int validate(const native_handle* h) {
+            const private_handle_t* hnd = (const private_handle_t*)h;
+            if (!h || h->version != sizeof(native_handle) ||
+                h->numInts != sNumInts || h->numFds != sNumFds ||
+                hnd->magic != sMagic)
+            {
+                ALOGD("Invalid gralloc handle (at %p): "
+                      "ver(%d/%d) ints(%d/%d) fds(%d/%d) magic(%c%c%c%c/%c%c%c%c)",
+                      h,
+                      h ? h->version : -1, sizeof(native_handle),
+                      h ? h->numInts : -1, sNumInts,
+                      h ? h->numFds : -1, sNumFds,
+                      hnd ? (((hnd->magic >> 24) & 0xFF)?
+                             ((hnd->magic >> 24) & 0xFF) : '-') : '?',
+                      hnd ? (((hnd->magic >> 16) & 0xFF)?
+                             ((hnd->magic >> 16) & 0xFF) : '-') : '?',
+                      hnd ? (((hnd->magic >> 8) & 0xFF)?
+                             ((hnd->magic >> 8) & 0xFF) : '-') : '?',
+                      hnd ? (((hnd->magic >> 0) & 0xFF)?
+                             ((hnd->magic >> 0) & 0xFF) : '-') : '?',
+                      (sMagic >> 24) & 0xFF,
+                      (sMagic >> 16) & 0xFF,
+                      (sMagic >> 8) & 0xFF,
+                      (sMagic >> 0) & 0xFF);
+                return -EINVAL;
+            }
+            return 0;
+        }
+
+        static private_handle_t* dynamicCast(const native_handle* in) {
+            if (validate(in) == 0) {
+                return (private_handle_t*) in;
+            }
+            return NULL;
+        }
+#endif
+    };
+
+#endif /* GRALLOC_PRIV_H_ */
diff --git a/msm8974/libgralloc/ionalloc.cpp b/msm8974/libgralloc/ionalloc.cpp
new file mode 100644
index 0000000..144d457
--- /dev/null
+++ b/msm8974/libgralloc/ionalloc.cpp
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define DEBUG 0
+#include <linux/ioctl.h>
+#include <sys/mman.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <cutils/log.h>
+#include <errno.h>
+#include "gralloc_priv.h"
+#include "ionalloc.h"
+
+using gralloc::IonAlloc;
+
+#define ION_DEVICE "/dev/ion"
+
+int IonAlloc::open_device()
+{
+    if(mIonFd == FD_INIT)
+        mIonFd = open(ION_DEVICE, O_RDONLY);
+
+    if(mIonFd < 0 ) {
+        ALOGE("%s: Failed to open ion device - %s",
+              __FUNCTION__, strerror(errno));
+        mIonFd = FD_INIT;
+        return -errno;
+    }
+    return 0;
+}
+
+void IonAlloc::close_device()
+{
+    if(mIonFd >= 0)
+        close(mIonFd);
+    mIonFd = FD_INIT;
+}
+
+int IonAlloc::alloc_buffer(alloc_data& data)
+{
+    Locker::Autolock _l(mLock);
+    int err = 0;
+    struct ion_handle_data handle_data;
+    struct ion_fd_data fd_data;
+    struct ion_allocation_data ionAllocData;
+    void *base = 0;
+
+    ionAllocData.len = data.size;
+    ionAllocData.align = data.align;
+    ionAllocData.heap_id_mask = data.flags & ~ION_SECURE;
+    ionAllocData.flags = data.uncached ? 0 : ION_FLAG_CACHED;
+    // ToDo: replace usage of alloc data structure with
+    //  ionallocdata structure.
+    if (data.flags & ION_SECURE)
+        ionAllocData.flags |= ION_SECURE;
+
+    // ToDo: replace usage of alloc data structure with
+    //  ionallocdata structure.
+    if (data.flags & ION_SECURE)
+        ionAllocData.flags |= ION_SECURE;
+
+    err = open_device();
+    if (err)
+        return err;
+    if(ioctl(mIonFd, ION_IOC_ALLOC, &ionAllocData)) {
+        err = -errno;
+        ALOGE("ION_IOC_ALLOC failed with error - %s", strerror(errno));
+        return err;
+    }
+
+    fd_data.handle = ionAllocData.handle;
+    handle_data.handle = ionAllocData.handle;
+    if(ioctl(mIonFd, ION_IOC_MAP, &fd_data)) {
+        err = -errno;
+        ALOGE("%s: ION_IOC_MAP failed with error - %s",
+              __FUNCTION__, strerror(errno));
+        ioctl(mIonFd, ION_IOC_FREE, &handle_data);
+        return err;
+    }
+
+    if(!(data.flags & ION_SECURE)) {
+        base = mmap(0, ionAllocData.len, PROT_READ|PROT_WRITE,
+                    MAP_SHARED, fd_data.fd, 0);
+        if(base == MAP_FAILED) {
+            err = -errno;
+            ALOGE("%s: Failed to map the allocated memory: %s",
+                  __FUNCTION__, strerror(errno));
+            ioctl(mIonFd, ION_IOC_FREE, &handle_data);
+            return err;
+        }
+    }
+
+    data.base = base;
+    data.fd = fd_data.fd;
+    ioctl(mIonFd, ION_IOC_FREE, &handle_data);
+    ALOGD_IF(DEBUG, "ion: Allocated buffer base:%p size:%d fd:%d",
+          data.base, ionAllocData.len, data.fd);
+    return 0;
+}
+
+
+int IonAlloc::free_buffer(void* base, size_t size, int offset, int fd)
+{
+    Locker::Autolock _l(mLock);
+    ALOGD_IF(DEBUG, "ion: Freeing buffer base:%p size:%d fd:%d",
+          base, size, fd);
+    int err = 0;
+    err = open_device();
+    if (err)
+        return err;
+
+    if(base)
+        err = unmap_buffer(base, size, offset);
+    close(fd);
+    return err;
+}
+
+int IonAlloc::map_buffer(void **pBase, size_t size, int offset, int fd)
+{
+    int err = 0;
+    void *base = 0;
+    // It is a (quirky) requirement of ION to have opened the
+    // ion fd in the process that is doing the mapping
+    err = open_device();
+    if (err)
+        return err;
+
+    base = mmap(0, size, PROT_READ| PROT_WRITE,
+                MAP_SHARED, fd, 0);
+    *pBase = base;
+    if(base == MAP_FAILED) {
+        err = -errno;
+        ALOGE("ion: Failed to map memory in the client: %s",
+              strerror(errno));
+    } else {
+        ALOGD_IF(DEBUG, "ion: Mapped buffer base:%p size:%d offset:%d fd:%d",
+              base, size, offset, fd);
+    }
+    return err;
+}
+
+int IonAlloc::unmap_buffer(void *base, size_t size, int offset)
+{
+    ALOGD_IF(DEBUG, "ion: Unmapping buffer  base:%p size:%d", base, size);
+    int err = 0;
+    if(munmap(base, size)) {
+        err = -errno;
+        ALOGE("ion: Failed to unmap memory at %p : %s",
+              base, strerror(errno));
+    }
+    return err;
+
+}
+int IonAlloc::clean_buffer(void *base, size_t size, int offset, int fd, int op)
+{
+    struct ion_flush_data flush_data;
+    struct ion_fd_data fd_data;
+    struct ion_handle_data handle_data;
+    int err = 0;
+
+    err = open_device();
+    if (err)
+        return err;
+
+    fd_data.fd = fd;
+    if (ioctl(mIonFd, ION_IOC_IMPORT, &fd_data)) {
+        err = -errno;
+        ALOGE("%s: ION_IOC_IMPORT failed with error - %s",
+              __FUNCTION__, strerror(errno));
+        return err;
+    }
+
+    handle_data.handle = fd_data.handle;
+    flush_data.handle  = fd_data.handle;
+    flush_data.vaddr   = base;
+    flush_data.offset  = offset;
+    flush_data.length  = size;
+
+    struct ion_custom_data d;
+    switch(op) {
+    case CACHE_CLEAN:
+        d.cmd = ION_IOC_CLEAN_CACHES;
+        break;
+    case CACHE_INVALIDATE:
+            d.cmd = ION_IOC_INV_CACHES;
+        break;
+    case CACHE_CLEAN_AND_INVALIDATE:
+    default:
+        d.cmd = ION_IOC_CLEAN_INV_CACHES;
+    }
+
+    d.arg = (unsigned long int)&flush_data;
+
+    if(ioctl(mIonFd, ION_IOC_CUSTOM, &d)) {
+        err = -errno;
+        ALOGE("%s: ION_IOC_CLEAN_INV_CACHES failed with error - %s",
+
+              __FUNCTION__, strerror(errno));
+        ioctl(mIonFd, ION_IOC_FREE, &handle_data);
+        return err;
+    }
+    ioctl(mIonFd, ION_IOC_FREE, &handle_data);
+    return 0;
+}
+
diff --git a/msm8974/libgralloc/ionalloc.h b/msm8974/libgralloc/ionalloc.h
new file mode 100644
index 0000000..174f44b
--- /dev/null
+++ b/msm8974/libgralloc/ionalloc.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GRALLOC_IONALLOC_H
+#define GRALLOC_IONALLOC_H
+
+#include <linux/msm_ion.h>
+#include "memalloc.h"
+#include "gr.h"
+
+namespace gralloc {
+
+class IonAlloc : public IMemAlloc  {
+
+    public:
+    virtual int alloc_buffer(alloc_data& data);
+
+    virtual int free_buffer(void *base, size_t size,
+                            int offset, int fd);
+
+    virtual int map_buffer(void **pBase, size_t size,
+                           int offset, int fd);
+
+    virtual int unmap_buffer(void *base, size_t size,
+                             int offset);
+
+    virtual int clean_buffer(void*base, size_t size,
+                             int offset, int fd, int op);
+
+    IonAlloc() { mIonFd = FD_INIT; }
+
+    ~IonAlloc() { close_device(); }
+
+    private:
+    int mIonFd;
+
+    int open_device();
+
+    void close_device();
+
+    mutable Locker mLock;
+
+};
+
+}
+
+#endif /* GRALLOC_IONALLOC_H */
+
diff --git a/msm8974/libgralloc/mapper.cpp b/msm8974/libgralloc/mapper.cpp
new file mode 100644
index 0000000..4f43d40
--- /dev/null
+++ b/msm8974/libgralloc/mapper.cpp
@@ -0,0 +1,411 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <limits.h>
+#include <errno.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <linux/ashmem.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+#include <cutils/ashmem.h>
+
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h>
+
+#include "gralloc_priv.h"
+#include "gr.h"
+#include "alloc_controller.h"
+#include "memalloc.h"
+#include <qdMetaData.h>
+
+using namespace gralloc;
+/*****************************************************************************/
+
+// Return the type of allocator -
+// these are used for mapping/unmapping
+static IMemAlloc* getAllocator(int flags)
+{
+    IMemAlloc* memalloc;
+    IAllocController* alloc_ctrl = IAllocController::getInstance();
+    memalloc = alloc_ctrl->getAllocator(flags);
+    return memalloc;
+}
+
+static int gralloc_map(gralloc_module_t const* module,
+                       buffer_handle_t handle)
+{
+    private_handle_t* hnd = (private_handle_t*)handle;
+    void *mappedAddress;
+    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) &&
+        !(hnd->flags & private_handle_t::PRIV_FLAGS_SECURE_BUFFER)) {
+        size_t size = hnd->size;
+        IMemAlloc* memalloc = getAllocator(hnd->flags) ;
+        int err = memalloc->map_buffer(&mappedAddress, size,
+                                       hnd->offset, hnd->fd);
+        if(err || mappedAddress == MAP_FAILED) {
+            ALOGE("Could not mmap handle %p, fd=%d (%s)",
+                  handle, hnd->fd, strerror(errno));
+            hnd->base = 0;
+            return -errno;
+        }
+
+        hnd->base = intptr_t(mappedAddress) + hnd->offset;
+        mappedAddress = MAP_FAILED;
+        size = ROUND_UP_PAGESIZE(sizeof(MetaData_t));
+        err = memalloc->map_buffer(&mappedAddress, size,
+                                       hnd->offset_metadata, hnd->fd_metadata);
+        if(err || mappedAddress == MAP_FAILED) {
+            ALOGE("Could not mmap handle %p, fd=%d (%s)",
+                  handle, hnd->fd_metadata, strerror(errno));
+            hnd->base_metadata = 0;
+            return -errno;
+        }
+        hnd->base_metadata = intptr_t(mappedAddress) + hnd->offset_metadata;
+    }
+    return 0;
+}
+
+static int gralloc_unmap(gralloc_module_t const* module,
+                         buffer_handle_t handle)
+{
+    private_handle_t* hnd = (private_handle_t*)handle;
+    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
+        int err = -EINVAL;
+        void* base = (void*)hnd->base;
+        size_t size = hnd->size;
+        IMemAlloc* memalloc = getAllocator(hnd->flags) ;
+        if(memalloc != NULL) {
+            err = memalloc->unmap_buffer(base, size, hnd->offset);
+            if (err) {
+                ALOGE("Could not unmap memory at address %p", base);
+            }
+            base = (void*)hnd->base_metadata;
+            size = ROUND_UP_PAGESIZE(sizeof(MetaData_t));
+            err = memalloc->unmap_buffer(base, size, hnd->offset_metadata);
+            if (err) {
+                ALOGE("Could not unmap memory at address %p", base);
+            }
+        }
+    }
+    /* need to initialize the pointer to NULL otherwise unmapping for that
+     * buffer happens twice which leads to crash */
+    hnd->base = 0;
+    hnd->base_metadata = 0;
+    return 0;
+}
+
+/*****************************************************************************/
+
+static pthread_mutex_t sMapLock = PTHREAD_MUTEX_INITIALIZER;
+
+/*****************************************************************************/
+
+int gralloc_register_buffer(gralloc_module_t const* module,
+                            buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    // In this implementation, we don't need to do anything here
+
+    /* NOTE: we need to initialize the buffer as not mapped/not locked
+     * because it shouldn't when this function is called the first time
+     * in a new process. Ideally these flags shouldn't be part of the
+     * handle, but instead maintained in the kernel or at least
+     * out-of-line
+     */
+
+    private_handle_t* hnd = (private_handle_t*)handle;
+    hnd->base = 0;
+    hnd->base_metadata = 0;
+    int err = gralloc_map(module, handle);
+    if (err) {
+        ALOGE("%s: gralloc_map failed", __FUNCTION__);
+        return err;
+    }
+
+    return 0;
+}
+
+int gralloc_unregister_buffer(gralloc_module_t const* module,
+                              buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    /*
+     * If the buffer has been mapped during a lock operation, it's time
+     * to un-map it. It's an error to be here with a locked buffer.
+     * NOTE: the framebuffer is handled differently and is never unmapped.
+     */
+
+    private_handle_t* hnd = (private_handle_t*)handle;
+
+    if (hnd->base != 0) {
+        gralloc_unmap(module, handle);
+    }
+    hnd->base = 0;
+    hnd->base_metadata = 0;
+    return 0;
+}
+
+int terminateBuffer(gralloc_module_t const* module,
+                    private_handle_t* hnd)
+{
+    /*
+     * If the buffer has been mapped during a lock operation, it's time
+     * to un-map it. It's an error to be here with a locked buffer.
+     */
+
+    if (hnd->base != 0) {
+        // this buffer was mapped, unmap it now
+        if (hnd->flags & (private_handle_t::PRIV_FLAGS_USES_PMEM |
+                          private_handle_t::PRIV_FLAGS_USES_PMEM_ADSP |
+                          private_handle_t::PRIV_FLAGS_USES_ASHMEM |
+                          private_handle_t::PRIV_FLAGS_USES_ION)) {
+                gralloc_unmap(module, hnd);
+        } else {
+            ALOGE("terminateBuffer: unmapping a non pmem/ashmem buffer flags = 0x%x",
+                  hnd->flags);
+            gralloc_unmap(module, hnd);
+        }
+    }
+
+    return 0;
+}
+
+static int gralloc_map_and_invalidate (gralloc_module_t const* module,
+                                       buffer_handle_t handle, int usage,
+                                       int l, int t, int w, int h)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+
+    int err = 0;
+    private_handle_t* hnd = (private_handle_t*)handle;
+    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
+        if (hnd->base == 0) {
+            // we need to map for real
+            pthread_mutex_t* const lock = &sMapLock;
+            pthread_mutex_lock(lock);
+            err = gralloc_map(module, handle);
+            pthread_mutex_unlock(lock);
+        }
+        if (hnd->flags & private_handle_t::PRIV_FLAGS_USES_ION) {
+            //Invalidate if reading in software. No need to do this for the
+            //metadata buffer as it is only read/written in software.
+            IMemAlloc* memalloc = getAllocator(hnd->flags) ;
+            err = memalloc->clean_buffer((void*)hnd->base,
+                                         hnd->size, hnd->offset, hnd->fd,
+                                         CACHE_INVALIDATE);
+            if (usage & GRALLOC_USAGE_SW_WRITE_MASK) {
+                // Mark the buffer to be flushed after cpu read/write
+                hnd->flags |= private_handle_t::PRIV_FLAGS_NEEDS_FLUSH;
+            }
+        }
+    } else {
+        hnd->flags |= private_handle_t::PRIV_FLAGS_DO_NOT_FLUSH;
+    }
+    return err;
+}
+
+int gralloc_lock(gralloc_module_t const* module,
+                 buffer_handle_t handle, int usage,
+                 int l, int t, int w, int h,
+                 void** vaddr)
+{
+    private_handle_t* hnd = (private_handle_t*)handle;
+    int err = gralloc_map_and_invalidate(module, handle, usage, l, t, w, h);
+    if(!err)
+        *vaddr = (void*)hnd->base;
+    return err;
+}
+
+int gralloc_lock_ycbcr(gralloc_module_t const* module,
+                 buffer_handle_t handle, int usage,
+                 int l, int t, int w, int h,
+                 struct android_ycbcr *ycbcr)
+{
+    private_handle_t* hnd = (private_handle_t*)handle;
+    int err = gralloc_map_and_invalidate(module, handle, usage, l, t, w, h);
+    int ystride, cstride;
+
+    memset(ycbcr->reserved, 0, sizeof(ycbcr->reserved));
+    if(!err) {
+        //hnd->format holds our implementation defined format
+        switch (hnd->format) {
+            case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+                ystride = ALIGN(hnd->width, 16);
+                ycbcr->y  = (void*)hnd->base;
+                ycbcr->cr = (void*)(hnd->base + ystride * hnd->height);
+                ycbcr->cb = (void*)(hnd->base + ystride * hnd->height + 1);
+                ycbcr->ystride = ystride;
+                ycbcr->cstride = ystride;
+                ycbcr->chroma_step = 2;
+                break;
+            case HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS:
+                ystride = cstride = hnd->width;
+                ycbcr->y  = (void*)hnd->base;
+                ycbcr->cb = (void*)(hnd->base + ystride * hnd->height);
+                ycbcr->cr = (void*)(hnd->base + ystride * hnd->height + 1);
+                ycbcr->ystride = ystride;
+                ycbcr->cstride = cstride;
+                ycbcr->chroma_step = 2;
+                break;
+              //Planar
+            case HAL_PIXEL_FORMAT_YV12:
+                ystride = hnd->width;
+                cstride = ALIGN(hnd->width/2, 16);
+                ycbcr->y  = (void*)hnd->base;
+                ycbcr->cr = (void*)(hnd->base + ystride * hnd->height);
+                ycbcr->cb = (void*)(hnd->base + ystride * hnd->height +
+                        cstride * hnd->height/2);
+                ycbcr->ystride = ystride;
+                ycbcr->cstride = cstride;
+                ycbcr->chroma_step = 1;
+                break;
+            default:
+                ALOGD("%s: Invalid format passed: 0x%x", __FUNCTION__,
+                      hnd->format);
+                err = -EINVAL;
+        }
+    }
+    return err;
+}
+
+int gralloc_unlock(gralloc_module_t const* module,
+                   buffer_handle_t handle)
+{
+    if (private_handle_t::validate(handle) < 0)
+        return -EINVAL;
+    int err = 0;
+    private_handle_t* hnd = (private_handle_t*)handle;
+
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_USES_ION) {
+        IMemAlloc* memalloc = getAllocator(hnd->flags);
+        if (hnd->flags & private_handle_t::PRIV_FLAGS_NEEDS_FLUSH) {
+            err = memalloc->clean_buffer((void*)hnd->base,
+                                         hnd->size, hnd->offset, hnd->fd,
+                                         CACHE_CLEAN_AND_INVALIDATE);
+            hnd->flags &= ~private_handle_t::PRIV_FLAGS_NEEDS_FLUSH;
+        } else if(hnd->flags & private_handle_t::PRIV_FLAGS_DO_NOT_FLUSH) {
+            hnd->flags &= ~private_handle_t::PRIV_FLAGS_DO_NOT_FLUSH;
+        } else {
+            //Probably a round about way to do this, but this avoids adding new
+            //flags
+            err = memalloc->clean_buffer((void*)hnd->base,
+                                         hnd->size, hnd->offset, hnd->fd,
+                                         CACHE_INVALIDATE);
+        }
+    }
+
+    return err;
+}
+
+/*****************************************************************************/
+
+int gralloc_perform(struct gralloc_module_t const* module,
+                    int operation, ... )
+{
+    int res = -EINVAL;
+    va_list args;
+    va_start(args, operation);
+    switch (operation) {
+        case GRALLOC_MODULE_PERFORM_CREATE_HANDLE_FROM_BUFFER:
+            {
+                int fd = va_arg(args, int);
+                size_t size = va_arg(args, size_t);
+                size_t offset = va_arg(args, size_t);
+                void* base = va_arg(args, void*);
+                int width = va_arg(args, int);
+                int height = va_arg(args, int);
+                int format = va_arg(args, int);
+
+                native_handle_t** handle = va_arg(args, native_handle_t**);
+                int memoryFlags __unused = va_arg(args, int);
+                private_handle_t* hnd = (private_handle_t*)native_handle_create(
+                    private_handle_t::sNumFds, private_handle_t::sNumInts);
+                hnd->magic = private_handle_t::sMagic;
+                hnd->fd = fd;
+                hnd->flags =  private_handle_t::PRIV_FLAGS_USES_ION;
+                hnd->size = size;
+                hnd->offset = offset;
+                hnd->base = intptr_t(base) + offset;
+                hnd->gpuaddr = 0;
+                hnd->width = width;
+                hnd->height = height;
+                hnd->format = format;
+                *handle = (native_handle_t *)hnd;
+                res = 0;
+                break;
+
+            }
+#ifdef QCOM_BSP
+        case GRALLOC_MODULE_PERFORM_UPDATE_BUFFER_GEOMETRY:
+            {
+                int width = va_arg(args, int);
+                int height = va_arg(args, int);
+                int format = va_arg(args, int);
+                private_handle_t* hnd =  va_arg(args, private_handle_t*);
+                if (private_handle_t::validate(hnd)) {
+                    return res;
+                }
+                hnd->width = width;
+                hnd->height = height;
+                hnd->format = format;
+                res = 0;
+            }
+            break;
+#endif
+        case GRALLOC_MODULE_PERFORM_GET_STRIDE:
+            {
+                int width   = va_arg(args, int);
+                int format  = va_arg(args, int);
+                int *stride = va_arg(args, int *);
+                *stride = AdrenoMemInfo::getInstance().getStride(width, format);
+                res = 0;
+            } break;
+        case GRALLOC_MODULE_PERFORM_GET_CUSTOM_STRIDE_FROM_HANDLE:
+            {
+                private_handle_t* hnd =  va_arg(args, private_handle_t*);
+                int *stride = va_arg(args, int *);
+                if (private_handle_t::validate(hnd)) {
+                    return res;
+                }
+                MetaData_t *metadata = (MetaData_t *)hnd->base_metadata;
+                if(metadata && metadata->operation & UPDATE_BUFFER_GEOMETRY) {
+                    *stride = metadata->bufferDim.sliceWidth;
+                } else {
+                    *stride = hnd->width;
+                }
+                res = 0;
+            } break;
+        default:
+            break;
+    }
+    va_end(args);
+    return res;
+}
diff --git a/msm8974/libgralloc/memalloc.h b/msm8974/libgralloc/memalloc.h
new file mode 100644
index 0000000..664bfa2
--- /dev/null
+++ b/msm8974/libgralloc/memalloc.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GRALLOC_MEMALLOC_H
+#define GRALLOC_MEMALLOC_H
+
+#include <stdlib.h>
+
+namespace gralloc {
+
+enum {
+    CACHE_CLEAN = 0x1,
+    CACHE_INVALIDATE,
+    CACHE_CLEAN_AND_INVALIDATE,
+};
+
+struct alloc_data {
+    void           *base;
+    int            fd;
+    int            offset;
+    size_t         size;
+    size_t         align;
+    unsigned int   pHandle;
+    bool           uncached;
+    unsigned int   flags;
+    int            allocType;
+};
+
+class IMemAlloc {
+
+    public:
+    // Allocate buffer - fill in the alloc_data
+    // structure and pass it in. Mapped address
+    // and fd are returned in the alloc_data struct
+    virtual int alloc_buffer(alloc_data& data) = 0;
+
+    // Free buffer
+    virtual int free_buffer(void *base, size_t size,
+                            int offset, int fd) = 0;
+
+    // Map buffer
+    virtual int map_buffer(void **pBase, size_t size,
+                           int offset, int fd) = 0;
+
+    // Unmap buffer
+    virtual int unmap_buffer(void *base, size_t size,
+                             int offset) = 0;
+
+    // Clean and invalidate
+    virtual int clean_buffer(void *base, size_t size,
+                             int offset, int fd, int op) = 0;
+
+    // Destructor
+    virtual ~IMemAlloc() {};
+
+    enum {
+        FD_INIT = -1,
+    };
+
+};
+
+} // end gralloc namespace
+#endif // GRALLOC_MEMALLOC_H
diff --git a/msm8974/libhwcomposer/Android.mk b/msm8974/libhwcomposer/Android.mk
new file mode 100644
index 0000000..951e170
--- /dev/null
+++ b/msm8974/libhwcomposer/Android.mk
@@ -0,0 +1,27 @@
+LOCAL_PATH := $(call my-dir)
+include $(LOCAL_PATH)/../common.mk
+include $(CLEAR_VARS)
+
+# hwc.cpp uses GNU old-style field designator extension.
+LOCAL_CLANG_CFLAGS            += -Wno-gnu-designator
+LOCAL_MODULE                  := hwcomposer.$(TARGET_BOARD_PLATFORM)
+LOCAL_MODULE_PATH             := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_MODULE_TAGS             := optional
+LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)
+LOCAL_SHARED_LIBRARIES        := $(common_libs) libEGL liboverlay \
+                                 libexternal libqdutils libhardware_legacy \
+                                 libdl libmemalloc libqservice libsync \
+                                 libbinder libmedia
+LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"qdhwcomposer\"
+LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
+LOCAL_SRC_FILES               := hwc.cpp          \
+                                 hwc_utils.cpp    \
+                                 hwc_uevents.cpp  \
+                                 hwc_vsync.cpp    \
+                                 hwc_fbupdate.cpp \
+                                 hwc_mdpcomp.cpp  \
+                                 hwc_copybit.cpp  \
+                                 hwc_qclient.cpp  \
+                                 hwc_ad.cpp
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/msm8974/libhwcomposer/hwc.cpp b/msm8974/libhwcomposer/hwc.cpp
new file mode 100644
index 0000000..83aa2a8
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc.cpp
@@ -0,0 +1,734 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define ATRACE_TAG (ATRACE_TAG_GRAPHICS | ATRACE_TAG_HAL)
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+#include <EGL/egl.h>
+#include <utils/Trace.h>
+#include <sys/ioctl.h>
+#include <overlay.h>
+#include <overlayRotator.h>
+#include <overlayWriteback.h>
+#include <mdp_version.h>
+#include "hwc_utils.h"
+#include "hwc_fbupdate.h"
+#include "hwc_mdpcomp.h"
+#include "external.h"
+#include "hwc_copybit.h"
+#include "hwc_ad.h"
+#include "profiler.h"
+
+using namespace qhwc;
+using namespace overlay;
+
+#define VSYNC_DEBUG 0
+#define BLANK_DEBUG 1
+
+static int hwc_device_open(const struct hw_module_t* module,
+                           const char* name,
+                           struct hw_device_t** device);
+
+static struct hw_module_methods_t hwc_module_methods = {
+    open: hwc_device_open
+};
+
+hwc_module_t HAL_MODULE_INFO_SYM = {
+    common: {
+        tag: HARDWARE_MODULE_TAG,
+        version_major: 2,
+        version_minor: 0,
+        id: HWC_HARDWARE_MODULE_ID,
+        name: "Qualcomm Hardware Composer Module",
+        author: "CodeAurora Forum",
+        methods: &hwc_module_methods,
+        dso: 0,
+        reserved: {0},
+    }
+};
+
+/*
+ * Save callback functions registered to HWC
+ */
+static void hwc_registerProcs(struct hwc_composer_device_1* dev,
+                              hwc_procs_t const* procs)
+{
+    ALOGI("%s", __FUNCTION__);
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    if(!ctx) {
+        ALOGE("%s: Invalid context", __FUNCTION__);
+        return;
+    }
+    ctx->proc = procs;
+
+    // Now that we have the functions needed, kick off
+    // the uevent & vsync threads
+    init_uevent_thread(ctx);
+    init_vsync_thread(ctx);
+}
+
+//Helper
+static void reset(hwc_context_t *ctx, int numDisplays,
+                  hwc_display_contents_1_t** displays) {
+    for(int i = 0; i < MAX_DISPLAYS; i++) {
+        hwc_display_contents_1_t *list = displays[i];
+        // XXX:SurfaceFlinger no longer guarantees that this
+        // value is reset on every prepare. However, for the layer
+        // cache we need to reset it.
+        // We can probably rethink that later on
+        if (LIKELY(list && list->numHwLayers > 1)) {
+            for(uint32_t j = 0; j < list->numHwLayers; j++) {
+                if(list->hwLayers[j].compositionType != HWC_FRAMEBUFFER_TARGET)
+                    list->hwLayers[j].compositionType = HWC_FRAMEBUFFER;
+            }
+        }
+
+        if(ctx->mFBUpdate[i])
+            ctx->mFBUpdate[i]->reset();
+        if(ctx->mMDPComp[i])
+            ctx->mMDPComp[i]->reset();
+        if(ctx->mCopyBit[i])
+            ctx->mCopyBit[i]->reset();
+        if(ctx->mLayerRotMap[i])
+            ctx->mLayerRotMap[i]->reset();
+    }
+
+    ctx->mAD->reset();
+}
+
+//clear prev layer prop flags and realloc for current frame
+static void reset_layer_prop(hwc_context_t* ctx, int dpy, int numAppLayers) {
+    if(ctx->layerProp[dpy]) {
+       delete[] ctx->layerProp[dpy];
+       ctx->layerProp[dpy] = NULL;
+    }
+    ctx->layerProp[dpy] = new LayerProp[numAppLayers];
+}
+
+static void handleGeomChange(hwc_context_t *ctx, int dpy,
+        hwc_display_contents_1_t *list) {
+    if(list->flags & HWC_GEOMETRY_CHANGED) {
+        ctx->mOverlay->forceSet(dpy);
+    }
+}
+
+static int display_commit(hwc_context_t *ctx, int dpy) {
+    int fbFd = ctx->dpyAttr[dpy].fd;
+    if(fbFd == -1) {
+        ALOGE("%s: Invalid FB fd for display: %d", __FUNCTION__, dpy);
+        return -1;
+    }
+
+    struct mdp_display_commit commit_info;
+    memset(&commit_info, 0, sizeof(struct mdp_display_commit));
+    commit_info.flags = MDP_DISPLAY_COMMIT_OVERLAY;
+    if(ioctl(fbFd, MSMFB_DISPLAY_COMMIT, &commit_info) == -1) {
+       ALOGE("%s: MSMFB_DISPLAY_COMMIT for primary failed", __FUNCTION__);
+       return -errno;
+    }
+    return 0;
+}
+
+static int hwc_prepare_primary(hwc_composer_device_1 *dev,
+        hwc_display_contents_1_t *list) {
+    ATRACE_CALL();
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    const int dpy = HWC_DISPLAY_PRIMARY;
+    if (LIKELY(list && list->numHwLayers > 1) &&
+            ctx->dpyAttr[dpy].isActive) {
+        reset_layer_prop(ctx, dpy, list->numHwLayers - 1);
+        handleGeomChange(ctx, dpy, list);
+        setListStats(ctx, list, dpy);
+        if(ctx->mMDPComp[dpy]->prepare(ctx, list) < 0) {
+            const int fbZ = 0;
+            ctx->mFBUpdate[dpy]->prepare(ctx, list, fbZ);
+        }
+        if (ctx->mMDP.version < qdutils::MDP_V4_0) {
+            if(ctx->mCopyBit[dpy])
+                ctx->mCopyBit[dpy]->prepare(ctx, list, dpy);
+        }
+    }
+    return 0;
+}
+
+static int hwc_prepare_external(hwc_composer_device_1 *dev,
+        hwc_display_contents_1_t *list) {
+
+    ATRACE_CALL();
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    const int dpy = HWC_DISPLAY_EXTERNAL;
+
+    if (LIKELY(list && list->numHwLayers > 1) &&
+            ctx->dpyAttr[dpy].isActive &&
+            ctx->dpyAttr[dpy].connected) {
+        reset_layer_prop(ctx, dpy, list->numHwLayers - 1);
+        handleGeomChange(ctx, dpy, list);
+        if(!ctx->dpyAttr[dpy].isPause) {
+            ctx->dpyAttr[dpy].isConfiguring = false;
+            setListStats(ctx, list, dpy);
+            if(ctx->mMDPComp[dpy]->prepare(ctx, list) < 0) {
+                const int fbZ = 0;
+                ctx->mFBUpdate[dpy]->prepare(ctx, list, fbZ);
+            }
+
+            /* Temporarily commenting out C2D until we support partial
+               copybit composition for mixed mode MDP
+
+               if((fbZOrder >= 0) && ctx->mCopyBit[dpy])
+               ctx->mCopyBit[dpy]->prepare(ctx, list, dpy);
+             */
+        } else {
+            // External Display is in Pause state.
+            // ToDo:
+            // Mark all application layers as OVERLAY so that
+            // GPU will not compose. This is done for power
+            // optimization
+        }
+    }
+    return 0;
+}
+
+static int hwc_prepare_virtual(hwc_composer_device_1 *dev,
+        hwc_display_contents_1_t *list) {
+    ATRACE_CALL();
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    const int dpy = HWC_DISPLAY_VIRTUAL;
+
+    if (list && list->outbuf && list->numHwLayers > 0) {
+        reset_layer_prop(ctx, dpy, list->numHwLayers - 1);
+        uint32_t last = list->numHwLayers - 1;
+        hwc_layer_1_t *fbLayer = &list->hwLayers[last];
+        int fbWidth = 0, fbHeight = 0;
+        getLayerResolution(fbLayer, fbWidth, fbHeight);
+        ctx->dpyAttr[dpy].xres = fbWidth;
+        ctx->dpyAttr[dpy].yres = fbHeight;
+
+        if(ctx->dpyAttr[dpy].connected == false) {
+            ctx->dpyAttr[dpy].connected = true;
+            setupSecondaryObjs(ctx, dpy);
+        }
+
+        ctx->dpyAttr[dpy].fd = Writeback::getInstance()->getFbFd();
+        private_handle_t *ohnd = (private_handle_t *)list->outbuf;
+        Writeback::getInstance()->configureDpyInfo(ohnd->width, ohnd->height);
+        setListStats(ctx, list, dpy);
+
+        if(ctx->mMDPComp[dpy]->prepare(ctx, list) < 0) {
+            const int fbZ = 0;
+            ctx->mFBUpdate[dpy]->prepare(ctx, list, fbZ);
+        }
+    }
+    return 0;
+}
+
+static int hwc_prepare(hwc_composer_device_1 *dev, size_t numDisplays,
+                       hwc_display_contents_1_t** displays)
+{
+    int ret = 0;
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    //Will be unlocked at the end of set
+    ctx->mDrawLock.lock();
+    reset(ctx, numDisplays, displays);
+
+    ctx->mOverlay->configBegin();
+    ctx->mRotMgr->configBegin();
+    overlay::Writeback::configBegin();
+
+    Overlay::setDMAMode(Overlay::DMA_LINE_MODE);
+
+    //Cleanup virtual display objs, since there is no explicit disconnect
+    if(ctx->dpyAttr[HWC_DISPLAY_VIRTUAL].connected &&
+        (numDisplays <= HWC_NUM_PHYSICAL_DISPLAY_TYPES ||
+        displays[HWC_DISPLAY_VIRTUAL] == NULL)) {
+        ctx->dpyAttr[HWC_DISPLAY_VIRTUAL].connected = false;
+        clearSecondaryObjs(ctx, HWC_DISPLAY_VIRTUAL);
+    }
+
+    for (int32_t i = numDisplays - 1; i >= 0; i--) {
+        hwc_display_contents_1_t *list = displays[i];
+        switch(i) {
+            case HWC_DISPLAY_PRIMARY:
+                ret = hwc_prepare_primary(dev, list);
+                break;
+            case HWC_DISPLAY_EXTERNAL:
+                ret = hwc_prepare_external(dev, list);
+                break;
+            case HWC_DISPLAY_VIRTUAL:
+                ret = hwc_prepare_virtual(dev, list);
+                break;
+            default:
+                ret = -EINVAL;
+        }
+    }
+
+    ctx->mOverlay->configDone();
+    ctx->mRotMgr->configDone();
+    overlay::Writeback::configDone();
+
+    return ret;
+}
+
+static int hwc_eventControl(struct hwc_composer_device_1* dev, int dpy,
+                             int event, int enable)
+{
+    ATRACE_CALL();
+    int ret = 0;
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    switch(event) {
+        case HWC_EVENT_VSYNC:
+            if(!ctx->dpyAttr[dpy].isActive) {
+                ALOGE("Display is blanked - Cannot %s vsync",
+                        enable ? "enable" : "disable");
+                return -EINVAL;
+            }
+
+            if (ctx->vstate.enable == enable)
+                break;
+            ret = hwc_vsync_control(ctx, dpy, enable);
+            if(ret == 0)
+                ctx->vstate.enable = !!enable;
+            ALOGD_IF (VSYNC_DEBUG, "VSYNC state changed to %s",
+                      (enable)?"ENABLED":"DISABLED");
+            break;
+        default:
+            ret = -EINVAL;
+    }
+    return ret;
+}
+
+static int hwc_blank(struct hwc_composer_device_1* dev, int dpy, int blank)
+{
+    ATRACE_CALL();
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+
+    Locker::Autolock _l(ctx->mDrawLock);
+    int ret = 0;
+    ALOGD_IF(BLANK_DEBUG, "%s: %s display: %d", __FUNCTION__,
+          blank==1 ? "Blanking":"Unblanking", dpy);
+    if (blank || (dpy == HWC_DISPLAY_PRIMARY &&
+        !ctx->dpyAttr[dpy].isActive )) {
+        // free up all the overlay pipes in use
+        // when we get a blank for either display
+        // makes sure that all pipes are freed
+        ctx->mOverlay->configBegin();
+        ctx->mOverlay->configDone();
+        ctx->mRotMgr->clear();
+        overlay::Writeback::clear();
+    }
+    switch(dpy) {
+        case HWC_DISPLAY_PRIMARY:
+            if(blank) {
+                ret = ioctl(ctx->dpyAttr[dpy].fd, FBIOBLANK,
+                            FB_BLANK_POWERDOWN);
+            } else {
+                ret = ioctl(ctx->dpyAttr[dpy].fd, FBIOBLANK,FB_BLANK_UNBLANK);
+            }
+            break;
+        case HWC_DISPLAY_EXTERNAL:
+        case HWC_DISPLAY_VIRTUAL:
+            if(blank) {
+                // call external framebuffer commit on blank,
+                // so that any pipe unsets gets committed
+                if (display_commit(ctx, dpy) < 0) {
+                    ret = -1;
+                    ALOGE("%s:post failed for dpy %d",
+                          __FUNCTION__, dpy);
+                }
+            } else {
+            }
+            break;
+        default:
+            return -EINVAL;
+    }
+    if(ret == 0){
+        ctx->dpyAttr[dpy].isActive = !blank;
+    } else {
+        ALOGE("%s: Failed in %s display: %d error:%s", __FUNCTION__,
+              blank==1 ? "blanking":"unblanking", dpy, strerror(errno));
+        return ret;
+    }
+
+    ALOGD_IF(BLANK_DEBUG, "%s: Done %s display: %d", __FUNCTION__,
+          blank==1 ? "blanking":"unblanking", dpy);
+    return 0;
+}
+
+static int hwc_query(struct hwc_composer_device_1* dev,
+                     int param, int* value)
+{
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    int supported = HWC_DISPLAY_PRIMARY_BIT;
+
+    switch (param) {
+    case HWC_BACKGROUND_LAYER_SUPPORTED:
+        // Not supported for now
+        value[0] = 0;
+        break;
+    case HWC_DISPLAY_TYPES_SUPPORTED: //Unused by f/w
+        if(ctx->mMDP.hasOverlay) {
+            supported |= HWC_DISPLAY_VIRTUAL_BIT;
+            if(!qdutils::MDPVersion::getInstance().is8x26())
+                supported |= HWC_DISPLAY_EXTERNAL_BIT;
+        }
+        value[0] = supported;
+        break;
+    default:
+        return -EINVAL;
+    }
+    return 0;
+
+}
+
+
+static int hwc_set_primary(hwc_context_t *ctx, hwc_display_contents_1_t* list) {
+    ATRACE_CALL();
+    int ret = 0;
+    const int dpy = HWC_DISPLAY_PRIMARY;
+
+    if (LIKELY(list) && ctx->dpyAttr[dpy].isActive) {
+        uint32_t last = list->numHwLayers - 1;
+        hwc_layer_1_t *fbLayer = &list->hwLayers[last];
+        int fd = -1; //FenceFD from the Copybit(valid in async mode)
+        bool copybitDone = false;
+        if(ctx->mCopyBit[dpy])
+            copybitDone = ctx->mCopyBit[dpy]->draw(ctx, list, dpy, &fd);
+        if(list->numHwLayers > 1)
+            hwc_sync(ctx, list, dpy, fd);
+
+        if (!ctx->mMDPComp[dpy]->draw(ctx, list)) {
+            ALOGE("%s: MDPComp draw failed", __FUNCTION__);
+            ret = -1;
+        }
+
+        //TODO We dont check for SKIP flag on this layer because we need PAN
+        //always. Last layer is always FB
+        private_handle_t *hnd = (private_handle_t *)fbLayer->handle;
+        if(copybitDone) {
+            hnd = ctx->mCopyBit[dpy]->getCurrentRenderBuffer();
+        }
+
+        if(hnd) {
+            if (!ctx->mFBUpdate[dpy]->draw(ctx, hnd)) {
+                ALOGE("%s: FBUpdate draw failed", __FUNCTION__);
+                ret = -1;
+            }
+        }
+
+        if (display_commit(ctx, dpy) < 0) {
+            ALOGE("%s: display commit fail!", __FUNCTION__);
+            ret = -1;
+        }
+    }
+
+    closeAcquireFds(list, dpy);
+    return ret;
+}
+
+static int hwc_set_external(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list)
+{
+    ATRACE_CALL();
+    int ret = 0;
+    const int dpy = HWC_DISPLAY_EXTERNAL;
+
+    if (LIKELY(list) && ctx->dpyAttr[dpy].isActive &&
+        !ctx->dpyAttr[dpy].isPause &&
+        ctx->dpyAttr[dpy].connected) {
+        uint32_t last = list->numHwLayers - 1;
+        hwc_layer_1_t *fbLayer = &list->hwLayers[last];
+        int fd = -1; //FenceFD from the Copybit(valid in async mode)
+        bool copybitDone = false;
+        if(ctx->mCopyBit[dpy])
+            copybitDone = ctx->mCopyBit[dpy]->draw(ctx, list, dpy, &fd);
+
+        if(list->numHwLayers > 1)
+            hwc_sync(ctx, list, dpy, fd);
+
+        if (!ctx->mMDPComp[dpy]->draw(ctx, list)) {
+            ALOGE("%s: MDPComp draw failed", __FUNCTION__);
+            ret = -1;
+        }
+
+        private_handle_t *hnd = (private_handle_t *)fbLayer->handle;
+        if(copybitDone) {
+            hnd = ctx->mCopyBit[dpy]->getCurrentRenderBuffer();
+        }
+
+        if(hnd) {
+            if (!ctx->mFBUpdate[dpy]->draw(ctx, hnd)) {
+                ALOGE("%s: FBUpdate::draw fail!", __FUNCTION__);
+                ret = -1;
+            }
+        }
+
+        if (display_commit(ctx, dpy) < 0) {
+            ALOGE("%s: display commit fail!", __FUNCTION__);
+            ret = -1;
+        }
+    }
+
+    closeAcquireFds(list, dpy);
+    return ret;
+}
+
+static int hwc_set_virtual(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list) {
+    ATRACE_CALL();
+    int ret = 0;
+    const int dpy = HWC_DISPLAY_VIRTUAL;
+
+    if (list && list->outbuf && list->numHwLayers > 0) {
+        uint32_t last = list->numHwLayers - 1;
+        hwc_layer_1_t *fbLayer = &list->hwLayers[last];
+
+        if(fbLayer->handle && ctx->dpyAttr[dpy].connected
+#ifndef FORCE_HWC_FOR_VIRTUAL_DISPLAYS
+                //XXX: If we're not forcing virtual via HWC,
+                //full GLES compositions will not be routed through here.
+                && !isGLESOnlyComp(ctx, dpy)
+#endif
+        ) {
+
+            private_handle_t *ohnd = (private_handle_t *)list->outbuf;
+            int format = ohnd->format;
+            if (format == HAL_PIXEL_FORMAT_RGBA_8888)
+                format = HAL_PIXEL_FORMAT_RGBX_8888;
+            Writeback::getInstance()->setOutputFormat(
+                    utils::getMdpFormat(format));
+
+            int fd = -1; //FenceFD from the Copybit
+            hwc_sync(ctx, list, dpy, fd);
+
+            if (!ctx->mMDPComp[dpy]->draw(ctx, list)) {
+                ALOGE("%s: MDPComp draw failed", __FUNCTION__);
+                ret = -1;
+            }
+
+            if (!ctx->mFBUpdate[dpy]->draw(ctx,
+                        (private_handle_t *)fbLayer->handle)) {
+                ALOGE("%s: FBUpdate::draw fail!", __FUNCTION__);
+                ret = -1;
+            }
+
+            Writeback::getInstance()->queueBuffer(ohnd->fd, ohnd->offset);
+            if (display_commit(ctx, dpy) < 0) {
+                ALOGE("%s: display commit fail!", __FUNCTION__);
+                ret = -1;
+            }
+        } else if(list->outbufAcquireFenceFd >= 0) {
+            //If we dont handle the frame, set retireFenceFd to outbufFenceFd,
+            //which will make sure, the framework waits on it and closes it.
+            //The other way is to wait on outbufFenceFd ourselves, close it and
+            //set retireFenceFd to -1. Since we want hwc to be async, choosing
+            //the former.
+            //Also dup because, the closeAcquireFds() will close the outbufFence
+            list->retireFenceFd = dup(list->outbufAcquireFenceFd);
+        }
+    }
+
+    closeAcquireFds(list, dpy);
+    return ret;
+}
+
+
+static int hwc_set(hwc_composer_device_1 *dev,
+                   size_t numDisplays,
+                   hwc_display_contents_1_t** displays)
+{
+    int ret = 0;
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    for (uint32_t i = 0; i < numDisplays; i++) {
+        hwc_display_contents_1_t* list = displays[i];
+        switch(i) {
+            case HWC_DISPLAY_PRIMARY:
+                ret = hwc_set_primary(ctx, list);
+                break;
+            case HWC_DISPLAY_EXTERNAL:
+                ret = hwc_set_external(ctx, list);
+                break;
+            case HWC_DISPLAY_VIRTUAL:
+                ret = hwc_set_virtual(ctx, list);
+                break;
+            default:
+                ret = -EINVAL;
+        }
+    }
+    // This is only indicative of how many times SurfaceFlinger posts
+    // frames to the display.
+    CALC_FPS();
+    MDPComp::resetIdleFallBack();
+    ctx->mVideoTransFlag = false;
+    //Was locked at the beginning of prepare
+    ctx->mDrawLock.unlock();
+    return ret;
+}
+
+int hwc_getDisplayConfigs(struct hwc_composer_device_1* dev, int disp,
+        uint32_t* configs, size_t* numConfigs) {
+    int ret = 0;
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    //in 1.1 there is no way to choose a config, report as config id # 0
+    //This config is passed to getDisplayAttributes. Ignore for now.
+    switch(disp) {
+        case HWC_DISPLAY_PRIMARY:
+            if(*numConfigs > 0) {
+                configs[0] = 0;
+                *numConfigs = 1;
+            }
+            ret = 0; //NO_ERROR
+            break;
+        case HWC_DISPLAY_EXTERNAL:
+            ret = -1; //Not connected
+            if(ctx->dpyAttr[HWC_DISPLAY_EXTERNAL].connected) {
+                ret = 0; //NO_ERROR
+                if(*numConfigs > 0) {
+                    configs[0] = 0;
+                    *numConfigs = 1;
+                }
+            }
+            break;
+    }
+    return ret;
+}
+
+int hwc_getDisplayAttributes(struct hwc_composer_device_1* dev, int disp,
+        uint32_t config, const uint32_t* attributes, int32_t* values) {
+
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    //If hotpluggable displays are inactive return error
+    if(disp == HWC_DISPLAY_EXTERNAL && !ctx->dpyAttr[disp].connected) {
+        return -1;
+    }
+
+    //From HWComposer
+    static const uint32_t DISPLAY_ATTRIBUTES[] = {
+        HWC_DISPLAY_VSYNC_PERIOD,
+        HWC_DISPLAY_WIDTH,
+        HWC_DISPLAY_HEIGHT,
+        HWC_DISPLAY_DPI_X,
+        HWC_DISPLAY_DPI_Y,
+        HWC_DISPLAY_NO_ATTRIBUTE,
+    };
+
+    const int NUM_DISPLAY_ATTRIBUTES = (sizeof(DISPLAY_ATTRIBUTES) /
+            sizeof(DISPLAY_ATTRIBUTES)[0]);
+
+    for (size_t i = 0; i < NUM_DISPLAY_ATTRIBUTES - 1; i++) {
+        switch (attributes[i]) {
+        case HWC_DISPLAY_VSYNC_PERIOD:
+            values[i] = ctx->dpyAttr[disp].vsync_period;
+            break;
+        case HWC_DISPLAY_WIDTH:
+            values[i] = ctx->dpyAttr[disp].xres;
+            ALOGD("%s disp = %d, width = %d",__FUNCTION__, disp,
+                    ctx->dpyAttr[disp].xres);
+            break;
+        case HWC_DISPLAY_HEIGHT:
+            values[i] = ctx->dpyAttr[disp].yres;
+            ALOGD("%s disp = %d, height = %d",__FUNCTION__, disp,
+                    ctx->dpyAttr[disp].yres);
+            break;
+        case HWC_DISPLAY_DPI_X:
+            values[i] = (int32_t) (ctx->dpyAttr[disp].xdpi*1000.0);
+            break;
+        case HWC_DISPLAY_DPI_Y:
+            values[i] = (int32_t) (ctx->dpyAttr[disp].ydpi*1000.0);
+            break;
+        default:
+            ALOGE("Unknown display attribute %d",
+                    attributes[i]);
+            return -EINVAL;
+        }
+    }
+    return 0;
+}
+
+void hwc_dump(struct hwc_composer_device_1* dev, char *buff, int buff_len)
+{
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    Locker::Autolock _l(ctx->mDrawLock);
+    android::String8 aBuf("");
+    dumpsys_log(aBuf, "Qualcomm HWC state:\n");
+    dumpsys_log(aBuf, "  MDPVersion=%d\n", ctx->mMDP.version);
+    dumpsys_log(aBuf, "  DisplayPanel=%c\n", ctx->mMDP.panel);
+    for(int dpy = 0; dpy < MAX_DISPLAYS; dpy++) {
+        if(ctx->mMDPComp[dpy])
+            ctx->mMDPComp[dpy]->dump(aBuf);
+    }
+    char ovDump[2048] = {'\0'};
+    ctx->mOverlay->getDump(ovDump, 2048);
+    dumpsys_log(aBuf, ovDump);
+    ovDump[0] = '\0';
+    ctx->mRotMgr->getDump(ovDump, 1024);
+    dumpsys_log(aBuf, ovDump);
+    ovDump[0] = '\0';
+    if(Writeback::getDump(ovDump, 1024)) {
+        dumpsys_log(aBuf, ovDump);
+        ovDump[0] = '\0';
+    }
+    strlcpy(buff, aBuf.string(), buff_len);
+}
+
+static int hwc_device_close(struct hw_device_t *dev)
+{
+    if(!dev) {
+        ALOGE("%s: NULL device pointer", __FUNCTION__);
+        return -1;
+    }
+    closeContext((hwc_context_t*)dev);
+    free(dev);
+
+    return 0;
+}
+
+static int hwc_device_open(const struct hw_module_t* module, const char* name,
+                           struct hw_device_t** device)
+{
+    int status = -EINVAL;
+
+    if (!strcmp(name, HWC_HARDWARE_COMPOSER)) {
+        struct hwc_context_t *dev;
+        dev = (hwc_context_t*)malloc(sizeof(*dev));
+        memset(dev, 0, sizeof(*dev));
+
+        //Initialize hwc context
+        initContext(dev);
+
+        //Setup HWC methods
+        dev->device.common.tag          = HARDWARE_DEVICE_TAG;
+        dev->device.common.version      = HWC_DEVICE_API_VERSION_1_3;
+        dev->device.common.module       = const_cast<hw_module_t*>(module);
+        dev->device.common.close        = hwc_device_close;
+        dev->device.prepare             = hwc_prepare;
+        dev->device.set                 = hwc_set;
+        dev->device.eventControl        = hwc_eventControl;
+        dev->device.blank               = hwc_blank;
+        dev->device.query               = hwc_query;
+        dev->device.registerProcs       = hwc_registerProcs;
+        dev->device.dump                = hwc_dump;
+        dev->device.getDisplayConfigs   = hwc_getDisplayConfigs;
+        dev->device.getDisplayAttributes = hwc_getDisplayAttributes;
+        *device = &dev->device.common;
+        status = 0;
+    }
+    return status;
+}
diff --git a/msm8974/libhwcomposer/hwc_ad.cpp b/msm8974/libhwcomposer/hwc_ad.cpp
new file mode 100644
index 0000000..037f931
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_ad.cpp
@@ -0,0 +1,262 @@
+/*
+* Copyright (c) 2013 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation. nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <unistd.h>
+#include <overlay.h>
+#include <overlayUtils.h>
+#include <overlayWriteback.h>
+#include <mdp_version.h>
+#include "hwc_ad.h"
+#include "hwc_utils.h"
+
+#define DEBUG 0
+using namespace overlay;
+using namespace overlay::utils;
+namespace qhwc {
+
+//Opens writeback framebuffer and returns fd.
+static int openWbFb() {
+    int wbFd = -1;
+    //Check opening which FB would connect LM to WB
+    const int wbFbNum = Overlay::getFbForDpy(Overlay::DPY_WRITEBACK);
+    if(wbFbNum >= 0) {
+        char wbFbPath[256];
+        snprintf (wbFbPath, sizeof(wbFbPath),
+                "/sys/class/graphics/fb%d", wbFbNum);
+        //Opening writeback fb first time would create ad node if the device
+        //supports adaptive display
+        wbFd = open(wbFbPath, O_RDONLY);
+        if(wbFd < 0) {
+            ALOGE("%s: Failed to open /sys/class/graphics/fb%d with error %s",
+                    __func__, wbFbNum, strerror(errno));
+        }
+    } else {
+        ALOGD_IF(DEBUG, "%s: No writeback available", __func__);
+    }
+    return wbFd;
+}
+
+static inline void closeWbFb(int& fd) {
+    if(fd >= 0) {
+        close(fd);
+        fd = -1;
+    } else {
+        ALOGE("%s: Invalid fd %d", __func__, fd);
+    }
+}
+
+//Helper to write data to ad node
+static void adWrite(const int& value) {
+    const int wbFbNum = Overlay::getFbForDpy(Overlay::DPY_WRITEBACK);
+    char wbFbPath[256];
+    snprintf (wbFbPath, sizeof(wbFbPath),
+            "/sys/class/graphics/fb%d/ad", wbFbNum);
+    int adFd = open(wbFbPath, O_WRONLY);
+    if(adFd >= 0) {
+        char opStr[4] = "";
+        snprintf(opStr, sizeof(opStr), "%d", value);
+        int ret = write(adFd, opStr, strlen(opStr));
+        if(ret < 0) {
+            ALOGE("%s: Failed to write %d with error %s",
+                    __func__, value, strerror(errno));
+        } else if (ret == 0){
+            ALOGE("%s Nothing written to ad", __func__);
+        } else {
+            ALOGD_IF(DEBUG, "%s: Wrote %d to ad", __func__, value);
+        }
+        close(adFd);
+    } else {
+        ALOGE("%s: Failed to open /sys/class/graphics/fb%d/ad with error %s",
+                __func__, wbFbNum, strerror(errno));
+    }
+}
+
+//Helper to read data from ad node
+static int adRead() {
+    const int wbFbNum = Overlay::getFbForDpy(Overlay::DPY_WRITEBACK);
+    int ret = -1;
+    char wbFbPath[256];
+    snprintf (wbFbPath, sizeof(wbFbPath),
+            "/sys/class/graphics/fb%d/ad", wbFbNum);
+    int adFd = open(wbFbPath, O_RDONLY);
+    if(adFd >= 0) {
+        char opStr[4] = {'\0'};
+        if(read(adFd, opStr, strlen(opStr)) >= 0) {
+            //Should return -1, 0 or 1
+            ret = atoi(opStr);
+            ALOGD_IF(DEBUG, "%s: Read %d from ad", __func__, ret);
+        } else {
+            ALOGE("%s: Read from ad node failed with error %s", __func__,
+                    strerror(errno));
+        }
+        close(adFd);
+    } else {
+        ALOGD("%s: /sys/class/graphics/fb%d/ad could not be opened : %s",
+                __func__, wbFbNum, strerror(errno));
+    }
+    return ret;
+}
+
+AssertiveDisplay::AssertiveDisplay() :mWbFd(-1), mDoable(false),
+        mFeatureEnabled(false), mDest(overlay::utils::OV_INVALID) {
+    int fd = openWbFb();
+    if(fd >= 0) {
+        //-1 means feature is disabled on device
+        // 0 means feature exists but turned off, will be turned on by hwc
+        // 1 means feature is turned on by hwc
+        if(adRead() >= 0) {
+            ALOGD_IF(DEBUG, "Assertive display feature supported");
+            mFeatureEnabled = true;
+        }
+        closeWbFb(fd);
+    }
+}
+
+void AssertiveDisplay::markDoable(hwc_context_t *ctx,
+        const hwc_display_contents_1_t* list) {
+    mDoable = false;
+    if(mFeatureEnabled &&
+        !isSecondaryConnected(ctx) &&
+        ctx->listStats[HWC_DISPLAY_PRIMARY].yuvCount == 1) {
+        int nYuvIndex = ctx->listStats[HWC_DISPLAY_PRIMARY].yuvIndices[0];
+        const hwc_layer_1_t* layer = &list->hwLayers[nYuvIndex];
+        private_handle_t *hnd = (private_handle_t *)layer->handle;
+        if(hnd && hnd->width <= qdutils::MAX_DISPLAY_DIM) {
+            mDoable = true;
+        }
+    }
+}
+
+bool AssertiveDisplay::prepare(hwc_context_t *ctx,
+        const hwc_rect_t& crop,
+        const Whf& whf,
+        const private_handle_t *hnd) {
+    if(!isDoable()) {
+        if(isModeOn()) {
+            //Cleanup one time during this switch
+            const int off = 0;
+            adWrite(off);
+            closeWbFb(mWbFd);
+        }
+        return false;
+    }
+
+    ovutils::eDest dest = ctx->mOverlay->nextPipe(ovutils::OV_MDP_PIPE_VG,
+            overlay::Overlay::DPY_WRITEBACK, Overlay::MIXER_DEFAULT);
+    if(dest == OV_INVALID) {
+        ALOGE("%s failed: No VG pipe available", __func__);
+        mDoable = false;
+        return false;
+    }
+
+    overlay::Writeback *wb = overlay::Writeback::getInstance();
+
+    if(!wb->configureDpyInfo(hnd->width, hnd->height)) {
+        ALOGE("%s: config display failed", __func__);
+        mDoable = false;
+        return false;
+    }
+
+    int tmpW, tmpH, size;
+    int format = ovutils::getHALFormat(wb->getOutputFormat());
+    if(format < 0) {
+        ALOGE("%s invalid format %d", __func__, format);
+        mDoable = false;
+        return false;
+    }
+
+    size = getBufferSizeAndDimensions(hnd->width, hnd->height,
+                format, tmpW, tmpH);
+
+    if(!wb->configureMemory(size, isSecureBuffer(hnd))) {
+        ALOGE("%s: config memory failed", __func__);
+        mDoable = false;
+        return false;
+    }
+
+    eMdpFlags mdpFlags = OV_MDP_FLAGS_NONE;
+    if(isSecureBuffer(hnd)) {
+        ovutils::setMdpFlags(mdpFlags,
+                ovutils::OV_MDP_SECURE_OVERLAY_SESSION);
+    }
+
+    PipeArgs parg(mdpFlags, whf, ZORDER_0, IS_FG_OFF,
+            ROT_FLAGS_NONE,
+            ovutils::DEFAULT_PLANE_ALPHA,
+            ovutils::OVERLAY_BLENDING_OPAQUE);
+    hwc_rect_t dst = crop; //input same as output
+
+    if(configMdp(ctx->mOverlay, parg, OVERLAY_TRANSFORM_0, crop, dst, NULL,
+                dest) < 0) {
+        ALOGE("%s: configMdp failed", __func__);
+        mDoable = false;
+        return false;
+    }
+
+    mDest = dest;
+    if(!isModeOn()) {
+        mWbFd = openWbFb();
+        if(mWbFd >= 0) {
+            //write to sysfs, one time during this switch
+            const int on = 1;
+            adWrite(on);
+        }
+    }
+    return true;
+}
+
+bool AssertiveDisplay::draw(hwc_context_t *ctx, int fd, uint32_t offset) {
+    if(!isDoable() || !isModeOn()) {
+        return false;
+    }
+
+    if (!ctx->mOverlay->queueBuffer(fd, offset, mDest)) {
+        ALOGE("%s: queueBuffer failed", __func__);
+        return false;
+    }
+
+    overlay::Writeback *wb = overlay::Writeback::getInstance();
+    if(!wb->writeSync()) {
+        return false;
+    }
+
+    return true;
+}
+
+int AssertiveDisplay::getDstFd(hwc_context_t *ctx) const {
+    overlay::Writeback *wb = overlay::Writeback::getInstance();
+    return wb->getDstFd();
+}
+
+uint32_t AssertiveDisplay::getDstOffset(hwc_context_t *ctx) const {
+    overlay::Writeback *wb = overlay::Writeback::getInstance();
+    return wb->getOffset();
+}
+
+}
diff --git a/msm8974/libhwcomposer/hwc_ad.h b/msm8974/libhwcomposer/hwc_ad.h
new file mode 100644
index 0000000..38b724d
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_ad.h
@@ -0,0 +1,67 @@
+/*
+* Copyright (c) 2013 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation. nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef HWC_AD_H
+#define HWC_AD_H
+
+#include <overlayUtils.h>
+#include <hwc_utils.h>
+
+struct hwc_context_t;
+
+namespace qhwc {
+
+class AssertiveDisplay {
+public:
+    AssertiveDisplay();
+    void markDoable(hwc_context_t *ctx, const hwc_display_contents_1_t* list);
+    bool prepare(hwc_context_t *ctx, const hwc_rect_t& crop,
+            const overlay::utils::Whf& whf,
+            const private_handle_t *hnd);
+    bool draw(hwc_context_t *ctx, int fd, uint32_t offset);
+    //Resets a few members on each draw round
+    void reset() { mDoable = false;
+            mDest = overlay::utils::OV_INVALID;
+    }
+    bool isDoable() const { return mDoable; }
+    bool isModeOn() const { return (mWbFd >= 0); }
+    int getDstFd(hwc_context_t *ctx) const;
+    uint32_t getDstOffset(hwc_context_t *ctx) const;
+
+private:
+    //State of feature turned on and off
+    int mWbFd;
+    bool mDoable;
+    //State of feature existence on certain devices and configs.
+    bool mFeatureEnabled;
+    overlay::utils::eDest mDest;
+};
+
+}
+#endif
diff --git a/msm8974/libhwcomposer/hwc_copybit.cpp b/msm8974/libhwcomposer/hwc_copybit.cpp
new file mode 100644
index 0000000..0dcc328
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_copybit.cpp
@@ -0,0 +1,637 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define DEBUG_COPYBIT 0
+#include <sync/sync.h>
+#include <copybit.h>
+#include <utils/Timers.h>
+#include <mdp_version.h>
+#include "hwc_copybit.h"
+#include "comptype.h"
+#include "gr.h"
+
+namespace qhwc {
+
+struct range {
+    int current;
+    int end;
+};
+struct region_iterator : public copybit_region_t {
+
+    region_iterator(hwc_region_t region) {
+        mRegion = region;
+        r.end = region.numRects;
+        r.current = 0;
+        this->next = iterate;
+    }
+
+private:
+    static int iterate(copybit_region_t const * self, copybit_rect_t* rect){
+        if (!self || !rect) {
+            ALOGE("iterate invalid parameters");
+            return 0;
+        }
+
+        region_iterator const* me =
+                                  static_cast<region_iterator const*>(self);
+        if (me->r.current != me->r.end) {
+            rect->l = me->mRegion.rects[me->r.current].left;
+            rect->t = me->mRegion.rects[me->r.current].top;
+            rect->r = me->mRegion.rects[me->r.current].right;
+            rect->b = me->mRegion.rects[me->r.current].bottom;
+            me->r.current++;
+            return 1;
+        }
+        return 0;
+    }
+
+    hwc_region_t mRegion;
+    mutable range r;
+};
+
+void CopyBit::reset() {
+    mIsModeOn = false;
+    mCopyBitDraw = false;
+}
+
+bool CopyBit::canUseCopybitForYUV(hwc_context_t *ctx) {
+    // return true for non-overlay targets
+    if(ctx->mMDP.hasOverlay && ctx->mMDP.version >= qdutils::MDP_V4_0) {
+       return false;
+    }
+    return true;
+}
+
+bool CopyBit::canUseCopybitForRGB(hwc_context_t *ctx,
+                                        hwc_display_contents_1_t *list,
+                                        int dpy) {
+    int compositionType = qdutils::QCCompositionType::
+                                    getInstance().getCompositionType();
+
+    if (compositionType & qdutils::COMPOSITION_TYPE_DYN) {
+        // DYN Composition:
+        // use copybit, if (TotalRGBRenderArea < threashold * FB Area)
+        // this is done based on perf inputs in ICS
+        // TODO: Above condition needs to be re-evaluated in JB
+        int fbWidth =  ctx->dpyAttr[dpy].xres;
+        int fbHeight =  ctx->dpyAttr[dpy].yres;
+        unsigned int fbArea = (fbWidth * fbHeight);
+        unsigned int renderArea = getRGBRenderingArea(list);
+            ALOGD_IF (DEBUG_COPYBIT, "%s:renderArea %u, fbArea %u",
+                                  __FUNCTION__, renderArea, fbArea);
+        if (renderArea < (mDynThreshold * fbArea)) {
+            return true;
+        }
+    } else if ((compositionType & qdutils::COMPOSITION_TYPE_MDP)) {
+      // MDP composition, use COPYBIT always
+      return true;
+    } else if ((compositionType & qdutils::COMPOSITION_TYPE_C2D)) {
+      // C2D composition, use COPYBIT
+      return true;
+    }
+    return false;
+}
+
+unsigned int CopyBit::getRGBRenderingArea
+                                    (const hwc_display_contents_1_t *list) {
+    //Calculates total rendering area for RGB layers
+    unsigned int renderArea = 0;
+    unsigned int w=0, h=0;
+    // Skipping last layer since FrameBuffer layer should not affect
+    // which composition to choose
+    for (unsigned int i=0; i<list->numHwLayers -1; i++) {
+         private_handle_t *hnd = (private_handle_t *)list->hwLayers[i].handle;
+         if (hnd) {
+             if (BUFFER_TYPE_UI == hnd->bufferType) {
+                 getLayerResolution(&list->hwLayers[i], w, h);
+                 renderArea += (w*h);
+             }
+         }
+    }
+    return renderArea;
+}
+
+bool CopyBit::prepare(hwc_context_t *ctx, hwc_display_contents_1_t *list,
+                                                            int dpy) {
+
+    if(mEngine == NULL) {
+        // No copybit device found - cannot use copybit
+        return false;
+    }
+    int compositionType = qdutils::QCCompositionType::
+                                    getInstance().getCompositionType();
+
+    if ((compositionType == qdutils::COMPOSITION_TYPE_GPU) ||
+        (compositionType == qdutils::COMPOSITION_TYPE_CPU))   {
+        //GPU/CPU composition, don't change layer composition type
+        return true;
+    }
+
+    if(!(validateParams(ctx, list))) {
+        ALOGE("%s:Invalid Params", __FUNCTION__);
+        return false;
+    }
+
+    if(ctx->listStats[dpy].skipCount) {
+        //GPU will be anyways used
+        return false;
+    }
+
+    if (ctx->listStats[dpy].numAppLayers > MAX_NUM_APP_LAYERS) {
+        // Reached max layers supported by HWC.
+        return false;
+    }
+
+    bool useCopybitForYUV = canUseCopybitForYUV(ctx);
+    bool useCopybitForRGB = canUseCopybitForRGB(ctx, list, dpy);
+    LayerProp *layerProp = ctx->layerProp[dpy];
+    size_t fbLayerIndex = ctx->listStats[dpy].fbLayerIndex;
+    hwc_layer_1_t *fbLayer = &list->hwLayers[fbLayerIndex];
+    private_handle_t *fbHnd = (private_handle_t *)fbLayer->handle;
+
+
+    // Following are MDP3 limitations for which we
+    // need to fallback to GPU composition:
+    // 1. HW issues with mdp3 and rotation.
+    // 2. Plane alpha is not supported by MDP3.
+    if (qdutils::MDPVersion::getInstance().getMDPVersion() < 400) {
+        for (int i = ctx->listStats[dpy].numAppLayers-1; i >= 0 ; i--) {
+            hwc_layer_1_t *layer = (hwc_layer_1_t *) &list->hwLayers[i];
+            if ((layer->transform & (HAL_TRANSFORM_FLIP_H |
+                   HAL_TRANSFORM_FLIP_V | HAL_TRANSFORM_ROT_90)) &&
+                   ((layer->displayFrame.bottom - layer->displayFrame.top) % 16 ||
+                   (layer->displayFrame.right - layer->displayFrame.left) % 16))
+                return true;
+            if (layer->planeAlpha != 0xFF)
+                return true;
+        }
+    }
+
+    //Allocate render buffers if they're not allocated
+    if (useCopybitForYUV || useCopybitForRGB) {
+        int ret = allocRenderBuffers(fbHnd->width,
+                                     fbHnd->height,
+                                     fbHnd->format);
+        if (ret < 0) {
+            return false;
+        } else {
+            mCurRenderBufferIndex = (mCurRenderBufferIndex + 1) %
+                NUM_RENDER_BUFFERS;
+        }
+    }
+
+    // We cannot mix copybit layer with layers marked to be drawn on FB
+    if (!useCopybitForYUV && ctx->listStats[dpy].yuvCount)
+        return true;
+
+    // numAppLayers-1, as we iterate till 0th layer index
+    for (int i = ctx->listStats[dpy].numAppLayers-1; i >= 0 ; i--) {
+        private_handle_t *hnd = (private_handle_t *)list->hwLayers[i].handle;
+
+        if ((hnd->bufferType == BUFFER_TYPE_VIDEO && useCopybitForYUV) ||
+            (hnd->bufferType == BUFFER_TYPE_UI && useCopybitForRGB)) {
+            layerProp[i].mFlags |= HWC_COPYBIT;
+            list->hwLayers[i].compositionType = HWC_OVERLAY;
+            mCopyBitDraw = true;
+        } else {
+            // We currently cannot mix copybit layers with layers marked to
+            // be drawn on the framebuffer or that are on the layer cache.
+            mCopyBitDraw = false;
+            //There is no need to reset layer properties here as we return in
+            //draw if mCopyBitDraw is false
+            break;
+        }
+    }
+    return true;
+}
+
+int CopyBit::clear (private_handle_t* hnd, hwc_rect_t& rect)
+{
+    int ret = 0;
+    copybit_rect_t clear_rect = {rect.left, rect.top,
+        rect.right,
+        rect.bottom};
+
+    copybit_image_t buf;
+    buf.w = ALIGN(getWidth(hnd),32);
+    buf.h = getHeight(hnd);
+    buf.format = hnd->format;
+    buf.base = (void *)hnd->base;
+    buf.handle = (native_handle_t *)hnd;
+
+    copybit_device_t *copybit = mEngine;
+    ret = copybit->clear(copybit, &buf, &clear_rect);
+    return ret;
+}
+
+bool CopyBit::draw(hwc_context_t *ctx, hwc_display_contents_1_t *list,
+                                                        int dpy, int32_t *fd) {
+    // draw layers marked for COPYBIT
+    int retVal = true;
+    int copybitLayerCount = 0;
+    LayerProp *layerProp = ctx->layerProp[dpy];
+
+    if(mCopyBitDraw == false) // there is no layer marked for copybit
+        return false ;
+
+    //render buffer
+    private_handle_t *renderBuffer = getCurrentRenderBuffer();
+    if (!renderBuffer) {
+        ALOGE("%s: Render buffer layer handle is NULL", __FUNCTION__);
+        return false;
+    }
+
+    //Wait for the previous frame to complete before rendering onto it
+    if(mRelFd[0] >=0) {
+        sync_wait(mRelFd[0], 1000);
+        close(mRelFd[0]);
+        mRelFd[0] = -1;
+    }
+
+    if (ctx->mMDP.version >= qdutils::MDP_V4_0) {
+        //Clear the visible region on the render buffer
+        //XXX: Do this only when needed.
+        hwc_rect_t clearRegion;
+        getNonWormholeRegion(list, clearRegion);
+        clear(renderBuffer, clearRegion);
+    }
+    // numAppLayers-1, as we iterate from 0th layer index with HWC_COPYBIT flag
+    for (int i = 0; i <= (ctx->listStats[dpy].numAppLayers-1); i++) {
+        if(!(layerProp[i].mFlags & HWC_COPYBIT)) {
+            ALOGD_IF(DEBUG_COPYBIT, "%s: Not Marked for copybit", __FUNCTION__);
+            continue;
+        }
+        int ret = -1;
+        if (list->hwLayers[i].acquireFenceFd != -1
+                && ctx->mMDP.version >= qdutils::MDP_V4_0) {
+            // Wait for acquire Fence on the App buffers.
+            ret = sync_wait(list->hwLayers[i].acquireFenceFd, 1000);
+            if(ret < 0) {
+                ALOGE("%s: sync_wait error!! error no = %d err str = %s",
+                                    __FUNCTION__, errno, strerror(errno));
+            }
+            close(list->hwLayers[i].acquireFenceFd);
+            list->hwLayers[i].acquireFenceFd = -1;
+        }
+        retVal = drawLayerUsingCopybit(ctx, &(list->hwLayers[i]),
+                                                    renderBuffer, dpy, !i);
+        copybitLayerCount++;
+        if(retVal < 0) {
+            ALOGE("%s : drawLayerUsingCopybit failed", __FUNCTION__);
+        }
+    }
+
+    if (copybitLayerCount) {
+        copybit_device_t *copybit = getCopyBitDevice();
+        // Async mode
+        copybit->flush_get_fence(copybit, fd);
+    }
+    return true;
+}
+
+int  CopyBit::drawLayerUsingCopybit(hwc_context_t *dev, hwc_layer_1_t *layer,
+                          private_handle_t *renderBuffer, int dpy, bool isFG)
+{
+    hwc_context_t* ctx = (hwc_context_t*)(dev);
+    int err = 0, acquireFd;
+    if(!ctx) {
+         ALOGE("%s: null context ", __FUNCTION__);
+         return -1;
+    }
+
+    private_handle_t *hnd = (private_handle_t *)layer->handle;
+    if(!hnd) {
+        ALOGE("%s: invalid handle", __FUNCTION__);
+        return -1;
+    }
+
+    private_handle_t *fbHandle = (private_handle_t *)renderBuffer;
+    if(!fbHandle) {
+        ALOGE("%s: Framebuffer handle is NULL", __FUNCTION__);
+        return -1;
+    }
+
+    // Set the copybit source:
+    copybit_image_t src;
+    src.w = getWidth(hnd);
+    src.h = getHeight(hnd);
+    src.format = hnd->format;
+    src.base = (void *)hnd->base;
+    src.handle = (native_handle_t *)layer->handle;
+    src.horiz_padding = src.w - getWidth(hnd);
+    // Initialize vertical padding to zero for now,
+    // this needs to change to accomodate vertical stride
+    // if needed in the future
+    src.vert_padding = 0;
+
+    // Copybit source rect
+    hwc_rect_t sourceCrop = integerizeSourceCrop(layer->sourceCropf);
+    copybit_rect_t srcRect = {sourceCrop.left, sourceCrop.top,
+                              sourceCrop.right,
+                              sourceCrop.bottom};
+
+    // Copybit destination rect
+    hwc_rect_t displayFrame = layer->displayFrame;
+    copybit_rect_t dstRect = {displayFrame.left, displayFrame.top,
+                              displayFrame.right,
+                              displayFrame.bottom};
+
+    // Copybit dst
+    copybit_image_t dst;
+    dst.w = ALIGN(fbHandle->width,32);
+    dst.h = fbHandle->height;
+    dst.format = fbHandle->format;
+    dst.base = (void *)fbHandle->base;
+    dst.handle = (native_handle_t *)fbHandle;
+
+    copybit_device_t *copybit = mEngine;
+
+    int32_t screen_w        = displayFrame.right - displayFrame.left;
+    int32_t screen_h        = displayFrame.bottom - displayFrame.top;
+    int32_t src_crop_width  = sourceCrop.right - sourceCrop.left;
+    int32_t src_crop_height = sourceCrop.bottom -sourceCrop.top;
+
+    // Copybit dst
+    float copybitsMaxScale =
+                      (float)copybit->get(copybit,COPYBIT_MAGNIFICATION_LIMIT);
+    float copybitsMinScale =
+                       (float)copybit->get(copybit,COPYBIT_MINIFICATION_LIMIT);
+
+    if((layer->transform == HWC_TRANSFORM_ROT_90) ||
+                           (layer->transform == HWC_TRANSFORM_ROT_270)) {
+        //swap screen width and height
+        int tmp = screen_w;
+        screen_w  = screen_h;
+        screen_h = tmp;
+    }
+    private_handle_t *tmpHnd = NULL;
+
+    if(screen_w <=0 || screen_h<=0 ||src_crop_width<=0 || src_crop_height<=0 ) {
+        ALOGE("%s: wrong params for display screen_w=%d src_crop_width=%d \
+        screen_w=%d src_crop_width=%d", __FUNCTION__, screen_w,
+                                src_crop_width,screen_w,src_crop_width);
+        return -1;
+    }
+
+    float dsdx = (float)screen_w/src_crop_width;
+    float dtdy = (float)screen_h/src_crop_height;
+
+    float scaleLimitMax = copybitsMaxScale * copybitsMaxScale;
+    float scaleLimitMin = copybitsMinScale * copybitsMinScale;
+    if(dsdx > scaleLimitMax ||
+        dtdy > scaleLimitMax ||
+        dsdx < 1/scaleLimitMin ||
+        dtdy < 1/scaleLimitMin) {
+        ALOGE("%s: greater than max supported size dsdx=%f dtdy=%f \
+              scaleLimitMax=%f scaleLimitMin=%f", __FUNCTION__,dsdx,dtdy,
+                                          scaleLimitMax,1/scaleLimitMin);
+        return -1;
+    }
+    acquireFd = layer->acquireFenceFd;
+    if(dsdx > copybitsMaxScale ||
+        dtdy > copybitsMaxScale ||
+        dsdx < 1/copybitsMinScale ||
+        dtdy < 1/copybitsMinScale){
+        // The requested scale is out of the range the hardware
+        // can support.
+       ALOGD("%s:%d::Need to scale twice dsdx=%f, dtdy=%f,copybitsMaxScale=%f,\
+                                 copybitsMinScale=%f,screen_w=%d,screen_h=%d \
+                  src_crop_width=%d src_crop_height=%d",__FUNCTION__,__LINE__,
+              dsdx,dtdy,copybitsMaxScale,1/copybitsMinScale,screen_w,screen_h,
+                                              src_crop_width,src_crop_height);
+
+       //Driver makes width and height as even
+       //that may cause wrong calculation of the ratio
+       //in display and crop.Hence we make
+       //crop width and height as even.
+       src_crop_width  = (src_crop_width/2)*2;
+       src_crop_height = (src_crop_height/2)*2;
+
+       int tmp_w =  src_crop_width;
+       int tmp_h =  src_crop_height;
+
+       if (dsdx > copybitsMaxScale || dtdy > copybitsMaxScale ){
+         tmp_w = src_crop_width*copybitsMaxScale;
+         tmp_h = src_crop_height*copybitsMaxScale;
+       }else if (dsdx < 1/copybitsMinScale ||dtdy < 1/copybitsMinScale ){
+         tmp_w = src_crop_width/copybitsMinScale;
+         tmp_h = src_crop_height/copybitsMinScale;
+         tmp_w  = (tmp_w/2)*2;
+         tmp_h = (tmp_h/2)*2;
+       }
+       ALOGD("%s:%d::tmp_w = %d,tmp_h = %d",__FUNCTION__,__LINE__,tmp_w,tmp_h);
+
+       int usage = GRALLOC_USAGE_PRIVATE_IOMMU_HEAP;
+       int format = fbHandle->format;
+
+       // We do not want copybit to generate alpha values from nothing
+       if (format == HAL_PIXEL_FORMAT_RGBA_8888 &&
+               src.format != HAL_PIXEL_FORMAT_RGBA_8888) {
+           format = HAL_PIXEL_FORMAT_RGBX_8888;
+       }
+       if (0 == alloc_buffer(&tmpHnd, tmp_w, tmp_h, format, usage)){
+            copybit_image_t tmp_dst;
+            copybit_rect_t tmp_rect;
+            tmp_dst.w = tmp_w;
+            tmp_dst.h = tmp_h;
+            tmp_dst.format = tmpHnd->format;
+            tmp_dst.handle = tmpHnd;
+            tmp_dst.horiz_padding = src.horiz_padding;
+            tmp_dst.vert_padding = src.vert_padding;
+            tmp_rect.l = 0;
+            tmp_rect.t = 0;
+            tmp_rect.r = tmp_dst.w;
+            tmp_rect.b = tmp_dst.h;
+            //create one clip region
+            hwc_rect tmp_hwc_rect = {0,0,tmp_rect.r,tmp_rect.b};
+            hwc_region_t tmp_hwc_reg = {1,(hwc_rect_t const*)&tmp_hwc_rect};
+            region_iterator tmp_it(tmp_hwc_reg);
+            copybit->set_parameter(copybit,COPYBIT_TRANSFORM,0);
+            //TODO: once, we are able to read layer alpha, update this
+            copybit->set_parameter(copybit, COPYBIT_PLANE_ALPHA, 255);
+            copybit->set_sync(copybit, acquireFd);
+            err = copybit->stretch(copybit,&tmp_dst, &src, &tmp_rect,
+                                                           &srcRect, &tmp_it);
+            if(err < 0){
+                ALOGE("%s:%d::tmp copybit stretch failed",__FUNCTION__,
+                                                             __LINE__);
+                if(tmpHnd)
+                    free_buffer(tmpHnd);
+                return err;
+            }
+            // use release fence as aquire fd for next stretch
+            if (ctx->mMDP.version < qdutils::MDP_V4_0) {
+                copybit->flush_get_fence(copybit, &acquireFd);
+                close(acquireFd);
+                acquireFd = -1;
+            }
+            // copy new src and src rect crop
+            src = tmp_dst;
+            srcRect = tmp_rect;
+      }
+    }
+    // Copybit region
+    hwc_region_t region = layer->visibleRegionScreen;
+    region_iterator copybitRegion(region);
+
+    copybit->set_parameter(copybit, COPYBIT_FRAMEBUFFER_WIDTH,
+                                          renderBuffer->width);
+    copybit->set_parameter(copybit, COPYBIT_FRAMEBUFFER_HEIGHT,
+                                          renderBuffer->height);
+    copybit->set_parameter(copybit, COPYBIT_TRANSFORM,
+                                              layer->transform);
+    //TODO: once, we are able to read layer alpha, update this
+    copybit->set_parameter(copybit, COPYBIT_PLANE_ALPHA, 255);
+    copybit->set_parameter(copybit, COPYBIT_BLEND_MODE,
+                                              layer->blending);
+    copybit->set_parameter(copybit, COPYBIT_DITHER,
+                             (dst.format == HAL_PIXEL_FORMAT_RGB_565)?
+                                             COPYBIT_ENABLE : COPYBIT_DISABLE);
+    copybit->set_parameter(copybit, COPYBIT_FG_LAYER, isFG ?
+                                             COPYBIT_ENABLE : COPYBIT_DISABLE);
+
+    copybit->set_parameter(copybit, COPYBIT_BLIT_TO_FRAMEBUFFER,
+                                                COPYBIT_ENABLE);
+    copybit->set_sync(copybit, acquireFd);
+    err = copybit->stretch(copybit, &dst, &src, &dstRect, &srcRect,
+                                                   &copybitRegion);
+    copybit->set_parameter(copybit, COPYBIT_BLIT_TO_FRAMEBUFFER,
+                                               COPYBIT_DISABLE);
+
+    if(tmpHnd) {
+        if (ctx->mMDP.version < qdutils::MDP_V4_0){
+            int ret = -1, releaseFd;
+            // we need to wait for the buffer before freeing
+            copybit->flush_get_fence(copybit, &releaseFd);
+            ret = sync_wait(releaseFd, 1000);
+            if(ret < 0) {
+                ALOGE("%s: sync_wait error!! error no = %d err str = %s",
+                    __FUNCTION__, errno, strerror(errno));
+            }
+            close(releaseFd);
+        }
+        free_buffer(tmpHnd);
+    }
+
+    if(err < 0)
+        ALOGE("%s: copybit stretch failed",__FUNCTION__);
+    return err;
+}
+
+void CopyBit::getLayerResolution(const hwc_layer_1_t* layer,
+                                 unsigned int& width, unsigned int& height)
+{
+    hwc_rect_t displayFrame  = layer->displayFrame;
+
+    width = displayFrame.right - displayFrame.left;
+    height = displayFrame.bottom - displayFrame.top;
+}
+
+bool CopyBit::validateParams(hwc_context_t *ctx,
+                                        const hwc_display_contents_1_t *list) {
+    //Validate parameters
+    if (!ctx) {
+        ALOGE("%s:Invalid HWC context", __FUNCTION__);
+        return false;
+    } else if (!list) {
+        ALOGE("%s:Invalid HWC layer list", __FUNCTION__);
+        return false;
+    }
+    return true;
+}
+
+
+int CopyBit::allocRenderBuffers(int w, int h, int f)
+{
+    int ret = 0;
+    for (int i = 0; i < NUM_RENDER_BUFFERS; i++) {
+        if (mRenderBuffer[i] == NULL) {
+            ret = alloc_buffer(&mRenderBuffer[i],
+                               w, h, f,
+                               GRALLOC_USAGE_PRIVATE_IOMMU_HEAP);
+        }
+        if(ret < 0) {
+            freeRenderBuffers();
+            break;
+        }
+    }
+    return ret;
+}
+
+void CopyBit::freeRenderBuffers()
+{
+    for (int i = 0; i < NUM_RENDER_BUFFERS; i++) {
+        if(mRenderBuffer[i]) {
+            free_buffer(mRenderBuffer[i]);
+            mRenderBuffer[i] = NULL;
+        }
+    }
+}
+
+private_handle_t * CopyBit::getCurrentRenderBuffer() {
+    return mRenderBuffer[mCurRenderBufferIndex];
+}
+
+void CopyBit::setReleaseFd(int fd) {
+    if(mRelFd[0] >=0)
+        close(mRelFd[0]);
+    mRelFd[0] = mRelFd[1];
+    mRelFd[1] = dup(fd);
+}
+
+struct copybit_device_t* CopyBit::getCopyBitDevice() {
+    return mEngine;
+}
+
+CopyBit::CopyBit():mIsModeOn(false), mCopyBitDraw(false),
+    mCurRenderBufferIndex(0){
+    hw_module_t const *module;
+    for (int i = 0; i < NUM_RENDER_BUFFERS; i++)
+        mRenderBuffer[i] = NULL;
+    mRelFd[0] = -1;
+    mRelFd[1] = -1;
+
+    char value[PROPERTY_VALUE_MAX];
+    property_get("debug.hwc.dynThreshold", value, "2");
+    mDynThreshold = atof(value);
+
+    if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
+        if(copybit_open(module, &mEngine) < 0) {
+            ALOGE("FATAL ERROR: copybit open failed.");
+        }
+    } else {
+        ALOGE("FATAL ERROR: copybit hw module not found");
+    }
+}
+
+CopyBit::~CopyBit()
+{
+    freeRenderBuffers();
+    if(mRelFd[0] >=0)
+        close(mRelFd[0]);
+    if(mRelFd[1] >=0)
+        close(mRelFd[1]);
+    if(mEngine)
+    {
+        copybit_close(mEngine);
+        mEngine = NULL;
+    }
+}
+}; //namespace qhwc
diff --git a/msm8974/libhwcomposer/hwc_copybit.h b/msm8974/libhwcomposer/hwc_copybit.h
new file mode 100644
index 0000000..03fe950
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_copybit.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef HWC_COPYBIT_H
+#define HWC_COPYBIT_H
+#include "hwc_utils.h"
+
+#define NUM_RENDER_BUFFERS 3
+
+namespace qhwc {
+
+class CopyBit {
+public:
+    CopyBit();
+    ~CopyBit();
+    // API to get copybit engine(non static)
+    struct copybit_device_t *getCopyBitDevice();
+    //Sets up members and prepares copybit if conditions are met
+    bool prepare(hwc_context_t *ctx, hwc_display_contents_1_t *list,
+                                                                   int dpy);
+    //Draws layer if the layer is set for copybit in prepare
+    bool draw(hwc_context_t *ctx, hwc_display_contents_1_t *list,
+                                                        int dpy, int* fd);
+    // resets the values
+    void reset();
+
+    private_handle_t * getCurrentRenderBuffer();
+
+    void setReleaseFd(int fd);
+
+private:
+    // holds the copybit device
+    struct copybit_device_t *mEngine;
+    // Helper functions for copybit composition
+    int  drawLayerUsingCopybit(hwc_context_t *dev, hwc_layer_1_t *layer,
+                          private_handle_t *renderBuffer, int dpy, bool isFG);
+    bool canUseCopybitForYUV (hwc_context_t *ctx);
+    bool canUseCopybitForRGB (hwc_context_t *ctx,
+                                     hwc_display_contents_1_t *list, int dpy);
+    bool validateParams (hwc_context_t *ctx,
+                                const hwc_display_contents_1_t *list);
+    //Flags if this feature is on.
+    bool mIsModeOn;
+    // flag that indicates whether CopyBit composition is enabled for this cycle
+    bool mCopyBitDraw;
+
+    unsigned int getRGBRenderingArea
+                            (const hwc_display_contents_1_t *list);
+
+    void getLayerResolution(const hwc_layer_1_t* layer,
+                                   unsigned int &width, unsigned int& height);
+
+    int allocRenderBuffers(int w, int h, int f);
+
+    void freeRenderBuffers();
+
+    int clear (private_handle_t* hnd, hwc_rect_t& rect);
+
+    private_handle_t* mRenderBuffer[NUM_RENDER_BUFFERS];
+
+    // Index of the current intermediate render buffer
+    int mCurRenderBufferIndex;
+
+    //These are the the release FDs of the T-2 and T-1 round
+    //We wait on the T-2 fence
+    int mRelFd[2];
+
+    //Dynamic composition threshold for deciding copybit usage.
+    double mDynThreshold;
+};
+
+}; //namespace qhwc
+
+#endif //HWC_COPYBIT_H
diff --git a/msm8974/libhwcomposer/hwc_fbupdate.cpp b/msm8974/libhwcomposer/hwc_fbupdate.cpp
new file mode 100644
index 0000000..9ede498
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_fbupdate.cpp
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define DEBUG_FBUPDATE 0
+#include <gralloc_priv.h>
+#include <overlay.h>
+#include "hwc_fbupdate.h"
+#include "mdp_version.h"
+
+using namespace qdutils;
+using namespace overlay;
+
+namespace qhwc {
+
+namespace ovutils = overlay::utils;
+
+IFBUpdate* IFBUpdate::getObject(const int& width, const int& rightSplit,
+        const int& dpy) {
+    if(width > MAX_DISPLAY_DIM || rightSplit) {
+        return new FBUpdateHighRes(dpy);
+    }
+    return new FBUpdateLowRes(dpy);
+}
+
+inline void IFBUpdate::reset() {
+    mModeOn = false;
+}
+
+//================= Low res====================================
+FBUpdateLowRes::FBUpdateLowRes(const int& dpy): IFBUpdate(dpy) {}
+
+inline void FBUpdateLowRes::reset() {
+    IFBUpdate::reset();
+    mDest = ovutils::OV_INVALID;
+}
+
+bool FBUpdateLowRes::prepare(hwc_context_t *ctx, hwc_display_contents_1 *list,
+                             int fbZorder) {
+    if(!ctx->mMDP.hasOverlay) {
+        ALOGD_IF(DEBUG_FBUPDATE, "%s, this hw doesnt support overlays",
+                 __FUNCTION__);
+        return false;
+    }
+    mModeOn = configure(ctx, list, fbZorder);
+    return mModeOn;
+}
+
+// Configure
+bool FBUpdateLowRes::configure(hwc_context_t *ctx, hwc_display_contents_1 *list,
+                               int fbZorder) {
+    bool ret = false;
+    hwc_layer_1_t *layer = &list->hwLayers[list->numHwLayers - 1];
+    if (LIKELY(ctx->mOverlay)) {
+        overlay::Overlay& ov = *(ctx->mOverlay);
+        hwc_rect_t displayFrame = layer->displayFrame;
+        int alignedWidth = 0;
+        int alignedHeight = 0;
+
+        getBufferSizeAndDimensions(displayFrame.right - displayFrame.left,
+                displayFrame.bottom - displayFrame.top,
+                HAL_PIXEL_FORMAT_RGBA_8888,
+                alignedWidth,
+                alignedHeight);
+
+        ovutils::Whf info(alignedWidth,
+                alignedHeight,
+                ovutils::getMdpFormat(HAL_PIXEL_FORMAT_RGBA_8888));
+
+        //Request a pipe
+        ovutils::eMdpPipeType type = ovutils::OV_MDP_PIPE_ANY;
+        if(qdutils::MDPVersion::getInstance().is8x26() && mDpy) {
+            //For 8x26 external always use DMA pipe
+            type = ovutils::OV_MDP_PIPE_DMA;
+        }
+        ovutils::eDest dest = ov.nextPipe(type, mDpy, Overlay::MIXER_DEFAULT);
+        if(dest == ovutils::OV_INVALID) { //None available
+            ALOGE("%s: No pipes available to configure framebuffer",
+                __FUNCTION__);
+            return false;
+        }
+
+        mDest = dest;
+
+        ovutils::eMdpFlags mdpFlags = ovutils::OV_MDP_BLEND_FG_PREMULT;
+
+        ovutils::eZorder zOrder = static_cast<ovutils::eZorder>(fbZorder);
+
+        //XXX: FB layer plane alpha is currently sent as zero from
+        //surfaceflinger
+        ovutils::PipeArgs parg(mdpFlags,
+                info,
+                zOrder,
+                ovutils::IS_FG_OFF,
+                ovutils::ROT_FLAGS_NONE,
+                ovutils::DEFAULT_PLANE_ALPHA,
+                (ovutils::eBlending) getBlending(layer->blending));
+        ov.setSource(parg, dest);
+
+        hwc_rect_t sourceCrop;
+        getNonWormholeRegion(list, sourceCrop);
+        // x,y,w,h
+        ovutils::Dim dcrop(sourceCrop.left, sourceCrop.top,
+                           sourceCrop.right - sourceCrop.left,
+                           sourceCrop.bottom - sourceCrop.top);
+        ov.setCrop(dcrop, dest);
+
+        int transform = layer->transform;
+        ovutils::eTransform orient =
+            static_cast<ovutils::eTransform>(transform);
+        ov.setTransform(orient, dest);
+
+        if(!qdutils::MDPVersion::getInstance().is8x26()) {
+            getNonWormholeRegion(list, sourceCrop);
+        }
+
+        displayFrame = sourceCrop;
+        ovutils::Dim dpos(displayFrame.left,
+                          displayFrame.top,
+                          displayFrame.right - displayFrame.left,
+                          displayFrame.bottom - displayFrame.top);
+
+        if(mDpy && !qdutils::MDPVersion::getInstance().is8x26())
+            // Calculate the actionsafe dimensions for External(dpy = 1 or 2)
+            getActionSafePosition(ctx, mDpy, dpos.x, dpos.y, dpos.w, dpos.h);
+        ov.setPosition(dpos, dest);
+
+        ret = true;
+        if (!ov.commit(dest)) {
+            ALOGE("%s: commit fails", __FUNCTION__);
+            ret = false;
+        }
+    }
+    return ret;
+}
+
+bool FBUpdateLowRes::draw(hwc_context_t *ctx, private_handle_t *hnd)
+{
+    if(!mModeOn) {
+        return true;
+    }
+    bool ret = true;
+    overlay::Overlay& ov = *(ctx->mOverlay);
+    ovutils::eDest dest = mDest;
+    if (!ov.queueBuffer(hnd->fd, hnd->offset, dest)) {
+        ALOGE("%s: queueBuffer failed for FBUpdate", __FUNCTION__);
+        ret = false;
+    }
+    return ret;
+}
+
+//================= High res====================================
+FBUpdateHighRes::FBUpdateHighRes(const int& dpy): IFBUpdate(dpy) {}
+
+inline void FBUpdateHighRes::reset() {
+    IFBUpdate::reset();
+    mDestLeft = ovutils::OV_INVALID;
+    mDestRight = ovutils::OV_INVALID;
+}
+
+bool FBUpdateHighRes::prepare(hwc_context_t *ctx, hwc_display_contents_1 *list,
+                              int fbZorder) {
+    if(!ctx->mMDP.hasOverlay) {
+        ALOGD_IF(DEBUG_FBUPDATE, "%s, this hw doesnt support overlays",
+                 __FUNCTION__);
+        return false;
+    }
+    ALOGD_IF(DEBUG_FBUPDATE, "%s, mModeOn = %d", __FUNCTION__, mModeOn);
+    mModeOn = configure(ctx, list, fbZorder);
+    return mModeOn;
+}
+
+// Configure
+bool FBUpdateHighRes::configure(hwc_context_t *ctx,
+        hwc_display_contents_1 *list, int fbZorder) {
+    bool ret = false;
+    hwc_layer_1_t *layer = &list->hwLayers[list->numHwLayers - 1];
+    if (LIKELY(ctx->mOverlay)) {
+        overlay::Overlay& ov = *(ctx->mOverlay);
+        hwc_rect_t displayFrame = layer->displayFrame;
+        int alignedWidth = 0;
+        int alignedHeight = 0;
+
+        getBufferSizeAndDimensions(displayFrame.right - displayFrame.left,
+                displayFrame.bottom - displayFrame.top,
+                HAL_PIXEL_FORMAT_RGBA_8888,
+                alignedWidth,
+                alignedHeight);
+
+        ovutils::Whf info(alignedWidth,
+                alignedHeight,
+                ovutils::getMdpFormat(HAL_PIXEL_FORMAT_RGBA_8888));
+
+        //Request left pipe
+        ovutils::eDest destL = ov.nextPipe(ovutils::OV_MDP_PIPE_ANY, mDpy,
+                Overlay::MIXER_LEFT);
+        if(destL == ovutils::OV_INVALID) { //None available
+            ALOGE("%s: No pipes available to configure framebuffer",
+                __FUNCTION__);
+            return false;
+        }
+        //Request right pipe
+        ovutils::eDest destR = ov.nextPipe(ovutils::OV_MDP_PIPE_ANY, mDpy,
+                Overlay::MIXER_RIGHT);
+        if(destR == ovutils::OV_INVALID) { //None available
+            ALOGE("%s: No pipes available to configure framebuffer",
+                __FUNCTION__);
+            return false;
+        }
+
+        mDestLeft = destL;
+        mDestRight = destR;
+
+        ovutils::eMdpFlags mdpFlagsL = ovutils::OV_MDP_BLEND_FG_PREMULT;
+
+        ovutils::eZorder zOrder = static_cast<ovutils::eZorder>(fbZorder);
+
+        //XXX: FB layer plane alpha is currently sent as zero from
+        //surfaceflinger
+        ovutils::PipeArgs pargL(mdpFlagsL,
+                info,
+                zOrder,
+                ovutils::IS_FG_OFF,
+                ovutils::ROT_FLAGS_NONE,
+                ovutils::DEFAULT_PLANE_ALPHA,
+                (ovutils::eBlending) getBlending(layer->blending));
+        ov.setSource(pargL, destL);
+
+        ovutils::eMdpFlags mdpFlagsR = mdpFlagsL;
+        ovutils::setMdpFlags(mdpFlagsR, ovutils::OV_MDSS_MDP_RIGHT_MIXER);
+        ovutils::PipeArgs pargR(mdpFlagsR,
+                info,
+                zOrder,
+                ovutils::IS_FG_OFF,
+                ovutils::ROT_FLAGS_NONE,
+                ovutils::DEFAULT_PLANE_ALPHA,
+                (ovutils::eBlending) getBlending(layer->blending));
+        ov.setSource(pargR, destR);
+
+        hwc_rect_t sourceCrop = integerizeSourceCrop(layer->sourceCropf);
+
+        const float xres = ctx->dpyAttr[mDpy].xres;
+        const int lSplit = getLeftSplit(ctx, mDpy);
+        const float lSplitRatio = lSplit / xres;
+        const float lCropWidth =
+                (sourceCrop.right - sourceCrop.left) * lSplitRatio;
+
+        ovutils::Dim dcropL(
+                sourceCrop.left,
+                sourceCrop.top,
+                lCropWidth,
+                sourceCrop.bottom - sourceCrop.top);
+
+        ovutils::Dim dcropR(
+                sourceCrop.left + lCropWidth,
+                sourceCrop.top,
+                (sourceCrop.right - sourceCrop.left) - lCropWidth,
+                sourceCrop.bottom - sourceCrop.top);
+
+        ov.setCrop(dcropL, destL);
+        ov.setCrop(dcropR, destR);
+
+        int transform = layer->transform;
+        ovutils::eTransform orient =
+            static_cast<ovutils::eTransform>(transform);
+        ov.setTransform(orient, destL);
+        ov.setTransform(orient, destR);
+
+        const int lWidth = (lSplit - displayFrame.left);
+        const int rWidth = (displayFrame.right - lSplit);
+        const int height = displayFrame.bottom - displayFrame.top;
+
+        ovutils::Dim dposL(displayFrame.left,
+                           displayFrame.top,
+                           lWidth,
+                           height);
+        ov.setPosition(dposL, destL);
+
+        ovutils::Dim dposR(0,
+                           displayFrame.top,
+                           rWidth,
+                           height);
+        ov.setPosition(dposR, destR);
+
+        ret = true;
+        if (!ov.commit(destL)) {
+            ALOGE("%s: commit fails for left", __FUNCTION__);
+            ret = false;
+        }
+        if (!ov.commit(destR)) {
+            ALOGE("%s: commit fails for right", __FUNCTION__);
+            ret = false;
+        }
+    }
+    return ret;
+}
+
+bool FBUpdateHighRes::draw(hwc_context_t *ctx, private_handle_t *hnd)
+{
+    if(!mModeOn) {
+        return true;
+    }
+    bool ret = true;
+    overlay::Overlay& ov = *(ctx->mOverlay);
+    ovutils::eDest destL = mDestLeft;
+    ovutils::eDest destR = mDestRight;
+    if (!ov.queueBuffer(hnd->fd, hnd->offset, destL)) {
+        ALOGE("%s: queue failed for left of dpy = %d",
+              __FUNCTION__, mDpy);
+        ret = false;
+    }
+    if (!ov.queueBuffer(hnd->fd, hnd->offset, destR)) {
+        ALOGE("%s: queue failed for right of dpy = %d",
+              __FUNCTION__, mDpy);
+        ret = false;
+    }
+    return ret;
+}
+
+//---------------------------------------------------------------------
+}; //namespace qhwc
diff --git a/msm8974/libhwcomposer/hwc_fbupdate.h b/msm8974/libhwcomposer/hwc_fbupdate.h
new file mode 100644
index 0000000..d496d5a
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_fbupdate.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef HWC_FBUPDATE_H
+#define HWC_FBUPDATE_H
+#include "hwc_utils.h"
+#include "overlay.h"
+
+#define LIKELY( exp )       (__builtin_expect( (exp) != 0, true  ))
+#define UNLIKELY( exp )     (__builtin_expect( (exp) != 0, false ))
+
+namespace qhwc {
+namespace ovutils = overlay::utils;
+
+//Framebuffer update Interface
+class IFBUpdate {
+public:
+    explicit IFBUpdate(const int& dpy) : mDpy(dpy) {}
+    virtual ~IFBUpdate() {};
+    // Sets up members and prepares overlay if conditions are met
+    virtual bool prepare(hwc_context_t *ctx, hwc_display_contents_1 *list,
+                                                       int fbZorder) = 0;
+    // Draws layer
+    virtual bool draw(hwc_context_t *ctx, private_handle_t *hnd) = 0;
+    //Reset values
+    virtual void reset();
+    //Factory method that returns a low-res or high-res version
+    static IFBUpdate *getObject(const int& width, const int& rightSplit,
+            const int& dpy);
+
+protected:
+    const int mDpy; // display to update
+    bool mModeOn; // if prepare happened
+};
+
+//Low resolution (<= 2048) panel handler.
+class FBUpdateLowRes : public IFBUpdate {
+public:
+    explicit FBUpdateLowRes(const int& dpy);
+    virtual ~FBUpdateLowRes() {};
+    bool prepare(hwc_context_t *ctx, hwc_display_contents_1 *list,
+            int fbZorder);
+    bool draw(hwc_context_t *ctx, private_handle_t *hnd);
+    void reset();
+private:
+    bool configure(hwc_context_t *ctx, hwc_display_contents_1 *list,
+            int fbZorder);
+    ovutils::eDest mDest; //pipe to draw on
+};
+
+//High resolution (> 2048) panel handler.
+class FBUpdateHighRes : public IFBUpdate {
+public:
+    explicit FBUpdateHighRes(const int& dpy);
+    virtual ~FBUpdateHighRes() {};
+    bool prepare(hwc_context_t *ctx, hwc_display_contents_1 *list,
+            int fbZorder);
+    bool draw(hwc_context_t *ctx, private_handle_t *hnd);
+    void reset();
+private:
+    bool configure(hwc_context_t *ctx, hwc_display_contents_1 *list,
+            int fbZorder);
+    ovutils::eDest mDestLeft; //left pipe to draw on
+    ovutils::eDest mDestRight; //right pipe to draw on
+};
+
+}; //namespace qhwc
+
+#endif //HWC_FBUPDATE_H
diff --git a/msm8974/libhwcomposer/hwc_mdpcomp.cpp b/msm8974/libhwcomposer/hwc_mdpcomp.cpp
new file mode 100644
index 0000000..274fe57
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_mdpcomp.cpp
@@ -0,0 +1,1313 @@
+/*
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <math.h>
+#include "hwc_mdpcomp.h"
+#include <sys/ioctl.h>
+#include "qdMetaData.h"
+#include "mdp_version.h"
+#include "hwc_fbupdate.h"
+#include "hwc_ad.h"
+#include <overlayRotator.h>
+
+using namespace overlay;
+using namespace qdutils;
+using namespace overlay::utils;
+namespace ovutils = overlay::utils;
+
+namespace qhwc {
+
+//==============MDPComp========================================================
+
+IdleInvalidator *MDPComp::idleInvalidator = NULL;
+bool MDPComp::sIdleFallBack = false;
+bool MDPComp::sDebugLogs = false;
+bool MDPComp::sEnabled = false;
+bool MDPComp::sEnableMixedMode = true;
+int MDPComp::sMaxPipesPerMixer = MAX_PIPES_PER_MIXER;
+
+MDPComp* MDPComp::getObject(const int& width, const int& rightSplit,
+        const int& dpy) {
+    if(width > MAX_DISPLAY_DIM || rightSplit) {
+        return new MDPCompHighRes(dpy);
+    }
+    return new MDPCompLowRes(dpy);
+}
+
+MDPComp::MDPComp(int dpy):mDpy(dpy){};
+
+void MDPComp::dump(android::String8& buf)
+{
+    if(mCurrentFrame.layerCount > MAX_NUM_APP_LAYERS)
+        return;
+
+    dumpsys_log(buf,"HWC Map for Dpy: %s \n",
+                (mDpy == 0) ? "\"PRIMARY\"" :
+                (mDpy == 1) ? "\"EXTERNAL\"" : "\"VIRTUAL\"");
+    dumpsys_log(buf,"CURR_FRAME: layerCount:%2d mdpCount:%2d "
+                "fbCount:%2d \n", mCurrentFrame.layerCount,
+                mCurrentFrame.mdpCount, mCurrentFrame.fbCount);
+    dumpsys_log(buf,"needsFBRedraw:%3s  pipesUsed:%2d  MaxPipesPerMixer: %d \n",
+                (mCurrentFrame.needsRedraw? "YES" : "NO"),
+                mCurrentFrame.mdpCount, sMaxPipesPerMixer);
+    dumpsys_log(buf," ---------------------------------------------  \n");
+    dumpsys_log(buf," listIdx | cached? | mdpIndex | comptype  |  Z  \n");
+    dumpsys_log(buf," ---------------------------------------------  \n");
+    for(int index = 0; index < mCurrentFrame.layerCount; index++ )
+        dumpsys_log(buf," %7d | %7s | %8d | %9s | %2d \n",
+                    index,
+                    (mCurrentFrame.isFBComposed[index] ? "YES" : "NO"),
+                    mCurrentFrame.layerToMDP[index],
+                    (mCurrentFrame.isFBComposed[index] ?
+                     (mCurrentFrame.needsRedraw ? "GLES" : "CACHE") : "MDP"),
+                    (mCurrentFrame.isFBComposed[index] ? mCurrentFrame.fbZ :
+    mCurrentFrame.mdpToLayer[mCurrentFrame.layerToMDP[index]].pipeInfo->zOrder));
+    dumpsys_log(buf,"\n");
+}
+
+bool MDPComp::init(hwc_context_t *ctx) {
+
+    if(!ctx) {
+        ALOGE("%s: Invalid hwc context!!",__FUNCTION__);
+        return false;
+    }
+
+    char property[PROPERTY_VALUE_MAX];
+
+    sEnabled = false;
+    if((property_get("persist.hwc.mdpcomp.enable", property, NULL) > 0) &&
+       (!strncmp(property, "1", PROPERTY_VALUE_MAX ) ||
+        (!strncasecmp(property,"true", PROPERTY_VALUE_MAX )))) {
+        sEnabled = true;
+    }
+
+    sEnableMixedMode = true;
+    if((property_get("debug.mdpcomp.mixedmode.disable", property, NULL) > 0) &&
+       (!strncmp(property, "1", PROPERTY_VALUE_MAX ) ||
+        (!strncasecmp(property,"true", PROPERTY_VALUE_MAX )))) {
+        sEnableMixedMode = false;
+    }
+
+    sDebugLogs = false;
+    if(property_get("debug.mdpcomp.logs", property, NULL) > 0) {
+        if(atoi(property) != 0)
+            sDebugLogs = true;
+    }
+
+    sMaxPipesPerMixer = MAX_PIPES_PER_MIXER;
+    if(property_get("debug.mdpcomp.maxpermixer", property, "-1") > 0) {
+        int val = atoi(property);
+        if(val >= 0)
+            sMaxPipesPerMixer = min(val, MAX_PIPES_PER_MIXER);
+    }
+
+    if(ctx->mMDP.panel != MIPI_CMD_PANEL) {
+        // Idle invalidation is not necessary on command mode panels
+        long idle_timeout = DEFAULT_IDLE_TIME;
+        if(property_get("debug.mdpcomp.idletime", property, NULL) > 0) {
+            if(atoi(property) != 0)
+                idle_timeout = atoi(property);
+        }
+
+        //create Idle Invalidator only when not disabled through property
+        if(idle_timeout != -1)
+            idleInvalidator = IdleInvalidator::getInstance();
+
+        if(idleInvalidator == NULL) {
+            ALOGE("%s: failed to instantiate idleInvalidator object",
+                  __FUNCTION__);
+        } else {
+            idleInvalidator->init(timeout_handler, ctx, idle_timeout);
+        }
+    }
+    return true;
+}
+
+void MDPComp::reset(const int& numLayers, hwc_display_contents_1_t* list) {
+    mCurrentFrame.reset(numLayers);
+    mCachedFrame.cacheAll(list);
+    mCachedFrame.updateCounts(mCurrentFrame);
+}
+
+void MDPComp::timeout_handler(void *udata) {
+    struct hwc_context_t* ctx = (struct hwc_context_t*)(udata);
+
+    if(!ctx) {
+        ALOGE("%s: received empty data in timer callback", __FUNCTION__);
+        return;
+    }
+
+    if(!ctx->proc) {
+        ALOGE("%s: HWC proc not registered", __FUNCTION__);
+        return;
+    }
+    sIdleFallBack = true;
+    /* Trigger SF to redraw the current frame */
+    ctx->proc->invalidate(ctx->proc);
+}
+
+void MDPComp::setMDPCompLayerFlags(hwc_context_t *ctx,
+                                   hwc_display_contents_1_t* list) {
+    LayerProp *layerProp = ctx->layerProp[mDpy];
+
+    for(int index = 0; index < ctx->listStats[mDpy].numAppLayers; index++) {
+        hwc_layer_1_t* layer = &(list->hwLayers[index]);
+        if(!mCurrentFrame.isFBComposed[index]) {
+            layerProp[index].mFlags |= HWC_MDPCOMP;
+            layer->compositionType = HWC_OVERLAY;
+            layer->hints |= HWC_HINT_CLEAR_FB;
+        } else {
+            if(!mCurrentFrame.needsRedraw)
+                layer->compositionType = HWC_OVERLAY;
+        }
+    }
+}
+
+MDPComp::FrameInfo::FrameInfo() {
+    memset(&mdpToLayer, 0, sizeof(mdpToLayer));
+    reset(0);
+}
+
+void MDPComp::FrameInfo::reset(const int& numLayers) {
+    for(int i = 0 ; i < MAX_PIPES_PER_MIXER; i++ ) {
+        if(mdpToLayer[i].pipeInfo) {
+            delete mdpToLayer[i].pipeInfo;
+            mdpToLayer[i].pipeInfo = NULL;
+            //We dont own the rotator
+            mdpToLayer[i].rot = NULL;
+        }
+    }
+
+    memset(&mdpToLayer, 0, sizeof(mdpToLayer));
+    memset(&layerToMDP, -1, sizeof(layerToMDP));
+    memset(&isFBComposed, 1, sizeof(isFBComposed));
+
+    layerCount = numLayers;
+    fbCount = numLayers;
+    mdpCount = 0;
+    needsRedraw = true;
+    fbZ = 0;
+}
+
+void MDPComp::FrameInfo::map() {
+    // populate layer and MDP maps
+    int mdpIdx = 0;
+    for(int idx = 0; idx < layerCount; idx++) {
+        if(!isFBComposed[idx]) {
+            mdpToLayer[mdpIdx].listIndex = idx;
+            layerToMDP[idx] = mdpIdx++;
+        }
+    }
+}
+
+MDPComp::LayerCache::LayerCache() {
+    reset();
+}
+
+void MDPComp::LayerCache::reset() {
+    memset(&hnd, 0, sizeof(hnd));
+    mdpCount = 0;
+    fbCount = 0;
+    layerCount = 0;
+    fbZ = -1;
+}
+
+void MDPComp::LayerCache::cacheAll(hwc_display_contents_1_t* list) {
+    const int numAppLayers = list->numHwLayers - 1;
+    for(int i = 0; i < numAppLayers; i++) {
+        hnd[i] = list->hwLayers[i].handle;
+    }
+}
+
+void MDPComp::LayerCache::updateCounts(const FrameInfo& curFrame) {
+    mdpCount = curFrame.mdpCount;
+    fbCount = curFrame.fbCount;
+    layerCount = curFrame.layerCount;
+    fbZ = curFrame.fbZ;
+}
+
+bool MDPComp::isSupportedForMDPComp(hwc_context_t *ctx, hwc_layer_1_t* layer) {
+    private_handle_t *hnd = (private_handle_t *)layer->handle;
+    if((not isYuvBuffer(hnd) and has90Transform(layer)) or
+        (not isValidDimension(ctx,layer))
+        //More conditions here, SKIP, sRGB+Blend etc
+        ) {
+        return false;
+    }
+    return true;
+}
+
+bool MDPComp::isValidDimension(hwc_context_t *ctx, hwc_layer_1_t *layer) {
+    private_handle_t *hnd = (private_handle_t *)layer->handle;
+
+    if(!hnd) {
+        ALOGE("%s: layer handle is NULL", __FUNCTION__);
+        return false;
+    }
+
+    //XXX: Investigate doing this with pixel phase on MDSS
+    if(!isSecureBuffer(hnd) && isNonIntegralSourceCrop(layer->sourceCropf))
+        return false;
+
+    int hw_w = ctx->dpyAttr[mDpy].xres;
+    int hw_h = ctx->dpyAttr[mDpy].yres;
+
+    hwc_rect_t crop = integerizeSourceCrop(layer->sourceCropf);
+    hwc_rect_t dst = layer->displayFrame;
+
+    if(dst.left < 0 || dst.top < 0 || dst.right > hw_w || dst.bottom > hw_h) {
+       hwc_rect_t scissor = {0, 0, hw_w, hw_h };
+       qhwc::calculate_crop_rects(crop, dst, scissor, layer->transform);
+    }
+
+    bool rotated90 = (bool)(layer->transform & HAL_TRANSFORM_ROT_90);
+    int crop_w = rotated90 ? crop.bottom - crop.top : crop.right - crop.left;
+    int crop_h = rotated90 ? crop.right - crop.left : crop.bottom - crop.top;
+    int dst_w = dst.right - dst.left;
+    int dst_h = dst.bottom - dst.top;
+    float w_dscale = ceilf((float)crop_w / (float)dst_w);
+    float h_dscale = ceilf((float)crop_h / (float)dst_h);
+
+    //Workaround for MDP HW limitation in DSI command mode panels where
+    //FPS will not go beyond 30 if buffers on RGB pipes are of width < 5
+
+    if((crop_w < 5)||(crop_h < 5))
+        return false;
+
+    const uint32_t downscale =
+            qdutils::MDPVersion::getInstance().getMaxMDPDownscale();
+    if(ctx->mMDP.version >= qdutils::MDSS_V5) {
+        if(!qdutils::MDPVersion::getInstance().supportsDecimation()) {
+            if(crop_w > MAX_DISPLAY_DIM || w_dscale > downscale ||
+                    h_dscale > downscale)
+                return false;
+        } else if(w_dscale > 64 || h_dscale > 64) {
+            return false;
+        }
+    } else { //A-family
+        if(w_dscale > downscale || h_dscale > downscale)
+            return false;
+    }
+
+    return true;
+}
+
+ovutils::eDest MDPComp::getMdpPipe(hwc_context_t *ctx, ePipeType type,
+        int mixer) {
+    overlay::Overlay& ov = *ctx->mOverlay;
+    ovutils::eDest mdp_pipe = ovutils::OV_INVALID;
+
+    switch(type) {
+    case MDPCOMP_OV_DMA:
+        mdp_pipe = ov.nextPipe(ovutils::OV_MDP_PIPE_DMA, mDpy, mixer);
+        if(mdp_pipe != ovutils::OV_INVALID) {
+            return mdp_pipe;
+        }
+    case MDPCOMP_OV_ANY:
+    case MDPCOMP_OV_RGB:
+        mdp_pipe = ov.nextPipe(ovutils::OV_MDP_PIPE_RGB, mDpy, mixer);
+        if(mdp_pipe != ovutils::OV_INVALID) {
+            return mdp_pipe;
+        }
+
+        if(type == MDPCOMP_OV_RGB) {
+            //Requested only for RGB pipe
+            break;
+        }
+    case  MDPCOMP_OV_VG:
+        return ov.nextPipe(ovutils::OV_MDP_PIPE_VG, mDpy, mixer);
+    default:
+        ALOGE("%s: Invalid pipe type",__FUNCTION__);
+        return ovutils::OV_INVALID;
+    };
+    return ovutils::OV_INVALID;
+}
+
+bool MDPComp::isFrameDoable(hwc_context_t *ctx) {
+    bool ret = true;
+
+    if(!isEnabled()) {
+        ALOGD_IF(isDebug(),"%s: MDP Comp. not enabled.", __FUNCTION__);
+        ret = false;
+    } else if(qdutils::MDPVersion::getInstance().is8x26() &&
+            ctx->mVideoTransFlag &&
+            isSecondaryConnected(ctx)) {
+        //1 Padding round to shift pipes across mixers
+        ALOGD_IF(isDebug(),"%s: MDP Comp. video transition padding round",
+                __FUNCTION__);
+        ret = false;
+    } else if(isSecondaryConfiguring(ctx)) {
+        ALOGD_IF( isDebug(),"%s: External Display connection is pending",
+                  __FUNCTION__);
+        ret = false;
+    } else if(ctx->isPaddingRound) {
+        ctx->isPaddingRound = false;
+        ALOGD_IF(isDebug(), "%s: padding round",__FUNCTION__);
+        ret = false;
+    }
+    return ret;
+}
+
+/* Checks for conditions where all the layers marked for MDP comp cannot be
+ * bypassed. On such conditions we try to bypass atleast YUV layers */
+bool MDPComp::isFullFrameDoable(hwc_context_t *ctx,
+                                hwc_display_contents_1_t* list){
+
+    const int numAppLayers = ctx->listStats[mDpy].numAppLayers;
+
+    if(sIdleFallBack) {
+        ALOGD_IF(isDebug(), "%s: Idle fallback dpy %d",__FUNCTION__, mDpy);
+        return false;
+    }
+
+    if(isSkipPresent(ctx, mDpy)) {
+        ALOGD_IF(isDebug(),"%s: SKIP present: %d",
+                __FUNCTION__,
+                isSkipPresent(ctx, mDpy));
+        return false;
+    }
+
+    if(ctx->listStats[mDpy].needsAlphaScale
+       && ctx->mMDP.version < qdutils::MDSS_V5) {
+        ALOGD_IF(isDebug(), "%s: frame needs alpha downscaling",__FUNCTION__);
+        return false;
+    }
+
+    for(int i = 0; i < numAppLayers; ++i) {
+        hwc_layer_1_t* layer = &list->hwLayers[i];
+        private_handle_t *hnd = (private_handle_t *)layer->handle;
+
+        if(isYuvBuffer(hnd) && has90Transform(layer)) {
+            if(!canUseRotator(ctx, mDpy)) {
+                ALOGD_IF(isDebug(), "%s: Can't use rotator for dpy %d",
+                        __FUNCTION__, mDpy);
+                return false;
+            }
+        }
+
+        if(mDpy > HWC_DISPLAY_PRIMARY && isL3SecureBuffer(hnd)) {
+            return false;
+        }
+
+        //For 8x26 with panel width>1k, if RGB layer needs HFLIP fail mdp comp
+        // may not need it if Gfx pre-rotation can handle all flips & rotations
+        if(qdutils::MDPVersion::getInstance().is8x26() &&
+                                (ctx->dpyAttr[mDpy].xres > 1024) &&
+                                (layer->transform & HWC_TRANSFORM_FLIP_H) &&
+                                (!isYuvBuffer(hnd)))
+                   return false;
+    }
+
+    if(ctx->mAD->isDoable()) {
+        return false;
+    }
+
+    //If all above hard conditions are met we can do full or partial MDP comp.
+    bool ret = false;
+    if(fullMDPComp(ctx, list)) {
+        ret = true;
+    } else if(partialMDPComp(ctx, list)) {
+        ret = true;
+    }
+    return ret;
+}
+
+bool MDPComp::fullMDPComp(hwc_context_t *ctx, hwc_display_contents_1_t* list) {
+    //Will benefit presentation / secondary-only layer.
+    if((mDpy > HWC_DISPLAY_PRIMARY) &&
+            (list->numHwLayers - 1) > MAX_SEC_LAYERS) {
+        ALOGD_IF(isDebug(), "%s: Exceeds max secondary pipes",__FUNCTION__);
+        return false;
+    }
+
+    /* XXX: There is some flicker currently seen with partial
+     * MDP composition on the virtual display.
+     * Disable UI MDP comp on virtual until it is fixed*/
+
+    if(mDpy > HWC_DISPLAY_EXTERNAL) {
+        return false;
+    }
+
+    const int numAppLayers = ctx->listStats[mDpy].numAppLayers;
+    for(int i = 0; i < numAppLayers; i++) {
+        hwc_layer_1_t* layer = &list->hwLayers[i];
+        if(not isSupportedForMDPComp(ctx, layer)) {
+            ALOGD_IF(isDebug(), "%s: Unsupported layer in list",__FUNCTION__);
+            return false;
+        }
+    }
+
+    //Setup mCurrentFrame
+    mCurrentFrame.mdpCount = mCurrentFrame.layerCount;
+    mCurrentFrame.fbCount = 0;
+    mCurrentFrame.fbZ = -1;
+    memset(&mCurrentFrame.isFBComposed, 0, sizeof(mCurrentFrame.isFBComposed));
+
+    int mdpCount = mCurrentFrame.mdpCount;
+    if(mdpCount > sMaxPipesPerMixer) {
+        ALOGD_IF(isDebug(), "%s: Exceeds MAX_PIPES_PER_MIXER",__FUNCTION__);
+        return false;
+    }
+
+    if(!arePipesAvailable(ctx, list)) {
+        return false;
+    }
+
+    return true;
+}
+
+bool MDPComp::partialMDPComp(hwc_context_t *ctx, hwc_display_contents_1_t* list)
+{
+    if(!sEnableMixedMode) {
+        //Mixed mode is disabled. No need to even try caching.
+        return false;
+    }
+
+    bool ret = false;
+    if(isLoadBasedCompDoable(ctx, list)) {
+        ret = loadBasedComp(ctx, list);
+    }
+
+    if(!ret) {
+        ret = cacheBasedComp(ctx, list);
+    }
+
+    return ret;
+}
+
+bool MDPComp::cacheBasedComp(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list) {
+    int numAppLayers = ctx->listStats[mDpy].numAppLayers;
+    mCurrentFrame.reset(numAppLayers);
+    updateLayerCache(ctx, list);
+
+    //If an MDP marked layer is unsupported cannot do partial MDP Comp
+    for(int i = 0; i < numAppLayers; i++) {
+        if(!mCurrentFrame.isFBComposed[i]) {
+            hwc_layer_1_t* layer = &list->hwLayers[i];
+            if(not isSupportedForMDPComp(ctx, layer)) {
+                ALOGD_IF(isDebug(), "%s: Unsupported layer in list",
+                        __FUNCTION__);
+                return false;
+            }
+        }
+    }
+
+    updateYUV(ctx, list);
+    bool ret = batchLayers(ctx, list); //sets up fbZ also
+    if(!ret) {
+        ALOGD_IF(isDebug(),"%s: batching failed, dpy %d",__FUNCTION__, mDpy);
+        return false;
+    }
+
+    int mdpCount = mCurrentFrame.mdpCount;
+
+    //Will benefit cases where a video has non-updating background.
+    if((mDpy > HWC_DISPLAY_PRIMARY) and
+            (mdpCount > MAX_SEC_LAYERS)) {
+        ALOGD_IF(isDebug(), "%s: Exceeds max secondary pipes",__FUNCTION__);
+        return false;
+    }
+
+    /* XXX: There is some flicker currently seen with partial
+     * MDP composition on the virtual display.
+     * Disable UI MDP comp on virtual until it is fixed*/
+
+    if(mDpy > HWC_DISPLAY_EXTERNAL) {
+        return false;
+    }
+
+    if(mdpCount > (sMaxPipesPerMixer - 1)) { // -1 since FB is used
+        ALOGD_IF(isDebug(), "%s: Exceeds MAX_PIPES_PER_MIXER",__FUNCTION__);
+        return false;
+    }
+
+    if(!arePipesAvailable(ctx, list)) {
+        return false;
+    }
+
+    return true;
+}
+
+bool MDPComp::loadBasedComp(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list) {
+    int numAppLayers = ctx->listStats[mDpy].numAppLayers;
+    mCurrentFrame.reset(numAppLayers);
+
+    //TODO BatchSize could be optimized further based on available pipes, split
+    //displays etc.
+    const int batchSize = numAppLayers - (sMaxPipesPerMixer - 1);
+    if(batchSize <= 0) {
+        ALOGD_IF(isDebug(), "%s: Not attempting", __FUNCTION__);
+        return false;
+    }
+
+    int minBatchStart = -1;
+    size_t minBatchPixelCount = SIZE_MAX;
+
+    for(int i = 0; i <= numAppLayers - batchSize; i++) {
+        uint32_t batchPixelCount = 0;
+        for(int j = i; j < i + batchSize; j++) {
+            hwc_layer_1_t* layer = &list->hwLayers[j];
+            hwc_rect_t crop = integerizeSourceCrop(layer->sourceCropf);
+            batchPixelCount += (crop.right - crop.left) *
+                    (crop.bottom - crop.top);
+        }
+
+        if(batchPixelCount < minBatchPixelCount) {
+            minBatchPixelCount = batchPixelCount;
+            minBatchStart = i;
+        }
+    }
+
+    if(minBatchStart < 0) {
+        ALOGD_IF(isDebug(), "%s: No batch found batchSize %d numAppLayers %d",
+                __FUNCTION__, batchSize, numAppLayers);
+        return false;
+    }
+
+    for(int i = 0; i < numAppLayers; i++) {
+        if(i < minBatchStart || i >= minBatchStart + batchSize) {
+            hwc_layer_1_t* layer = &list->hwLayers[i];
+            if(not isSupportedForMDPComp(ctx, layer)) {
+                ALOGD_IF(isDebug(), "%s: MDP unsupported layer found at %d",
+                        __FUNCTION__, i);
+                return false;
+            }
+            mCurrentFrame.isFBComposed[i] = false;
+        }
+    }
+
+    mCurrentFrame.fbZ = minBatchStart;
+    mCurrentFrame.fbCount = batchSize;
+    mCurrentFrame.mdpCount = mCurrentFrame.layerCount - batchSize;
+
+    if(!arePipesAvailable(ctx, list)) {
+        return false;
+    }
+
+    ALOGD_IF(isDebug(), "%s: fbZ %d batchSize %d",
+                __FUNCTION__, mCurrentFrame.fbZ, batchSize);
+    return true;
+}
+
+bool MDPComp::isLoadBasedCompDoable(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list) {
+    if(mDpy or isSecurePresent(ctx, mDpy) or
+            not (list->flags & HWC_GEOMETRY_CHANGED)) {
+        return false;
+    }
+    return true;
+}
+
+bool MDPComp::isOnlyVideoDoable(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list){
+    int numAppLayers = ctx->listStats[mDpy].numAppLayers;
+    mCurrentFrame.reset(numAppLayers);
+    updateYUV(ctx, list);
+    int mdpCount = mCurrentFrame.mdpCount;
+    int fbNeeded = int(mCurrentFrame.fbCount != 0);
+
+    if(!isYuvPresent(ctx, mDpy)) {
+        return false;
+    }
+
+    if(!mdpCount)
+        return false;
+
+    if(mdpCount > (sMaxPipesPerMixer - fbNeeded)) {
+        ALOGD_IF(isDebug(), "%s: Exceeds MAX_PIPES_PER_MIXER",__FUNCTION__);
+        return false;
+    }
+
+    if(!arePipesAvailable(ctx, list)) {
+        return false;
+    }
+
+    int nYuvCount = ctx->listStats[mDpy].yuvCount;
+    for(int index = 0; index < nYuvCount ; index ++) {
+        int nYuvIndex = ctx->listStats[mDpy].yuvIndices[index];
+        hwc_layer_1_t* layer = &list->hwLayers[nYuvIndex];
+        if(layer->planeAlpha < 0xFF) {
+            ALOGD_IF(isDebug(), "%s: Cannot handle YUV layer with plane alpha\
+                    in video only mode",
+                    __FUNCTION__);
+            return false;
+        }
+        private_handle_t *hnd = (private_handle_t *)layer->handle;
+        if(mDpy > HWC_DISPLAY_PRIMARY && isL3SecureBuffer(hnd)) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+/* Checks for conditions where YUV layers cannot be bypassed */
+bool MDPComp::isYUVDoable(hwc_context_t* ctx, hwc_layer_1_t* layer) {
+    if(isSkipLayer(layer)) {
+        ALOGE("%s: Unable to bypass skipped YUV", __FUNCTION__);
+        return false;
+    }
+
+    if(layer->transform & HWC_TRANSFORM_ROT_90 && !canUseRotator(ctx,mDpy)) {
+        ALOGD_IF(isDebug(), "%s: no free DMA pipe",__FUNCTION__);
+        return false;
+    }
+
+    if(isSecuring(ctx, layer)) {
+        ALOGD_IF(isDebug(), "%s: MDP securing is active", __FUNCTION__);
+        return false;
+    }
+
+    if(!isValidDimension(ctx, layer)) {
+        ALOGD_IF(isDebug(), "%s: Buffer is of invalid width",
+            __FUNCTION__);
+        return false;
+    }
+
+    return true;
+}
+
+bool MDPComp::batchLayers(hwc_context_t *ctx, hwc_display_contents_1_t* list) {
+    /* Idea is to keep as many contiguous non-updating(cached) layers in FB and
+     * send rest of them through MDP. NEVER mark an updating layer for caching.
+     * But cached ones can be marked for MDP*/
+
+    int maxBatchStart = -1;
+    int maxBatchCount = 0;
+
+    /* All or Nothing is cached. No batching needed */
+    if(!mCurrentFrame.fbCount) {
+        mCurrentFrame.fbZ = -1;
+        return true;
+    }
+    if(!mCurrentFrame.mdpCount) {
+        mCurrentFrame.fbZ = 0;
+        return true;
+    }
+
+    /* Search for max number of contiguous (cached) layers */
+    int i = 0;
+    while (i < mCurrentFrame.layerCount) {
+        int count = 0;
+        while(mCurrentFrame.isFBComposed[i] && i < mCurrentFrame.layerCount) {
+            count++; i++;
+        }
+        if(count > maxBatchCount) {
+            maxBatchCount = count;
+            maxBatchStart = i - count;
+            mCurrentFrame.fbZ = maxBatchStart;
+        }
+        if(i < mCurrentFrame.layerCount) i++;
+    }
+
+    /* reset rest of the layers for MDP comp */
+    for(int i = 0; i < mCurrentFrame.layerCount; i++) {
+        hwc_layer_1_t* layer = &list->hwLayers[i];
+        if(i != maxBatchStart) {
+            //If an unsupported layer is being attempted to be pulled out we
+            //should fail
+            if(not isSupportedForMDPComp(ctx, layer)) {
+                return false;
+            }
+            mCurrentFrame.isFBComposed[i] = false;
+        } else {
+            i += maxBatchCount;
+        }
+    }
+
+    mCurrentFrame.fbCount = maxBatchCount;
+    mCurrentFrame.mdpCount = mCurrentFrame.layerCount -
+            mCurrentFrame.fbCount;
+
+    ALOGD_IF(isDebug(),"%s: cached count: %d",__FUNCTION__,
+             mCurrentFrame.fbCount);
+
+    return true;
+}
+
+void MDPComp::updateLayerCache(hwc_context_t* ctx,
+        hwc_display_contents_1_t* list) {
+    int numAppLayers = ctx->listStats[mDpy].numAppLayers;
+    int fbCount = 0;
+
+    for(int i = 0; i < numAppLayers; i++) {
+        if (mCachedFrame.hnd[i] == list->hwLayers[i].handle) {
+            fbCount++;
+            mCurrentFrame.isFBComposed[i] = true;
+        } else {
+            mCurrentFrame.isFBComposed[i] = false;
+            mCachedFrame.hnd[i] = list->hwLayers[i].handle;
+        }
+    }
+
+    mCurrentFrame.fbCount = fbCount;
+    mCurrentFrame.mdpCount = mCurrentFrame.layerCount - mCurrentFrame.fbCount;
+
+    ALOGD_IF(isDebug(),"%s: MDP count: %d FB count %d",__FUNCTION__,
+            mCurrentFrame.mdpCount, mCurrentFrame.fbCount);
+}
+
+void MDPComp::updateYUV(hwc_context_t* ctx, hwc_display_contents_1_t* list) {
+
+    int nYuvCount = ctx->listStats[mDpy].yuvCount;
+    for(int index = 0;index < nYuvCount; index++){
+        int nYuvIndex = ctx->listStats[mDpy].yuvIndices[index];
+        hwc_layer_1_t* layer = &list->hwLayers[nYuvIndex];
+
+        if(!isYUVDoable(ctx, layer)) {
+            if(!mCurrentFrame.isFBComposed[nYuvIndex]) {
+                mCurrentFrame.isFBComposed[nYuvIndex] = true;
+                mCurrentFrame.fbCount++;
+            }
+        } else {
+            if(mCurrentFrame.isFBComposed[nYuvIndex]) {
+                mCurrentFrame.isFBComposed[nYuvIndex] = false;
+                mCurrentFrame.fbCount--;
+            }
+        }
+    }
+
+    mCurrentFrame.mdpCount = mCurrentFrame.layerCount -
+            mCurrentFrame.fbCount;
+    ALOGD_IF(isDebug(),"%s: cached count: %d",__FUNCTION__,
+             mCurrentFrame.fbCount);
+}
+
+bool MDPComp::programMDP(hwc_context_t *ctx, hwc_display_contents_1_t* list) {
+    if(!allocLayerPipes(ctx, list)) {
+        ALOGD_IF(isDebug(), "%s: Unable to allocate MDP pipes", __FUNCTION__);
+        return false;
+    }
+
+    bool fbBatch = false;
+    for (int index = 0, mdpNextZOrder = 0; index < mCurrentFrame.layerCount;
+            index++) {
+        if(!mCurrentFrame.isFBComposed[index]) {
+            int mdpIndex = mCurrentFrame.layerToMDP[index];
+            hwc_layer_1_t* layer = &list->hwLayers[index];
+
+            MdpPipeInfo* cur_pipe = mCurrentFrame.mdpToLayer[mdpIndex].pipeInfo;
+            cur_pipe->zOrder = mdpNextZOrder++;
+
+            if(configure(ctx, layer, mCurrentFrame.mdpToLayer[mdpIndex]) != 0 ){
+                ALOGD_IF(isDebug(), "%s: Failed to configure overlay for \
+                         layer %d",__FUNCTION__, index);
+                return false;
+            }
+        } else if(fbBatch == false) {
+                mdpNextZOrder++;
+                fbBatch = true;
+        }
+    }
+
+    return true;
+}
+
+bool MDPComp::programYUV(hwc_context_t *ctx, hwc_display_contents_1_t* list) {
+    if(!allocLayerPipes(ctx, list)) {
+        ALOGD_IF(isDebug(), "%s: Unable to allocate MDP pipes", __FUNCTION__);
+        return false;
+    }
+    //If we are in this block, it means we have yuv + rgb layers both
+    int mdpIdx = 0;
+    for (int index = 0; index < mCurrentFrame.layerCount; index++) {
+        if(!mCurrentFrame.isFBComposed[index]) {
+            hwc_layer_1_t* layer = &list->hwLayers[index];
+            int mdpIndex = mCurrentFrame.layerToMDP[index];
+            MdpPipeInfo* cur_pipe =
+                    mCurrentFrame.mdpToLayer[mdpIndex].pipeInfo;
+            cur_pipe->zOrder = mdpIdx++;
+
+            if(configure(ctx, layer,
+                        mCurrentFrame.mdpToLayer[mdpIndex]) != 0 ){
+                ALOGD_IF(isDebug(), "%s: Failed to configure overlay for \
+                        layer %d",__FUNCTION__, index);
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
+int MDPComp::prepare(hwc_context_t *ctx, hwc_display_contents_1_t* list) {
+    const int numLayers = ctx->listStats[mDpy].numAppLayers;
+
+    //reset old data
+    mCurrentFrame.reset(numLayers);
+
+    //number of app layers exceeds MAX_NUM_APP_LAYERS fall back to GPU
+    //do not cache the information for next draw cycle.
+    if(numLayers > MAX_NUM_APP_LAYERS) {
+        mCachedFrame.updateCounts(mCurrentFrame);
+        ALOGD_IF(isDebug(), "%s: Number of App layers exceeded the limit ",
+                __FUNCTION__);
+        return -1;
+    }
+
+    //Hard conditions, if not met, cannot do MDP comp
+    if(!isFrameDoable(ctx)) {
+        ALOGD_IF( isDebug(),"%s: MDP Comp not possible for this frame",
+                __FUNCTION__);
+        reset(numLayers, list);
+        return -1;
+    }
+
+    //Check whether layers marked for MDP Composition is actually doable.
+    if(isFullFrameDoable(ctx, list)) {
+        mCurrentFrame.map();
+        //Configure framebuffer first if applicable
+        if(mCurrentFrame.fbZ >= 0) {
+            if(!ctx->mFBUpdate[mDpy]->prepare(ctx, list,
+                        mCurrentFrame.fbZ)) {
+                ALOGE("%s configure framebuffer failed", __func__);
+                reset(numLayers, list);
+                return -1;
+            }
+        }
+        //Acquire and Program MDP pipes
+        if(!programMDP(ctx, list)) {
+            reset(numLayers, list);
+            return -1;
+        } else { //Success
+            //Any change in composition types needs an FB refresh
+            mCurrentFrame.needsRedraw = false;
+            if(mCurrentFrame.fbCount &&
+                    ((mCurrentFrame.mdpCount != mCachedFrame.mdpCount) ||
+                     (mCurrentFrame.fbCount != mCachedFrame.fbCount) ||
+                     (mCurrentFrame.fbZ != mCachedFrame.fbZ) ||
+                     (!mCurrentFrame.mdpCount) ||
+                     (list->flags & HWC_GEOMETRY_CHANGED) ||
+                     isSkipPresent(ctx, mDpy))) {
+                mCurrentFrame.needsRedraw = true;
+            }
+        }
+    } else if(isOnlyVideoDoable(ctx, list)) {
+        //All layers marked for MDP comp cannot be bypassed.
+        //Try to compose atleast YUV layers through MDP comp and let
+        //all the RGB layers compose in FB
+        //Destination over
+        mCurrentFrame.fbZ = -1;
+        if(mCurrentFrame.fbCount)
+            mCurrentFrame.fbZ = mCurrentFrame.mdpCount;
+
+        mCurrentFrame.map();
+
+        //Configure framebuffer first if applicable
+        if(mCurrentFrame.fbZ >= 0) {
+            if(!ctx->mFBUpdate[mDpy]->prepare(ctx, list, mCurrentFrame.fbZ)) {
+                ALOGE("%s configure framebuffer failed", __func__);
+                reset(numLayers, list);
+                return -1;
+            }
+        }
+        if(!programYUV(ctx, list)) {
+            reset(numLayers, list);
+            return -1;
+        }
+    } else {
+        reset(numLayers, list);
+        return -1;
+    }
+
+    //UpdateLayerFlags
+    setMDPCompLayerFlags(ctx, list);
+    mCachedFrame.updateCounts(mCurrentFrame);
+
+    // unlock it before calling dump function to avoid deadlock
+    if(isDebug()) {
+        ALOGD("GEOMETRY change: %d", (list->flags & HWC_GEOMETRY_CHANGED));
+        android::String8 sDump("");
+        dump(sDump);
+        ALOGE("%s",sDump.string());
+    }
+
+    return 0;
+}
+
+//=============MDPCompLowRes===================================================
+
+/*
+ * Configures pipe(s) for MDP composition
+ */
+int MDPCompLowRes::configure(hwc_context_t *ctx, hwc_layer_1_t *layer,
+                             PipeLayerPair& PipeLayerPair) {
+    MdpPipeInfoLowRes& mdp_info =
+        *(static_cast<MdpPipeInfoLowRes*>(PipeLayerPair.pipeInfo));
+    eMdpFlags mdpFlags = OV_MDP_BACKEND_COMPOSITION;
+    eZorder zOrder = static_cast<eZorder>(mdp_info.zOrder);
+    eIsFg isFg = IS_FG_OFF;
+    eDest dest = mdp_info.index;
+
+    ALOGD_IF(isDebug(),"%s: configuring: layer: %p z_order: %d dest_pipe: %d",
+             __FUNCTION__, layer, zOrder, dest);
+
+    return configureLowRes(ctx, layer, mDpy, mdpFlags, zOrder, isFg, dest,
+                           &PipeLayerPair.rot);
+}
+
+bool MDPCompLowRes::arePipesAvailable(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list) {
+    overlay::Overlay& ov = *ctx->mOverlay;
+    int numPipesNeeded = mCurrentFrame.mdpCount;
+    int availPipes = ov.availablePipes(mDpy, Overlay::MIXER_DEFAULT);
+
+    //Reserve pipe for FB
+    if(mCurrentFrame.fbCount)
+        availPipes -= 1;
+
+    if(numPipesNeeded > availPipes) {
+        ALOGD_IF(isDebug(), "%s: Insufficient pipes, dpy %d needed %d, avail %d",
+                __FUNCTION__, mDpy, numPipesNeeded, availPipes);
+        return false;
+    }
+
+    return true;
+}
+
+bool MDPCompLowRes::allocLayerPipes(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list) {
+    for(int index = 0; index < mCurrentFrame.layerCount; index++) {
+
+        if(mCurrentFrame.isFBComposed[index]) continue;
+
+        hwc_layer_1_t* layer = &list->hwLayers[index];
+        private_handle_t *hnd = (private_handle_t *)layer->handle;
+        int mdpIndex = mCurrentFrame.layerToMDP[index];
+        PipeLayerPair& info = mCurrentFrame.mdpToLayer[mdpIndex];
+        info.pipeInfo = new MdpPipeInfoLowRes;
+        info.rot = NULL;
+        MdpPipeInfoLowRes& pipe_info = *(MdpPipeInfoLowRes*)info.pipeInfo;
+        ePipeType type = MDPCOMP_OV_ANY;
+
+        if(isYuvBuffer(hnd)) {
+            type = MDPCOMP_OV_VG;
+        } else if(!qhwc::needsScaling(ctx, layer, mDpy)
+            && Overlay::getDMAMode() != Overlay::DMA_BLOCK_MODE
+            && ctx->mMDP.version >= qdutils::MDSS_V5) {
+            type = MDPCOMP_OV_DMA;
+        }
+
+        pipe_info.index = getMdpPipe(ctx, type, Overlay::MIXER_DEFAULT);
+        if(pipe_info.index == ovutils::OV_INVALID) {
+            ALOGD_IF(isDebug(), "%s: Unable to get pipe type = %d",
+                __FUNCTION__, (int) type);
+            return false;
+        }
+    }
+    return true;
+}
+
+bool MDPCompLowRes::draw(hwc_context_t *ctx, hwc_display_contents_1_t* list) {
+
+    if(!isEnabled()) {
+        ALOGD_IF(isDebug(),"%s: MDP Comp not configured", __FUNCTION__);
+        return true;
+    }
+
+    if(!ctx || !list) {
+        ALOGE("%s: invalid contxt or list",__FUNCTION__);
+        return false;
+    }
+
+    if(ctx->listStats[mDpy].numAppLayers > MAX_NUM_APP_LAYERS) {
+        ALOGD_IF(isDebug(),"%s: Exceeding max layer count", __FUNCTION__);
+        return true;
+    }
+
+    /* reset Invalidator */
+    if(idleInvalidator && !sIdleFallBack && mCurrentFrame.mdpCount)
+        idleInvalidator->markForSleep();
+
+    overlay::Overlay& ov = *ctx->mOverlay;
+    LayerProp *layerProp = ctx->layerProp[mDpy];
+
+    int numHwLayers = ctx->listStats[mDpy].numAppLayers;
+    for(int i = 0; i < numHwLayers && mCurrentFrame.mdpCount; i++ )
+    {
+        if(mCurrentFrame.isFBComposed[i]) continue;
+
+        hwc_layer_1_t *layer = &list->hwLayers[i];
+        private_handle_t *hnd = (private_handle_t *)layer->handle;
+        if(!hnd) {
+            ALOGE("%s handle null", __FUNCTION__);
+            return false;
+        }
+
+        int mdpIndex = mCurrentFrame.layerToMDP[i];
+
+        MdpPipeInfoLowRes& pipe_info =
+            *(MdpPipeInfoLowRes*)mCurrentFrame.mdpToLayer[mdpIndex].pipeInfo;
+        ovutils::eDest dest = pipe_info.index;
+        if(dest == ovutils::OV_INVALID) {
+            ALOGE("%s: Invalid pipe index (%d)", __FUNCTION__, dest);
+            return false;
+        }
+
+        if(!(layerProp[i].mFlags & HWC_MDPCOMP)) {
+            continue;
+        }
+
+        ALOGD_IF(isDebug(),"%s: MDP Comp: Drawing layer: %p hnd: %p \
+                 using  pipe: %d", __FUNCTION__, layer,
+                 hnd, dest );
+
+        int fd = hnd->fd;
+        uint32_t offset = hnd->offset;
+
+        if(ctx->mAD->isModeOn()) {
+            if(ctx->mAD->draw(ctx, fd, offset)) {
+                fd = ctx->mAD->getDstFd(ctx);
+                offset = ctx->mAD->getDstOffset(ctx);
+            }
+        }
+
+        Rotator *rot = mCurrentFrame.mdpToLayer[mdpIndex].rot;
+        if(rot) {
+            if(!rot->queueBuffer(fd, offset))
+                return false;
+            fd = rot->getDstMemId();
+            offset = rot->getDstOffset();
+        }
+
+        if (!ov.queueBuffer(fd, offset, dest)) {
+            ALOGE("%s: queueBuffer failed for display:%d ", __FUNCTION__, mDpy);
+            return false;
+        }
+
+        layerProp[i].mFlags &= ~HWC_MDPCOMP;
+    }
+    return true;
+}
+
+//=============MDPCompHighRes===================================================
+
+int MDPCompHighRes::pipesNeeded(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list,
+        int mixer) {
+    int pipesNeeded = 0;
+
+    const int lSplit = getLeftSplit(ctx, mDpy);
+
+    for(int i = 0; i < mCurrentFrame.layerCount; ++i) {
+        if(!mCurrentFrame.isFBComposed[i]) {
+            hwc_layer_1_t* layer = &list->hwLayers[i];
+            hwc_rect_t dst = layer->displayFrame;
+            if(mixer == Overlay::MIXER_LEFT && dst.left < lSplit) {
+                pipesNeeded++;
+            } else if(mixer == Overlay::MIXER_RIGHT && dst.right > lSplit) {
+                pipesNeeded++;
+            }
+        }
+    }
+    return pipesNeeded;
+}
+
+bool MDPCompHighRes::arePipesAvailable(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list) {
+    overlay::Overlay& ov = *ctx->mOverlay;
+
+    for(int i = 0; i < Overlay::MIXER_MAX; i++) {
+        int numPipesNeeded = pipesNeeded(ctx, list, i);
+        int availPipes = ov.availablePipes(mDpy, i);
+
+        //Reserve pipe(s)for FB
+        if(mCurrentFrame.fbCount)
+            availPipes -= 1;
+
+        if(numPipesNeeded > availPipes) {
+            ALOGD_IF(isDebug(), "%s: Insufficient pipes for "
+                     "dpy %d mixer %d needed %d, avail %d",
+                     __FUNCTION__, mDpy, i, numPipesNeeded, availPipes);
+            return false;
+        }
+    }
+    return true;
+}
+
+bool MDPCompHighRes::acquireMDPPipes(hwc_context_t *ctx, hwc_layer_1_t* layer,
+        MdpPipeInfoHighRes& pipe_info,
+        ePipeType type) {
+    const int lSplit = getLeftSplit(ctx, mDpy);
+
+    hwc_rect_t dst = layer->displayFrame;
+    pipe_info.lIndex = ovutils::OV_INVALID;
+    pipe_info.rIndex = ovutils::OV_INVALID;
+
+    if (dst.left < lSplit) {
+        pipe_info.lIndex = getMdpPipe(ctx, type, Overlay::MIXER_LEFT);
+        if(pipe_info.lIndex == ovutils::OV_INVALID)
+            return false;
+    }
+
+    if(dst.right > lSplit) {
+        pipe_info.rIndex = getMdpPipe(ctx, type, Overlay::MIXER_RIGHT);
+        if(pipe_info.rIndex == ovutils::OV_INVALID)
+            return false;
+    }
+
+    return true;
+}
+
+bool MDPCompHighRes::allocLayerPipes(hwc_context_t *ctx,
+        hwc_display_contents_1_t* list) {
+    for(int index = 0 ; index < mCurrentFrame.layerCount; index++) {
+
+        if(mCurrentFrame.isFBComposed[index]) continue;
+
+        hwc_layer_1_t* layer = &list->hwLayers[index];
+        private_handle_t *hnd = (private_handle_t *)layer->handle;
+        int mdpIndex = mCurrentFrame.layerToMDP[index];
+        PipeLayerPair& info = mCurrentFrame.mdpToLayer[mdpIndex];
+        info.pipeInfo = new MdpPipeInfoHighRes;
+        info.rot = NULL;
+        MdpPipeInfoHighRes& pipe_info = *(MdpPipeInfoHighRes*)info.pipeInfo;
+        ePipeType type = MDPCOMP_OV_ANY;
+
+        if(isYuvBuffer(hnd)) {
+            type = MDPCOMP_OV_VG;
+        } else if(!qhwc::needsScaling(ctx, layer, mDpy)
+            && Overlay::getDMAMode() != Overlay::DMA_BLOCK_MODE
+            && ctx->mMDP.version >= qdutils::MDSS_V5) {
+            type = MDPCOMP_OV_DMA;
+        }
+
+        if(!acquireMDPPipes(ctx, layer, pipe_info, type)) {
+            ALOGD_IF(isDebug(), "%s: Unable to get pipe for type = %d",
+                    __FUNCTION__, (int) type);
+            return false;
+        }
+    }
+    return true;
+}
+
+/*
+ * Configures pipe(s) for MDP composition
+ */
+int MDPCompHighRes::configure(hwc_context_t *ctx, hwc_layer_1_t *layer,
+        PipeLayerPair& PipeLayerPair) {
+    MdpPipeInfoHighRes& mdp_info =
+        *(static_cast<MdpPipeInfoHighRes*>(PipeLayerPair.pipeInfo));
+    eZorder zOrder = static_cast<eZorder>(mdp_info.zOrder);
+    eIsFg isFg = IS_FG_OFF;
+    eMdpFlags mdpFlagsL = OV_MDP_BACKEND_COMPOSITION;
+    eDest lDest = mdp_info.lIndex;
+    eDest rDest = mdp_info.rIndex;
+
+    ALOGD_IF(isDebug(),"%s: configuring: layer: %p z_order: %d dest_pipeL: %d"
+             "dest_pipeR: %d",__FUNCTION__, layer, zOrder, lDest, rDest);
+
+    return configureHighRes(ctx, layer, mDpy, mdpFlagsL, zOrder, isFg, lDest,
+                            rDest, &PipeLayerPair.rot);
+}
+
+bool MDPCompHighRes::draw(hwc_context_t *ctx, hwc_display_contents_1_t* list) {
+
+    if(!isEnabled()) {
+        ALOGD_IF(isDebug(),"%s: MDP Comp not configured", __FUNCTION__);
+        return true;
+    }
+
+    if(!ctx || !list) {
+        ALOGE("%s: invalid contxt or list",__FUNCTION__);
+        return false;
+    }
+
+    if(ctx->listStats[mDpy].numAppLayers > MAX_NUM_APP_LAYERS) {
+        ALOGD_IF(isDebug(),"%s: Exceeding max layer count", __FUNCTION__);
+        return true;
+    }
+
+    /* reset Invalidator */
+    if(idleInvalidator && !sIdleFallBack && mCurrentFrame.mdpCount)
+        idleInvalidator->markForSleep();
+
+    overlay::Overlay& ov = *ctx->mOverlay;
+    LayerProp *layerProp = ctx->layerProp[mDpy];
+
+    int numHwLayers = ctx->listStats[mDpy].numAppLayers;
+    for(int i = 0; i < numHwLayers && mCurrentFrame.mdpCount; i++ )
+    {
+        if(mCurrentFrame.isFBComposed[i]) continue;
+
+        hwc_layer_1_t *layer = &list->hwLayers[i];
+        private_handle_t *hnd = (private_handle_t *)layer->handle;
+        if(!hnd) {
+            ALOGE("%s handle null", __FUNCTION__);
+            return false;
+        }
+
+        if(!(layerProp[i].mFlags & HWC_MDPCOMP)) {
+            continue;
+        }
+
+        int mdpIndex = mCurrentFrame.layerToMDP[i];
+
+        MdpPipeInfoHighRes& pipe_info =
+            *(MdpPipeInfoHighRes*)mCurrentFrame.mdpToLayer[mdpIndex].pipeInfo;
+        Rotator *rot = mCurrentFrame.mdpToLayer[mdpIndex].rot;
+
+        ovutils::eDest indexL = pipe_info.lIndex;
+        ovutils::eDest indexR = pipe_info.rIndex;
+
+        int fd = hnd->fd;
+        int offset = hnd->offset;
+
+        if(ctx->mAD->isModeOn()) {
+            if(ctx->mAD->draw(ctx, fd, offset)) {
+                fd = ctx->mAD->getDstFd(ctx);
+                offset = ctx->mAD->getDstOffset(ctx);
+            }
+        }
+
+        if(rot) {
+            rot->queueBuffer(fd, offset);
+            fd = rot->getDstMemId();
+            offset = rot->getDstOffset();
+        }
+
+        //************* play left mixer **********
+        if(indexL != ovutils::OV_INVALID) {
+            ovutils::eDest destL = (ovutils::eDest)indexL;
+            ALOGD_IF(isDebug(),"%s: MDP Comp: Drawing layer: %p hnd: %p \
+                     using  pipe: %d", __FUNCTION__, layer, hnd, indexL );
+            if (!ov.queueBuffer(fd, offset, destL)) {
+                ALOGE("%s: queueBuffer failed for left mixer", __FUNCTION__);
+                return false;
+            }
+        }
+
+        //************* play right mixer **********
+        if(indexR != ovutils::OV_INVALID) {
+            ovutils::eDest destR = (ovutils::eDest)indexR;
+            ALOGD_IF(isDebug(),"%s: MDP Comp: Drawing layer: %p hnd: %p \
+                     using  pipe: %d", __FUNCTION__, layer, hnd, indexR );
+            if (!ov.queueBuffer(fd, offset, destR)) {
+                ALOGE("%s: queueBuffer failed for right mixer", __FUNCTION__);
+                return false;
+            }
+        }
+
+        layerProp[i].mFlags &= ~HWC_MDPCOMP;
+    }
+
+    return true;
+}
+}; //namespace
+
diff --git a/msm8974/libhwcomposer/hwc_mdpcomp.h b/msm8974/libhwcomposer/hwc_mdpcomp.h
new file mode 100644
index 0000000..ab8fe48
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_mdpcomp.h
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HWC_MDP_COMP
+#define HWC_MDP_COMP
+
+#include <hwc_utils.h>
+#include <idle_invalidator.h>
+#include <cutils/properties.h>
+#include <overlay.h>
+
+#define DEFAULT_IDLE_TIME 2000
+#define MAX_PIPES_PER_MIXER 4
+
+namespace overlay {
+class Rotator;
+};
+
+namespace qhwc {
+namespace ovutils = overlay::utils;
+
+class MDPComp {
+public:
+    explicit MDPComp(int);
+    virtual ~MDPComp(){};
+    /*sets up mdp comp for the current frame */
+    int prepare(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    /* draw */
+    virtual bool draw(hwc_context_t *ctx, hwc_display_contents_1_t *list) = 0;
+    /* dumpsys */
+    void dump(android::String8& buf);
+    void reset() { mCurrentFrame.reset(0); }
+    int getMDPCompCount() { return mCurrentFrame.mdpCount; }
+
+    static MDPComp* getObject(const int& width, const int& rightSplit,
+            const int& dpy);
+    /* Handler to invoke frame redraw on Idle Timer expiry */
+    static void timeout_handler(void *udata);
+    /* Initialize MDP comp*/
+    static bool init(hwc_context_t *ctx);
+    static void resetIdleFallBack() { sIdleFallBack = false; }
+
+protected:
+    enum { MAX_SEC_LAYERS = 1 }; //TODO add property support
+
+    enum ePipeType {
+        MDPCOMP_OV_RGB = ovutils::OV_MDP_PIPE_RGB,
+        MDPCOMP_OV_VG = ovutils::OV_MDP_PIPE_VG,
+        MDPCOMP_OV_DMA = ovutils::OV_MDP_PIPE_DMA,
+        MDPCOMP_OV_ANY,
+    };
+
+    /* mdp pipe data */
+    struct MdpPipeInfo {
+        int zOrder;
+        virtual ~MdpPipeInfo(){};
+    };
+
+    /* per layer data */
+    struct PipeLayerPair {
+        MdpPipeInfo *pipeInfo;
+        overlay::Rotator* rot;
+        int listIndex;
+    };
+
+    /* per frame data */
+    struct FrameInfo {
+        /* maps layer list to mdp list */
+        int layerCount;
+        int layerToMDP[MAX_NUM_APP_LAYERS];
+
+        /* maps mdp list to layer list */
+        int mdpCount;
+        struct PipeLayerPair mdpToLayer[MAX_PIPES_PER_MIXER];
+
+        /* layer composing on FB? */
+        int fbCount;
+        bool isFBComposed[MAX_NUM_APP_LAYERS];
+
+        bool needsRedraw;
+        int fbZ;
+
+        /* c'tor */
+        FrameInfo();
+        /* clear old frame data */
+        void reset(const int& numLayers);
+        void map();
+    };
+
+    /* cached data */
+    struct LayerCache {
+        int layerCount;
+        int mdpCount;
+        int fbCount;
+        int fbZ;
+        buffer_handle_t hnd[MAX_NUM_APP_LAYERS];
+
+        /* c'tor */
+        LayerCache();
+        /* clear caching info*/
+        void reset();
+        void cacheAll(hwc_display_contents_1_t* list);
+        void updateCounts(const FrameInfo&);
+    };
+
+    /* allocates pipe from pipe book */
+    virtual bool allocLayerPipes(hwc_context_t *ctx,
+                                 hwc_display_contents_1_t* list) = 0;
+    /* allocate MDP pipes from overlay */
+    ovutils::eDest getMdpPipe(hwc_context_t *ctx, ePipeType type, int mixer);
+    /* configures MPD pipes */
+    virtual int configure(hwc_context_t *ctx, hwc_layer_1_t *layer,
+                          PipeLayerPair& pipeLayerPair) = 0;
+    /* Checks for pipes needed versus pipes available */
+    virtual bool arePipesAvailable(hwc_context_t *ctx,
+            hwc_display_contents_1_t* list) = 0;
+
+    /* set/reset flags for MDPComp */
+    void setMDPCompLayerFlags(hwc_context_t *ctx,
+                              hwc_display_contents_1_t* list);
+    /* checks for conditions where mdpcomp is not possible */
+    bool isFrameDoable(hwc_context_t *ctx);
+    /* checks for conditions where RGB layers cannot be bypassed */
+    bool isFullFrameDoable(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    /* checks if full MDP comp can be done */
+    bool fullMDPComp(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    /* check if we can use layer cache to do at least partial MDP comp */
+    bool partialMDPComp(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    /* Partial MDP comp that uses caching to save power as primary goal */
+    bool cacheBasedComp(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    /* Partial MDP comp that uses number of pixels to optimize perf goal */
+    bool loadBasedComp(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    /* Checks if its worth doing load based partial comp */
+    bool isLoadBasedCompDoable(hwc_context_t *ctx,
+            hwc_display_contents_1_t* list);
+    /* checks for conditions where only video can be bypassed */
+    bool isOnlyVideoDoable(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    /* checks for conditions where YUV layers cannot be bypassed */
+    bool isYUVDoable(hwc_context_t* ctx, hwc_layer_1_t* layer);
+
+    /* Is debug enabled */
+    static bool isDebug() { return sDebugLogs ? true : false; };
+    /* Is feature enabled */
+    static bool isEnabled() { return sEnabled; };
+    /* checks for mdp comp dimension limitation */
+    bool isValidDimension(hwc_context_t *ctx, hwc_layer_1_t *layer);
+    /* tracks non updating layers*/
+    void updateLayerCache(hwc_context_t* ctx, hwc_display_contents_1_t* list);
+    /* optimize layers for mdp comp*/
+    bool batchLayers(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    /* updates cache map with YUV info */
+    void updateYUV(hwc_context_t* ctx, hwc_display_contents_1_t* list);
+    bool programMDP(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    bool programYUV(hwc_context_t *ctx, hwc_display_contents_1_t* list);
+    void reset(const int& numAppLayers, hwc_display_contents_1_t* list);
+    bool isSupportedForMDPComp(hwc_context_t *ctx, hwc_layer_1_t* layer);
+
+    int mDpy;
+    static bool sEnabled;
+    static bool sEnableMixedMode;
+    static bool sDebugLogs;
+    static bool sIdleFallBack;
+    static int sMaxPipesPerMixer;
+    static IdleInvalidator *idleInvalidator;
+    struct FrameInfo mCurrentFrame;
+    struct LayerCache mCachedFrame;
+};
+
+class MDPCompLowRes : public MDPComp {
+public:
+    explicit MDPCompLowRes(int dpy):MDPComp(dpy){};
+    virtual ~MDPCompLowRes(){};
+    virtual bool draw(hwc_context_t *ctx, hwc_display_contents_1_t *list);
+
+private:
+    struct MdpPipeInfoLowRes : public MdpPipeInfo {
+        ovutils::eDest index;
+        virtual ~MdpPipeInfoLowRes() {};
+    };
+
+    /* configure's overlay pipes for the frame */
+    virtual int configure(hwc_context_t *ctx, hwc_layer_1_t *layer,
+                          PipeLayerPair& pipeLayerPair);
+
+    /* allocates pipes to selected candidates */
+    virtual bool allocLayerPipes(hwc_context_t *ctx,
+                                 hwc_display_contents_1_t* list);
+
+    /* Checks for pipes needed versus pipes available */
+    virtual bool arePipesAvailable(hwc_context_t *ctx,
+            hwc_display_contents_1_t* list);
+};
+
+class MDPCompHighRes : public MDPComp {
+public:
+    explicit MDPCompHighRes(int dpy):MDPComp(dpy){};
+    virtual ~MDPCompHighRes(){};
+    virtual bool draw(hwc_context_t *ctx, hwc_display_contents_1_t *list);
+private:
+    struct MdpPipeInfoHighRes : public MdpPipeInfo {
+        ovutils::eDest lIndex;
+        ovutils::eDest rIndex;
+        virtual ~MdpPipeInfoHighRes() {};
+    };
+
+    bool acquireMDPPipes(hwc_context_t *ctx, hwc_layer_1_t* layer,
+                         MdpPipeInfoHighRes& pipe_info, ePipeType type);
+
+    /* configure's overlay pipes for the frame */
+    virtual int configure(hwc_context_t *ctx, hwc_layer_1_t *layer,
+                          PipeLayerPair& pipeLayerPair);
+
+    /* allocates pipes to selected candidates */
+    virtual bool allocLayerPipes(hwc_context_t *ctx,
+                                 hwc_display_contents_1_t* list);
+
+    /* Checks for pipes needed versus pipes available */
+    virtual bool arePipesAvailable(hwc_context_t *ctx,
+            hwc_display_contents_1_t* list);
+
+    int pipesNeeded(hwc_context_t *ctx, hwc_display_contents_1_t* list,
+            int mixer);
+};
+
+}; //namespace
+#endif
diff --git a/msm8974/libhwcomposer/hwc_qclient.cpp b/msm8974/libhwcomposer/hwc_qclient.cpp
new file mode 100644
index 0000000..691ae0b
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_qclient.cpp
@@ -0,0 +1,111 @@
+/*
+ *  Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR CLIENTS; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <hwc_qclient.h>
+#include <IQService.h>
+#include <hwc_utils.h>
+
+#define QCLIENT_DEBUG 0
+
+using namespace android;
+using namespace qService;
+
+namespace qClient {
+
+// ----------------------------------------------------------------------------
+QClient::QClient(hwc_context_t *ctx) : mHwcContext(ctx),
+        mMPDeathNotifier(new MPDeathNotifier(ctx))
+{
+    ALOGD_IF(QCLIENT_DEBUG, "QClient Constructor invoked");
+}
+
+QClient::~QClient()
+{
+    ALOGD_IF(QCLIENT_DEBUG,"QClient Destructor invoked");
+}
+
+status_t QClient::notifyCallback(uint32_t msg, uint32_t value) {
+    switch(msg) {
+        case IQService::SECURING:
+            securing(value);
+            break;
+        case IQService::UNSECURING:
+            unsecuring(value);
+            break;
+        case IQService::SCREEN_REFRESH:
+            return screenRefresh();
+            break;
+        default:
+            return NO_ERROR;
+    }
+    return NO_ERROR;
+}
+
+void QClient::securing(uint32_t startEnd) {
+    Locker::Autolock _sl(mHwcContext->mDrawLock);
+    //The only way to make this class in this process subscribe to media
+    //player's death.
+    IMediaDeathNotifier::getMediaPlayerService();
+
+    mHwcContext->mSecuring = startEnd;
+    //We're done securing
+    if(startEnd == IQService::END)
+        mHwcContext->mSecureMode = true;
+    if(mHwcContext->proc)
+        mHwcContext->proc->invalidate(mHwcContext->proc);
+}
+
+void QClient::unsecuring(uint32_t startEnd) {
+    Locker::Autolock _sl(mHwcContext->mDrawLock);
+    mHwcContext->mSecuring = startEnd;
+    //We're done unsecuring
+    if(startEnd == IQService::END)
+        mHwcContext->mSecureMode = false;
+    if(mHwcContext->proc)
+        mHwcContext->proc->invalidate(mHwcContext->proc);
+}
+
+void QClient::MPDeathNotifier::died() {
+    Locker::Autolock _sl(mHwcContext->mDrawLock);
+    ALOGD_IF(QCLIENT_DEBUG, "Media Player died");
+    mHwcContext->mSecuring = false;
+    mHwcContext->mSecureMode = false;
+    if(mHwcContext->proc)
+        mHwcContext->proc->invalidate(mHwcContext->proc);
+}
+
+android::status_t QClient::screenRefresh() {
+    status_t result = NO_INIT;
+    if(mHwcContext->proc) {
+        mHwcContext->proc->invalidate(mHwcContext->proc);
+        result = NO_ERROR;
+    }
+    return result;
+}
+}
diff --git a/msm8974/libhwcomposer/hwc_qclient.h b/msm8974/libhwcomposer/hwc_qclient.h
new file mode 100644
index 0000000..9cb2680
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_qclient.h
@@ -0,0 +1,68 @@
+/*
+ *  Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR CLIENTS; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANDROID_QCLIENT_H
+#define ANDROID_QCLIENT_H
+
+#include <utils/Errors.h>
+#include <sys/types.h>
+#include <cutils/log.h>
+#include <binder/IServiceManager.h>
+#include <media/IMediaDeathNotifier.h>
+#include <IQClient.h>
+
+struct hwc_context_t;
+
+namespace qClient {
+// ----------------------------------------------------------------------------
+
+class QClient : public BnQClient {
+public:
+    QClient(hwc_context_t *ctx);
+    virtual ~QClient();
+    virtual android::status_t notifyCallback(uint32_t msg, uint32_t value);
+
+private:
+    //Notifies of Media Player death
+    class MPDeathNotifier : public android::IMediaDeathNotifier {
+    public:
+        MPDeathNotifier(hwc_context_t* ctx) : mHwcContext(ctx){}
+        virtual void died();
+        hwc_context_t *mHwcContext;
+    };
+
+    void securing(uint32_t startEnd);
+    void unsecuring(uint32_t startEnd);
+    android::status_t screenRefresh();
+
+    hwc_context_t *mHwcContext;
+    const android::sp<android::IMediaDeathNotifier> mMPDeathNotifier;
+};
+}; // namespace qClient
+#endif // ANDROID_QCLIENT_H
diff --git a/msm8974/libhwcomposer/hwc_uevents.cpp b/msm8974/libhwcomposer/hwc_uevents.cpp
new file mode 100644
index 0000000..cb13c95
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_uevents.cpp
@@ -0,0 +1,213 @@
+
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define UEVENT_DEBUG 0
+#include <hardware_legacy/uevent.h>
+#include <utils/Log.h>
+#include <sys/resource.h>
+#include <sys/prctl.h>
+#include <string.h>
+#include <stdlib.h>
+#include "hwc_utils.h"
+#include "hwc_fbupdate.h"
+#include "hwc_mdpcomp.h"
+#include "hwc_copybit.h"
+#include "comptype.h"
+#include "external.h"
+#include "mdp_version.h"
+
+namespace qhwc {
+
+#define HWC_UEVENT_THREAD_NAME "hwcUeventThread"
+
+/* External Display states */
+enum {
+    EXTERNAL_OFFLINE = 0,
+    EXTERNAL_ONLINE,
+    EXTERNAL_PAUSE,
+    EXTERNAL_RESUME
+};
+
+static bool isHDMI(const char* str)
+{
+    if(strcasestr("change@/devices/virtual/switch/hdmi", str))
+        return true;
+    return false;
+}
+
+static void handle_uevent(hwc_context_t* ctx, const char* udata, int len)
+{
+    const char *str = udata;
+
+    if(!strcasestr("change@/devices/virtual/switch/hdmi", str) &&
+       !strcasestr("change@/devices/virtual/switch/wfd", str)) {
+        ALOGD_IF(UEVENT_DEBUG, "%s: Not Ext Disp Event ", __FUNCTION__);
+        return;
+    }
+    int connected = -1; // initial value - will be set to  1/0 based on hotplug
+    int extDpyNum = HWC_DISPLAY_EXTERNAL;
+    char property[PROPERTY_VALUE_MAX];
+    if((property_get("persist.sys.wfd.virtual", property, NULL) > 0) &&
+            (!strncmp(property, "1", PROPERTY_VALUE_MAX ) ||
+             (!strncasecmp(property,"true", PROPERTY_VALUE_MAX )))) {
+        // This means we are using Google API to trigger WFD Display
+        extDpyNum = HWC_DISPLAY_VIRTUAL;
+
+    }
+
+    int dpy = isHDMI(str) ? HWC_DISPLAY_EXTERNAL : extDpyNum;
+
+    // update extDpyNum
+    ctx->mExtDisplay->setExtDpyNum(dpy);
+
+    // parse HDMI/WFD switch state for connect/disconnect
+    // for HDMI:
+    // The event will be of the form:
+    // change@/devices/virtual/switch/hdmi ACTION=change
+    // SWITCH_STATE=1 or SWITCH_STATE=0
+    while(*str) {
+        if (!strncmp(str, "SWITCH_STATE=", strlen("SWITCH_STATE="))) {
+            connected = atoi(str + strlen("SWITCH_STATE="));
+            //Disabled until SF calls unblank
+            ctx->dpyAttr[HWC_DISPLAY_EXTERNAL].isActive = false;
+            //Ignored for Virtual Displays
+            //ToDo: we can do this in a much better way
+            ctx->dpyAttr[HWC_DISPLAY_VIRTUAL].isActive = true;
+            break;
+        }
+        str += strlen(str) + 1;
+        if (str - udata >= len)
+            break;
+    }
+
+    switch(connected) {
+        case EXTERNAL_OFFLINE:
+            {   // disconnect event
+                ctx->mExtDisplay->processUEventOffline(udata);
+                Locker::Autolock _l(ctx->mDrawLock);
+                clearSecondaryObjs(ctx, dpy);
+                ALOGD("%s sending hotplug: connected = %d and dpy:%d",
+                      __FUNCTION__, connected, dpy);
+                ctx->dpyAttr[dpy].connected = false;
+                //hwc comp could be on
+                ctx->proc->hotplug(ctx->proc, dpy, connected);
+                break;
+            }
+        case EXTERNAL_ONLINE:
+            {   // connect case
+                {
+                    //Force composition to give up resources like pipes and
+                    //close fb. For example if assertive display is going on,
+                    //fb2 could be open, thus connecting Layer Mixer#0 to
+                    //WriteBack module. If HDMI attempts to open fb1, the driver
+                    //will try to attach Layer Mixer#0 to HDMI INT, which will
+                    //fail, since Layer Mixer#0 is still connected to WriteBack.
+                    //This block will force composition to close fb2 in above
+                    //example.
+                    Locker::Autolock _l(ctx->mDrawLock);
+                    ctx->dpyAttr[dpy].isConfiguring = true;
+                    ctx->dpyAttr[dpy].connected = false;
+                    ctx->proc->invalidate(ctx->proc);
+                }
+                //2 cycles for slower content
+                usleep(ctx->dpyAttr[HWC_DISPLAY_PRIMARY].vsync_period
+                        * 2 / 1000);
+                ctx->mExtDisplay->processUEventOnline(udata);
+                {
+                    Locker::Autolock _l(ctx->mDrawLock);
+                    ctx->dpyAttr[dpy].isPause = false;
+                    setupSecondaryObjs(ctx, dpy);
+                    ALOGD("%s sending hotplug: connected = %d", __FUNCTION__,
+                            connected);
+                    ctx->dpyAttr[dpy].connected = true;
+                    ctx->proc->hotplug(ctx->proc, dpy, connected);
+                }
+                break;
+            }
+        case EXTERNAL_PAUSE:
+            {   // pause case
+                ALOGD("%s Received Pause event",__FUNCTION__);
+                Locker::Autolock _l(ctx->mDrawLock);
+                ctx->dpyAttr[dpy].isActive = true;
+                ctx->dpyAttr[dpy].isPause = true;
+                break;
+            }
+        case EXTERNAL_RESUME:
+            {  // resume case
+                ALOGD("%s Received resume event",__FUNCTION__);
+                //Treat Resume as Online event
+                //Since external didnt have any pipes, force primary to give up
+                //its pipes; we don't allow inter-mixer pipe transfers.
+                {
+                    Locker::Autolock _l(ctx->mDrawLock);
+                    ctx->dpyAttr[dpy].isConfiguring = true;
+                    ctx->dpyAttr[dpy].isActive = true;
+                    ctx->proc->invalidate(ctx->proc);
+                }
+                usleep(ctx->dpyAttr[HWC_DISPLAY_PRIMARY].vsync_period
+                        * 2 / 1000);
+                //At this point external has all the pipes it would need.
+                {
+                    Locker::Autolock _l(ctx->mDrawLock);
+                    ctx->dpyAttr[dpy].isPause = false;
+                    ctx->proc->invalidate(ctx->proc);
+                }
+                break;
+            }
+        default:
+            {
+                ALOGE("ignore event and connected:%d",connected);
+                break;
+            }
+    }
+}
+
+static void *uevent_loop(void *param)
+{
+    int len = 0;
+    static char udata[PAGE_SIZE];
+    hwc_context_t * ctx = reinterpret_cast<hwc_context_t *>(param);
+    char thread_name[64] = HWC_UEVENT_THREAD_NAME;
+    prctl(PR_SET_NAME, (unsigned long) &thread_name, 0, 0, 0);
+    setpriority(PRIO_PROCESS, 0, HAL_PRIORITY_URGENT_DISPLAY);
+    uevent_init();
+
+    while(1) {
+        len = uevent_next_event(udata, sizeof(udata) - 2);
+        handle_uevent(ctx, udata, len);
+    }
+
+    return NULL;
+}
+
+void init_uevent_thread(hwc_context_t* ctx)
+{
+    pthread_t uevent_thread;
+    int ret;
+
+    ALOGI("Initializing UEVENT Thread");
+    ret = pthread_create(&uevent_thread, NULL, uevent_loop, (void*) ctx);
+    if (ret) {
+        ALOGE("%s: failed to create %s: %s", __FUNCTION__,
+            HWC_UEVENT_THREAD_NAME, strerror(ret));
+    }
+}
+
+}; //namespace
diff --git a/msm8974/libhwcomposer/hwc_utils.cpp b/msm8974/libhwcomposer/hwc_utils.cpp
new file mode 100644
index 0000000..3379923
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_utils.cpp
@@ -0,0 +1,1217 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define ATRACE_TAG (ATRACE_TAG_GRAPHICS | ATRACE_TAG_HAL)
+#define HWC_UTILS_DEBUG 0
+#include <math.h>
+#include <sys/ioctl.h>
+#include <binder/IServiceManager.h>
+#include <EGL/egl.h>
+#include <cutils/properties.h>
+#include <utils/Trace.h>
+#include <gralloc_priv.h>
+#include <overlay.h>
+#include <overlayRotator.h>
+#include <overlayWriteback.h>
+#include "hwc_utils.h"
+#include "hwc_mdpcomp.h"
+#include "hwc_fbupdate.h"
+#include "hwc_ad.h"
+#include "mdp_version.h"
+#include "hwc_copybit.h"
+#include "external.h"
+#include "hwc_qclient.h"
+#include "QService.h"
+#include "comptype.h"
+
+using namespace qClient;
+using namespace qService;
+using namespace android;
+using namespace overlay;
+using namespace overlay::utils;
+namespace ovutils = overlay::utils;
+
+namespace qhwc {
+
+static int openFramebufferDevice(hwc_context_t *ctx)
+{
+    struct fb_fix_screeninfo finfo;
+    struct fb_var_screeninfo info;
+
+    int fb_fd = openFb(HWC_DISPLAY_PRIMARY);
+    if(fb_fd < 0) {
+        ALOGE("%s: Error Opening FB : %s", __FUNCTION__, strerror(errno));
+        return -errno;
+    }
+
+    if (ioctl(fb_fd, FBIOGET_VSCREENINFO, &info) == -1) {
+        ALOGE("%s:Error in ioctl FBIOGET_VSCREENINFO: %s", __FUNCTION__,
+                                                       strerror(errno));
+        close(fb_fd);
+        return -errno;
+    }
+
+    if (int(info.width) <= 0 || int(info.height) <= 0) {
+        // the driver doesn't return that information
+        // default to 160 dpi
+        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f);
+        info.height = ((info.yres * 25.4f)/160.0f + 0.5f);
+    }
+
+    float xdpi = (info.xres * 25.4f) / info.width;
+    float ydpi = (info.yres * 25.4f) / info.height;
+
+#ifdef MSMFB_METADATA_GET
+    struct msmfb_metadata metadata;
+    memset(&metadata, 0 , sizeof(metadata));
+    metadata.op = metadata_op_frame_rate;
+
+    if (ioctl(fb_fd, MSMFB_METADATA_GET, &metadata) == -1) {
+        ALOGE("%s:Error retrieving panel frame rate: %s", __FUNCTION__,
+                                                      strerror(errno));
+        close(fb_fd);
+        return -errno;
+    }
+
+    float fps  = metadata.data.panel_frame_rate;
+#else
+    //XXX: Remove reserved field usage on all baselines
+    //The reserved[3] field is used to store FPS by the driver.
+    float fps  = info.reserved[3] & 0xFF;
+#endif
+
+    if (ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo) == -1) {
+        ALOGE("%s:Error in ioctl FBIOGET_FSCREENINFO: %s", __FUNCTION__,
+                                                       strerror(errno));
+        close(fb_fd);
+        return -errno;
+    }
+
+    ctx->dpyAttr[HWC_DISPLAY_PRIMARY].fd = fb_fd;
+    //xres, yres may not be 32 aligned
+    ctx->dpyAttr[HWC_DISPLAY_PRIMARY].stride = finfo.line_length /(info.xres/8);
+    ctx->dpyAttr[HWC_DISPLAY_PRIMARY].xres = info.xres;
+    ctx->dpyAttr[HWC_DISPLAY_PRIMARY].yres = info.yres;
+    ctx->dpyAttr[HWC_DISPLAY_PRIMARY].xdpi = xdpi;
+    ctx->dpyAttr[HWC_DISPLAY_PRIMARY].ydpi = ydpi;
+    ctx->dpyAttr[HWC_DISPLAY_PRIMARY].vsync_period = 1000000000l / fps;
+
+    //Unblank primary on first boot
+    if(ioctl(fb_fd, FBIOBLANK,FB_BLANK_UNBLANK) < 0) {
+        ALOGE("%s: Failed to unblank display", __FUNCTION__);
+        return -errno;
+    }
+    ctx->dpyAttr[HWC_DISPLAY_PRIMARY].isActive = true;
+
+    return 0;
+}
+
+void initContext(hwc_context_t *ctx)
+{
+    memset(&ctx->dpyAttr, 0, sizeof(ctx->dpyAttr));
+    if(openFramebufferDevice(ctx) < 0) {
+        ALOGE("%s: failed to open framebuffer!!", __FUNCTION__);
+    }
+
+    overlay::Overlay::initOverlay();
+    ctx->mOverlay = overlay::Overlay::getInstance();
+    ctx->mRotMgr = new RotMgr();
+    ctx->mMDP.version = qdutils::MDPVersion::getInstance().getMDPVersion();
+    ctx->mMDP.hasOverlay = qdutils::MDPVersion::getInstance().hasOverlay();
+    ctx->mMDP.panel = qdutils::MDPVersion::getInstance().getPanelType();
+    const int rightSplit = qdutils::MDPVersion::getInstance().getRightSplit();
+    overlay::Overlay::initOverlay();
+    ctx->mOverlay = overlay::Overlay::getInstance();
+    ctx->mRotMgr = new RotMgr();
+
+    //Is created and destroyed only once for primary
+    //For external it could get created and destroyed multiple times depending
+    //on what external we connect to.
+    ctx->mFBUpdate[HWC_DISPLAY_PRIMARY] =
+        IFBUpdate::getObject(ctx->dpyAttr[HWC_DISPLAY_PRIMARY].xres,
+                rightSplit, HWC_DISPLAY_PRIMARY);
+
+    // Check if the target supports copybit compostion (dyn/mdp/c2d) to
+    // decide if we need to open the copybit module.
+    int compositionType =
+        qdutils::QCCompositionType::getInstance().getCompositionType();
+
+    if (compositionType & (qdutils::COMPOSITION_TYPE_DYN |
+                           qdutils::COMPOSITION_TYPE_MDP |
+                           qdutils::COMPOSITION_TYPE_C2D)) {
+            ctx->mCopyBit[HWC_DISPLAY_PRIMARY] = new CopyBit();
+    }
+
+    ctx->mExtDisplay = new ExternalDisplay(ctx);
+
+    for (uint32_t i = 0; i < MAX_DISPLAYS; i++) {
+        ctx->mLayerRotMap[i] = new LayerRotMap();
+    }
+
+    ctx->mMDPComp[HWC_DISPLAY_PRIMARY] =
+         MDPComp::getObject(ctx->dpyAttr[HWC_DISPLAY_PRIMARY].xres,
+                rightSplit, HWC_DISPLAY_PRIMARY);
+
+    MDPComp::init(ctx);
+    ctx->mAD = new AssertiveDisplay();
+
+    ctx->vstate.enable = false;
+    ctx->vstate.fakevsync = false;
+
+    //Right now hwc starts the service but anybody could do it, or it could be
+    //independent process as well.
+    QService::init();
+    sp<IQClient> client = new QClient(ctx);
+    interface_cast<IQService>(
+            defaultServiceManager()->getService(
+            String16("display.qservice")))->connect(client);
+
+    ALOGI("Initializing Qualcomm Hardware Composer");
+    ALOGI("MDP version: %d", ctx->mMDP.version);
+}
+
+void closeContext(hwc_context_t *ctx)
+{
+    if(ctx->mOverlay) {
+        delete ctx->mOverlay;
+        ctx->mOverlay = NULL;
+    }
+
+    if(ctx->mRotMgr) {
+        delete ctx->mRotMgr;
+        ctx->mRotMgr = NULL;
+    }
+
+    for(int i = 0; i < MAX_DISPLAYS; i++) {
+        if(ctx->mCopyBit[i]) {
+            delete ctx->mCopyBit[i];
+            ctx->mCopyBit[i] = NULL;
+        }
+    }
+
+    if(ctx->dpyAttr[HWC_DISPLAY_PRIMARY].fd) {
+        close(ctx->dpyAttr[HWC_DISPLAY_PRIMARY].fd);
+        ctx->dpyAttr[HWC_DISPLAY_PRIMARY].fd = -1;
+    }
+
+    if(ctx->mExtDisplay) {
+        delete ctx->mExtDisplay;
+        ctx->mExtDisplay = NULL;
+    }
+
+    for(int i = 0; i < MAX_DISPLAYS; i++) {
+        if(ctx->mFBUpdate[i]) {
+            delete ctx->mFBUpdate[i];
+            ctx->mFBUpdate[i] = NULL;
+        }
+        if(ctx->mMDPComp[i]) {
+            delete ctx->mMDPComp[i];
+            ctx->mMDPComp[i] = NULL;
+        }
+        if(ctx->mLayerRotMap[i]) {
+            delete ctx->mLayerRotMap[i];
+            ctx->mLayerRotMap[i] = NULL;
+        }
+    }
+
+    if(ctx->mAD) {
+        delete ctx->mAD;
+        ctx->mAD = NULL;
+    }
+}
+
+
+void dumpsys_log(android::String8& buf, const char* fmt, ...)
+{
+    va_list varargs;
+    va_start(varargs, fmt);
+    buf.appendFormatV(fmt, varargs);
+    va_end(varargs);
+}
+
+/* Calculates the destination position based on the action safe rectangle */
+void getActionSafePosition(hwc_context_t *ctx, int dpy, uint32_t& x,
+                           uint32_t& y, uint32_t& w, uint32_t& h) {
+
+    // if external supports underscan, do nothing
+    // it will be taken care in the driver
+    if(ctx->mExtDisplay->isCEUnderscanSupported())
+        return;
+
+    char value[PROPERTY_VALUE_MAX];
+    // Read action safe properties
+    property_get("persist.sys.actionsafe.width", value, "0");
+    int asWidthRatio = atoi(value);
+    property_get("persist.sys.actionsafe.height", value, "0");
+    int asHeightRatio = atoi(value);
+
+    if(!asWidthRatio && !asHeightRatio) {
+        //No action safe ratio set, return
+        return;
+    }
+
+    float wRatio = 1.0;
+    float hRatio = 1.0;
+    float xRatio = 1.0;
+    float yRatio = 1.0;
+
+    float fbWidth = ctx->dpyAttr[dpy].xres;
+    float fbHeight = ctx->dpyAttr[dpy].yres;
+
+    float asX = 0;
+    float asY = 0;
+    float asW = fbWidth;
+    float asH= fbHeight;
+
+    // based on the action safe ratio, get the Action safe rectangle
+    asW = fbWidth * (1.0f -  asWidthRatio / 100.0f);
+    asH = fbHeight * (1.0f -  asHeightRatio / 100.0f);
+    asX = (fbWidth - asW) / 2;
+    asY = (fbHeight - asH) / 2;
+
+    // calculate the position ratio
+    xRatio = (float)x/fbWidth;
+    yRatio = (float)y/fbHeight;
+    wRatio = (float)w/fbWidth;
+    hRatio = (float)h/fbHeight;
+
+    //Calculate the position...
+    x = (xRatio * asW) + asX;
+    y = (yRatio * asH) + asY;
+    w = (wRatio * asW);
+    h = (hRatio * asH);
+
+    return;
+}
+
+bool needsScaling(hwc_context_t* ctx, hwc_layer_1_t const* layer,
+        const int& dpy) {
+    int dst_w, dst_h, src_w, src_h;
+
+    hwc_rect_t displayFrame  = layer->displayFrame;
+    hwc_rect_t sourceCrop = integerizeSourceCrop(layer->sourceCropf);
+    trimLayer(ctx, dpy, layer->transform, sourceCrop, displayFrame);
+
+    dst_w = displayFrame.right - displayFrame.left;
+    dst_h = displayFrame.bottom - displayFrame.top;
+    src_w = sourceCrop.right - sourceCrop.left;
+    src_h = sourceCrop.bottom - sourceCrop.top;
+
+    if(((src_w != dst_w) || (src_h != dst_h)))
+        return true;
+
+    return false;
+}
+
+bool isAlphaScaled(hwc_context_t* ctx, hwc_layer_1_t const* layer,
+        const int& dpy) {
+    if(needsScaling(ctx, layer, dpy) && isAlphaPresent(layer)) {
+        return true;
+    }
+    return false;
+}
+
+bool isAlphaPresent(hwc_layer_1_t const* layer) {
+    private_handle_t *hnd = (private_handle_t *)layer->handle;
+    if(hnd) {
+        int format = hnd->format;
+        switch(format) {
+        case HAL_PIXEL_FORMAT_RGBA_8888:
+        case HAL_PIXEL_FORMAT_BGRA_8888:
+            // In any more formats with Alpha go here..
+            return true;
+        default : return false;
+        }
+    }
+    return false;
+}
+
+// Let CABL know we have a YUV layer
+static void setYUVProp(int yuvCount) {
+    static char property[PROPERTY_VALUE_MAX];
+    if(yuvCount > 0) {
+        if (property_get("hw.cabl.yuv", property, NULL) > 0) {
+            if (atoi(property) != 1) {
+                property_set("hw.cabl.yuv", "1");
+            }
+        }
+    } else {
+        if (property_get("hw.cabl.yuv", property, NULL) > 0) {
+            if (atoi(property) != 0) {
+                property_set("hw.cabl.yuv", "0");
+            }
+        }
+    }
+}
+
+void setListStats(hwc_context_t *ctx,
+        const hwc_display_contents_1_t *list, int dpy) {
+    const int prevYuvCount = ctx->listStats[dpy].yuvCount;
+    memset(&ctx->listStats[dpy], 0, sizeof(ListStats));
+    ctx->listStats[dpy].numAppLayers = list->numHwLayers - 1;
+    ctx->listStats[dpy].fbLayerIndex = list->numHwLayers - 1;
+    ctx->listStats[dpy].skipCount = 0;
+    ctx->listStats[dpy].needsAlphaScale = false;
+    ctx->listStats[dpy].preMultipliedAlpha = false;
+    ctx->listStats[dpy].planeAlpha = false;
+    ctx->listStats[dpy].isSecurePresent = false;
+    ctx->listStats[dpy].yuvCount = 0;
+
+    for (size_t i = 0; i < (size_t)ctx->listStats[dpy].numAppLayers; i++) {
+        hwc_layer_1_t const* layer = &list->hwLayers[i];
+        private_handle_t *hnd = (private_handle_t *)layer->handle;
+
+        // continue if number of app layers exceeds MAX_NUM_APP_LAYERS
+        if(ctx->listStats[dpy].numAppLayers > MAX_NUM_APP_LAYERS)
+            continue;
+
+        //reset yuv indices
+        ctx->listStats[dpy].yuvIndices[i] = -1;
+
+        if (isSecureBuffer(hnd)) {
+            ctx->listStats[dpy].isSecurePresent = true;
+        }
+
+        if (isSkipLayer(&list->hwLayers[i])) {
+            ctx->listStats[dpy].skipCount++;
+        } else if (UNLIKELY(isYuvBuffer(hnd))) {
+            int& yuvCount = ctx->listStats[dpy].yuvCount;
+            ctx->listStats[dpy].yuvIndices[yuvCount] = i;
+            yuvCount++;
+
+            if((layer->transform & HWC_TRANSFORM_ROT_90) &&
+                    canUseRotator(ctx, dpy)) {
+                if( (dpy == HWC_DISPLAY_PRIMARY) &&
+                        ctx->mOverlay->isPipeTypeAttached(OV_MDP_PIPE_DMA)) {
+                    ctx->isPaddingRound = true;
+                }
+                Overlay::setDMAMode(Overlay::DMA_BLOCK_MODE);
+            }
+        }
+        if(layer->blending == HWC_BLENDING_PREMULT)
+            ctx->listStats[dpy].preMultipliedAlpha = true;
+        if(layer->planeAlpha < 0xFF)
+            ctx->listStats[dpy].planeAlpha = true;
+        if(!ctx->listStats[dpy].needsAlphaScale)
+            ctx->listStats[dpy].needsAlphaScale =
+                    isAlphaScaled(ctx, layer, dpy);
+    }
+    setYUVProp(ctx->listStats[dpy].yuvCount);
+    //The marking of video begin/end is useful on some targets where we need
+    //to have a padding round to be able to shift pipes across mixers.
+    if(prevYuvCount != ctx->listStats[dpy].yuvCount) {
+        ctx->mVideoTransFlag = true;
+    }
+    if(dpy == HWC_DISPLAY_PRIMARY) {
+        ctx->mAD->markDoable(ctx, list);
+    }
+}
+
+
+static void calc_cut(double& leftCutRatio, double& topCutRatio,
+        double& rightCutRatio, double& bottomCutRatio, int orient) {
+    if(orient & HAL_TRANSFORM_FLIP_H) {
+        swap(leftCutRatio, rightCutRatio);
+    }
+    if(orient & HAL_TRANSFORM_FLIP_V) {
+        swap(topCutRatio, bottomCutRatio);
+    }
+    if(orient & HAL_TRANSFORM_ROT_90) {
+        //Anti clock swapping
+        double tmpCutRatio = leftCutRatio;
+        leftCutRatio = topCutRatio;
+        topCutRatio = rightCutRatio;
+        rightCutRatio = bottomCutRatio;
+        bottomCutRatio = tmpCutRatio;
+    }
+}
+
+bool isSecuring(hwc_context_t* ctx, hwc_layer_1_t const* layer) {
+    if((ctx->mMDP.version < qdutils::MDSS_V5) &&
+       (ctx->mMDP.version > qdutils::MDP_V3_0) &&
+        ctx->mSecuring) {
+        return true;
+    }
+    //  On A-Family, Secure policy is applied system wide and not on
+    //  buffers.
+    if (isSecureModePolicy(ctx->mMDP.version)) {
+        private_handle_t *hnd = (private_handle_t *)layer->handle;
+        if(ctx->mSecureMode) {
+            if (! isSecureBuffer(hnd)) {
+                // This code path executes for the following usecase:
+                // Some Apps in which first few seconds, framework
+                // sends non-secure buffer and with out destroying
+                // surfaces, switches to secure buffer thereby exposing
+                // vulnerability on A-family devices. Catch this situation
+                // and handle it gracefully by allowing it to be composed by
+                // GPU.
+                ALOGD_IF(HWC_UTILS_DEBUG, "%s: Handle non-secure video layer"
+                         "during secure playback gracefully", __FUNCTION__);
+                return true;
+            }
+        } else {
+            if (isSecureBuffer(hnd)) {
+                // This code path executes for the following usecase:
+                // For some Apps, when User terminates playback, Framework
+                // doesnt destroy video surface and video surface still
+                // comes to Display HAL. This exposes vulnerability on
+                // A-family. Catch this situation and handle it gracefully
+                // by allowing it to be composed by GPU.
+                ALOGD_IF(HWC_UTILS_DEBUG, "%s: Handle secure video layer"
+                         "during non-secure playback gracefully", __FUNCTION__);
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+bool isSecureModePolicy(int mdpVersion) {
+    if (mdpVersion < qdutils::MDSS_V5)
+        return true;
+    else
+        return false;
+}
+
+int getBlending(int blending) {
+    switch(blending) {
+    case HWC_BLENDING_NONE:
+        return overlay::utils::OVERLAY_BLENDING_OPAQUE;
+    case HWC_BLENDING_PREMULT:
+        return overlay::utils::OVERLAY_BLENDING_PREMULT;
+    case HWC_BLENDING_COVERAGE :
+    default:
+        return overlay::utils::OVERLAY_BLENDING_COVERAGE;
+    }
+}
+
+//Crops source buffer against destination and FB boundaries
+void calculate_crop_rects(hwc_rect_t& crop, hwc_rect_t& dst,
+                          const hwc_rect_t& scissor, int orient) {
+
+    int& crop_l = crop.left;
+    int& crop_t = crop.top;
+    int& crop_r = crop.right;
+    int& crop_b = crop.bottom;
+    int crop_w = crop.right - crop.left;
+    int crop_h = crop.bottom - crop.top;
+
+    int& dst_l = dst.left;
+    int& dst_t = dst.top;
+    int& dst_r = dst.right;
+    int& dst_b = dst.bottom;
+    int dst_w = abs(dst.right - dst.left);
+    int dst_h = abs(dst.bottom - dst.top);
+
+    const int& sci_l = scissor.left;
+    const int& sci_t = scissor.top;
+    const int& sci_r = scissor.right;
+    const int& sci_b = scissor.bottom;
+
+    double leftCutRatio = 0.0, rightCutRatio = 0.0, topCutRatio = 0.0,
+            bottomCutRatio = 0.0;
+
+    if(dst_l < sci_l) {
+        leftCutRatio = (double)(sci_l - dst_l) / (double)dst_w;
+        dst_l = sci_l;
+    }
+
+    if(dst_r > sci_r) {
+        rightCutRatio = (double)(dst_r - sci_r) / (double)dst_w;
+        dst_r = sci_r;
+    }
+
+    if(dst_t < sci_t) {
+        topCutRatio = (double)(sci_t - dst_t) / (double)dst_h;
+        dst_t = sci_t;
+    }
+
+    if(dst_b > sci_b) {
+        bottomCutRatio = (double)(dst_b - sci_b) / (double)dst_h;
+        dst_b = sci_b;
+    }
+
+    calc_cut(leftCutRatio, topCutRatio, rightCutRatio, bottomCutRatio, orient);
+    crop_l += crop_w * leftCutRatio;
+    crop_t += crop_h * topCutRatio;
+    crop_r -= crop_w * rightCutRatio;
+    crop_b -= crop_h * bottomCutRatio;
+}
+
+void getNonWormholeRegion(hwc_display_contents_1_t* list,
+                              hwc_rect_t& nwr)
+{
+    uint32_t last = list->numHwLayers - 1;
+    hwc_rect_t fbDisplayFrame = list->hwLayers[last].displayFrame;
+    //Initiliaze nwr to first frame
+    nwr.left =  list->hwLayers[0].displayFrame.left;
+    nwr.top =  list->hwLayers[0].displayFrame.top;
+    nwr.right =  list->hwLayers[0].displayFrame.right;
+    nwr.bottom =  list->hwLayers[0].displayFrame.bottom;
+
+    for (uint32_t i = 1; i < last; i++) {
+        hwc_rect_t displayFrame = list->hwLayers[i].displayFrame;
+        nwr.left   = min(nwr.left, displayFrame.left);
+        nwr.top    = min(nwr.top, displayFrame.top);
+        nwr.right  = max(nwr.right, displayFrame.right);
+        nwr.bottom = max(nwr.bottom, displayFrame.bottom);
+    }
+
+    //Intersect with the framebuffer
+    nwr.left   = max(nwr.left, fbDisplayFrame.left);
+    nwr.top    = max(nwr.top, fbDisplayFrame.top);
+    nwr.right  = min(nwr.right, fbDisplayFrame.right);
+    nwr.bottom = min(nwr.bottom, fbDisplayFrame.bottom);
+
+}
+
+void closeAcquireFds(hwc_display_contents_1_t* list, int dpy) {
+    if(LIKELY(list)) {
+        for(uint32_t i = 0; i < list->numHwLayers; i++) {
+            //Close the acquireFenceFds
+            //HWC_FRAMEBUFFER are -1 already by SF, rest we close.
+            if(list->hwLayers[i].acquireFenceFd >= 0) {
+                close(list->hwLayers[i].acquireFenceFd);
+                list->hwLayers[i].acquireFenceFd = -1;
+            }
+        }
+
+        //Writeback
+        if(dpy > HWC_DISPLAY_EXTERNAL && list->outbufAcquireFenceFd >= 0) {
+            close(list->outbufAcquireFenceFd);
+            list->outbufAcquireFenceFd = -1;
+        }
+    }
+}
+
+int hwc_sync(hwc_context_t *ctx, hwc_display_contents_1_t* list, int dpy,
+        int fd) {
+    ATRACE_CALL();
+    int ret = 0;
+    int acquireFd[MAX_NUM_APP_LAYERS];
+    int count = 0;
+    int releaseFd = -1;
+    int retireFd = -1;
+    int fbFd = -1;
+    bool swapzero = false;
+
+    struct mdp_buf_sync data;
+    memset(&data, 0, sizeof(data));
+    data.acq_fen_fd = acquireFd;
+    data.rel_fen_fd = &releaseFd;
+    data.retire_fen_fd = &retireFd;
+
+    char property[PROPERTY_VALUE_MAX];
+    if(property_get("debug.egl.swapinterval", property, "1") > 0) {
+        if(atoi(property) == 0)
+            swapzero = true;
+    }
+
+    for(uint32_t i = 0; i < ctx->mLayerRotMap[dpy]->getCount(); i++) {
+        int rotFd = ctx->mRotMgr->getRotDevFd();
+        int rotReleaseFd = -1;
+        int rotRetireFd = -1;
+        struct mdp_buf_sync rotData;
+        memset(&rotData, 0, sizeof(rotData));
+        rotData.acq_fen_fd =
+                &ctx->mLayerRotMap[dpy]->getLayer(i)->acquireFenceFd;
+        rotData.rel_fen_fd = &rotReleaseFd; //driver to populate this
+        rotData.retire_fen_fd = &rotRetireFd;
+        rotData.session_id = ctx->mLayerRotMap[dpy]->getRot(i)->getSessId();
+        int ret = 0;
+        ret = ioctl(rotFd, MSMFB_BUFFER_SYNC, &rotData);
+        if(ret < 0) {
+            ALOGE("%s: ioctl MSMFB_BUFFER_SYNC failed for rot sync, err=%s",
+                    __FUNCTION__, strerror(errno));
+        } else {
+            close(ctx->mLayerRotMap[dpy]->getLayer(i)->acquireFenceFd);
+            //For MDP to wait on.
+            ctx->mLayerRotMap[dpy]->getLayer(i)->acquireFenceFd =
+                    dup(rotReleaseFd);
+            //A buffer is free to be used by producer as soon as its copied to
+            //rotator
+            ctx->mLayerRotMap[dpy]->getLayer(i)->releaseFenceFd =
+                    rotReleaseFd;
+            //Not used for rotator
+            close(rotRetireFd);
+        }
+    }
+
+    //Accumulate acquireFenceFds for MDP
+    if(dpy > HWC_DISPLAY_EXTERNAL && list->outbufAcquireFenceFd >= 0) {
+        //Writeback output buffer
+        acquireFd[count++] = list->outbufAcquireFenceFd;
+    }
+
+    for(uint32_t i = 0; i < list->numHwLayers; i++) {
+        if(list->hwLayers[i].compositionType == HWC_OVERLAY &&
+                        list->hwLayers[i].acquireFenceFd >= 0) {
+            if(UNLIKELY(swapzero))
+                acquireFd[count++] = -1;
+            else
+                acquireFd[count++] = list->hwLayers[i].acquireFenceFd;
+        }
+        if(list->hwLayers[i].compositionType == HWC_FRAMEBUFFER_TARGET) {
+            if(UNLIKELY(swapzero))
+                acquireFd[count++] = -1;
+            else if(fd >= 0) {
+                //set the acquireFD from fd - which is coming from c2d
+                acquireFd[count++] = fd;
+                // Buffer sync IOCTL should be async when using c2d fence is
+                // used
+                data.flags &= ~MDP_BUF_SYNC_FLAG_WAIT;
+            } else if(list->hwLayers[i].acquireFenceFd >= 0)
+                acquireFd[count++] = list->hwLayers[i].acquireFenceFd;
+        }
+    }
+
+    data.acq_fen_fd_cnt = count;
+    fbFd = ctx->dpyAttr[dpy].fd;
+
+    //Waits for acquire fences, returns a release fence
+    if(LIKELY(!swapzero)) {
+        uint64_t start = systemTime();
+        ret = ioctl(fbFd, MSMFB_BUFFER_SYNC, &data);
+        ALOGD_IF(HWC_UTILS_DEBUG, "%s: time taken for MSMFB_BUFFER_SYNC IOCTL = %d",
+                            __FUNCTION__, (size_t) ns2ms(systemTime() - start));
+    }
+
+    if(ret < 0) {
+        ALOGE("%s: ioctl MSMFB_BUFFER_SYNC failed, err=%s",
+                  __FUNCTION__, strerror(errno));
+        ALOGE("%s: acq_fen_fd_cnt=%d flags=%d fd=%d dpy=%d numHwLayers=%d",
+              __FUNCTION__, data.acq_fen_fd_cnt, data.flags, fbFd,
+              dpy, list->numHwLayers);
+    }
+
+    for(uint32_t i = 0; i < list->numHwLayers; i++) {
+        if(list->hwLayers[i].compositionType == HWC_OVERLAY ||
+           list->hwLayers[i].compositionType == HWC_FRAMEBUFFER_TARGET) {
+            //Populate releaseFenceFds.
+            if(UNLIKELY(swapzero)) {
+                list->hwLayers[i].releaseFenceFd = -1;
+            } else if(list->hwLayers[i].releaseFenceFd < 0) {
+                //If rotator has not already populated this field.
+                list->hwLayers[i].releaseFenceFd = dup(releaseFd);
+            }
+        }
+    }
+
+    if(fd >= 0) {
+        close(fd);
+        fd = -1;
+    }
+
+    if (ctx->mCopyBit[dpy])
+        ctx->mCopyBit[dpy]->setReleaseFd(releaseFd);
+
+    //Signals when MDP finishes reading rotator buffers.
+    ctx->mLayerRotMap[dpy]->setReleaseFd(releaseFd);
+    close(releaseFd);
+
+    if(UNLIKELY(swapzero))
+        list->retireFenceFd = -1;
+    else
+        list->retireFenceFd = retireFd;
+    return ret;
+}
+
+void trimLayer(hwc_context_t *ctx, const int& dpy, const int& transform,
+        hwc_rect_t& crop, hwc_rect_t& dst) {
+    int hw_w = ctx->dpyAttr[dpy].xres;
+    int hw_h = ctx->dpyAttr[dpy].yres;
+    if(dst.left < 0 || dst.top < 0 ||
+            dst.right > hw_w || dst.bottom > hw_h) {
+        hwc_rect_t scissor = {0, 0, hw_w, hw_h };
+        qhwc::calculate_crop_rects(crop, dst, scissor, transform);
+    }
+}
+
+void setMdpFlags(hwc_layer_1_t *layer,
+        ovutils::eMdpFlags &mdpFlags,
+        int rotDownscale) {
+    private_handle_t *hnd = (private_handle_t *)layer->handle;
+    MetaData_t *metadata = (MetaData_t *)hnd->base_metadata;
+    const int& transform = layer->transform;
+
+    if(layer->blending == HWC_BLENDING_PREMULT) {
+        ovutils::setMdpFlags(mdpFlags,
+                ovutils::OV_MDP_BLEND_FG_PREMULT);
+    }
+
+    if(isYuvBuffer(hnd)) {
+        if(isSecureBuffer(hnd)) {
+            ovutils::setMdpFlags(mdpFlags,
+                    ovutils::OV_MDP_SECURE_OVERLAY_SESSION);
+        }
+        if(metadata && (metadata->operation & PP_PARAM_INTERLACED) &&
+                metadata->interlaced) {
+            ovutils::setMdpFlags(mdpFlags,
+                    ovutils::OV_MDP_DEINTERLACE);
+        }
+        //Pre-rotation will be used using rotator.
+        if(transform & HWC_TRANSFORM_ROT_90) {
+            ovutils::setMdpFlags(mdpFlags,
+                    ovutils::OV_MDP_SOURCE_ROTATED_90);
+        }
+    }
+
+    //No 90 component and no rot-downscale then flips done by MDP
+    //If we use rot then it might as well do flips
+    if(!(layer->transform & HWC_TRANSFORM_ROT_90) && !rotDownscale) {
+        if(layer->transform & HWC_TRANSFORM_FLIP_H) {
+            ovutils::setMdpFlags(mdpFlags, ovutils::OV_MDP_FLIP_H);
+        }
+
+        if(layer->transform & HWC_TRANSFORM_FLIP_V) {
+            ovutils::setMdpFlags(mdpFlags,  ovutils::OV_MDP_FLIP_V);
+        }
+    }
+
+    if(metadata &&
+        ((metadata->operation & PP_PARAM_HSIC)
+        || (metadata->operation & PP_PARAM_IGC)
+        || (metadata->operation & PP_PARAM_SHARP2))) {
+        ovutils::setMdpFlags(mdpFlags, ovutils::OV_MDP_PP_EN);
+    }
+}
+
+int configRotator(Rotator *rot, const Whf& whf,
+        hwc_rect_t& crop, const eMdpFlags& mdpFlags,
+        const eTransform& orient, const int& downscale) {
+    rot->setSource(whf);
+
+    if (qdutils::MDPVersion::getInstance().getMDPVersion() >=
+        qdutils::MDSS_V5) {
+        uint32_t crop_w = (crop.right - crop.left);
+        uint32_t crop_h = (crop.bottom - crop.top);
+        if (ovutils::isYuv(whf.format)) {
+            ovutils::normalizeCrop((uint32_t&)crop.left, crop_w);
+            ovutils::normalizeCrop((uint32_t&)crop.top, crop_h);
+            // For interlaced, crop.h should be 4-aligned
+            if ((mdpFlags & ovutils::OV_MDP_DEINTERLACE) && (crop_h % 4))
+                crop_h = ovutils::aligndown(crop_h, 4);
+            crop.right = crop.left + crop_w;
+            crop.bottom = crop.top + crop_h;
+        }
+        Dim rotCrop(crop.left, crop.top, crop_w, crop_h);
+        rot->setCrop(rotCrop);
+    }
+
+    rot->setFlags(mdpFlags);
+    rot->setTransform(orient);
+    rot->setDownscale(downscale);
+    if(!rot->commit()) return -1;
+    return 0;
+}
+
+int configMdp(Overlay *ov, const PipeArgs& parg,
+        const eTransform& orient, const hwc_rect_t& crop,
+        const hwc_rect_t& pos, const MetaData_t *metadata,
+        const eDest& dest) {
+    ov->setSource(parg, dest);
+    ov->setTransform(orient, dest);
+
+    int crop_w = crop.right - crop.left;
+    int crop_h = crop.bottom - crop.top;
+    Dim dcrop(crop.left, crop.top, crop_w, crop_h);
+    ov->setCrop(dcrop, dest);
+
+    int posW = pos.right - pos.left;
+    int posH = pos.bottom - pos.top;
+    Dim position(pos.left, pos.top, posW, posH);
+    ov->setPosition(position, dest);
+
+    if (metadata)
+        ov->setVisualParams(*metadata, dest);
+
+    if (!ov->commit(dest)) {
+        return -1;
+    }
+    return 0;
+}
+
+void updateSource(eTransform& orient, Whf& whf,
+        hwc_rect_t& crop) {
+    Dim srcCrop(crop.left, crop.top,
+            crop.right - crop.left,
+            crop.bottom - crop.top);
+    orient = static_cast<eTransform>(ovutils::getMdpOrient(orient));
+    preRotateSource(orient, whf, srcCrop);
+    if (qdutils::MDPVersion::getInstance().getMDPVersion() >=
+        qdutils::MDSS_V5) {
+        // Source for overlay will be the cropped (and rotated)
+        crop.left = 0;
+        crop.top = 0;
+        crop.right = srcCrop.w;
+        crop.bottom = srcCrop.h;
+        // Set width & height equal to sourceCrop w & h
+        whf.w = srcCrop.w;
+        whf.h = srcCrop.h;
+    } else {
+        crop.left = srcCrop.x;
+        crop.top = srcCrop.y;
+        crop.right = srcCrop.x + srcCrop.w;
+        crop.bottom = srcCrop.y + srcCrop.h;
+    }
+}
+
+int configureLowRes(hwc_context_t *ctx, hwc_layer_1_t *layer,
+        const int& dpy, eMdpFlags& mdpFlags, const eZorder& z,
+        const eIsFg& isFg, const eDest& dest, Rotator **rot) {
+
+    private_handle_t *hnd = (private_handle_t *)layer->handle;
+    if(!hnd) {
+        ALOGE("%s: layer handle is NULL", __FUNCTION__);
+        ctx->mLayerRotMap[dpy]->reset();
+        return -1;
+    }
+
+    MetaData_t *metadata = (MetaData_t *)hnd->base_metadata;
+
+    hwc_rect_t crop = integerizeSourceCrop(layer->sourceCropf);
+    hwc_rect_t dst = layer->displayFrame;
+    int transform = layer->transform;
+    eTransform orient = static_cast<eTransform>(transform);
+    int downscale = 0;
+    int rotFlags = ovutils::ROT_FLAGS_NONE;
+    Whf whf(getWidth(hnd), getHeight(hnd),
+            getMdpFormat(hnd->format), hnd->size);
+
+    uint32_t x = dst.left, y  = dst.top;
+    uint32_t w = dst.right - dst.left;
+    uint32_t h = dst.bottom - dst.top;
+
+    if(dpy) {
+        // Calculate the actionsafe dimensions for External(dpy = 1 or 2)
+        getActionSafePosition(ctx, dpy, x, y, w, h);
+        // Convert position to hwc_rect_t
+        dst.left = x;
+        dst.top = y;
+        dst.right = w + dst.left;
+        dst.bottom = h + dst.top;
+    }
+
+    if(isYuvBuffer(hnd) && ctx->mMDP.version >= qdutils::MDP_V4_2 &&
+       ctx->mMDP.version < qdutils::MDSS_V5) {
+        downscale =  getDownscaleFactor(
+            crop.right - crop.left,
+            crop.bottom - crop.top,
+            dst.right - dst.left,
+            dst.bottom - dst.top);
+        if(downscale) {
+            rotFlags = ROT_DOWNSCALE_ENABLED;
+        }
+    }
+
+    setMdpFlags(layer, mdpFlags, downscale);
+    trimLayer(ctx, dpy, transform, crop, dst);
+
+    //Will do something only if feature enabled and conditions suitable
+    //hollow call otherwise
+    if(ctx->mAD->prepare(ctx, crop, whf, hnd)) {
+        overlay::Writeback *wb = overlay::Writeback::getInstance();
+        whf.format = wb->getOutputFormat();
+    }
+
+    if(isYuvBuffer(hnd) && //if 90 component or downscale, use rot
+            ((transform & HWC_TRANSFORM_ROT_90) || downscale)) {
+        *rot = ctx->mRotMgr->getNext();
+        if(*rot == NULL) return -1;
+        BwcPM::setBwc(ctx, crop, dst, transform, mdpFlags);
+        //Configure rotator for pre-rotation
+        if(configRotator(*rot, whf, crop, mdpFlags, orient, downscale) < 0) {
+            ALOGE("%s: configRotator failed!", __FUNCTION__);
+            ctx->mOverlay->clear(dpy);
+            return -1;
+        }
+        ctx->mLayerRotMap[dpy]->add(layer, *rot);
+        whf.format = (*rot)->getDstFormat();
+        updateSource(orient, whf, crop);
+        rotFlags |= ovutils::ROT_PREROTATED;
+    }
+
+    //For the mdp, since either we are pre-rotating or MDP does flips
+    orient = OVERLAY_TRANSFORM_0;
+    transform = 0;
+
+    PipeArgs parg(mdpFlags, whf, z, isFg,
+                  static_cast<eRotFlags>(rotFlags), layer->planeAlpha,
+                  (ovutils::eBlending) getBlending(layer->blending));
+
+    if(configMdp(ctx->mOverlay, parg, orient, crop, dst, metadata, dest) < 0) {
+        ALOGE("%s: commit failed for low res panel", __FUNCTION__);
+        ctx->mLayerRotMap[dpy]->reset();
+        return -1;
+    }
+    return 0;
+}
+
+int configureHighRes(hwc_context_t *ctx, hwc_layer_1_t *layer,
+        const int& dpy, eMdpFlags& mdpFlagsL, const eZorder& z,
+        const eIsFg& isFg, const eDest& lDest, const eDest& rDest,
+        Rotator **rot) {
+    private_handle_t *hnd = (private_handle_t *)layer->handle;
+    if(!hnd) {
+        ALOGE("%s: layer handle is NULL", __FUNCTION__);
+        return -1;
+    }
+
+    MetaData_t *metadata = (MetaData_t *)hnd->base_metadata;
+
+    int hw_w = ctx->dpyAttr[dpy].xres;
+    int hw_h = ctx->dpyAttr[dpy].yres;
+    hwc_rect_t crop = integerizeSourceCrop(layer->sourceCropf);
+    hwc_rect_t dst = layer->displayFrame;
+    int transform = layer->transform;
+    eTransform orient = static_cast<eTransform>(transform);
+    const int downscale = 0;
+    int rotFlags = ROT_FLAGS_NONE;
+
+    Whf whf(getWidth(hnd), getHeight(hnd),
+            getMdpFormat(hnd->format), hnd->size);
+
+    setMdpFlags(layer, mdpFlagsL, 0);
+    trimLayer(ctx, dpy, transform, crop, dst);
+
+    //Will do something only if feature enabled and conditions suitable
+    //hollow call otherwise
+    if(ctx->mAD->prepare(ctx, crop, whf, hnd)) {
+        overlay::Writeback *wb = overlay::Writeback::getInstance();
+        whf.format = wb->getOutputFormat();
+    }
+
+    if(isYuvBuffer(hnd) && (transform & HWC_TRANSFORM_ROT_90)) {
+        (*rot) = ctx->mRotMgr->getNext();
+        if((*rot) == NULL) return -1;
+        //Configure rotator for pre-rotation
+        if(configRotator(*rot, whf, crop, mdpFlagsL, orient, downscale) < 0) {
+            ALOGE("%s: configRotator failed!", __FUNCTION__);
+            ctx->mOverlay->clear(dpy);
+            return -1;
+        }
+        ctx->mLayerRotMap[dpy]->add(layer, *rot);
+        whf.format = (*rot)->getDstFormat();
+        updateSource(orient, whf, crop);
+        rotFlags |= ROT_PREROTATED;
+    }
+
+    eMdpFlags mdpFlagsR = mdpFlagsL;
+    setMdpFlags(mdpFlagsR, OV_MDSS_MDP_RIGHT_MIXER);
+
+    hwc_rect_t tmp_cropL, tmp_dstL;
+    hwc_rect_t tmp_cropR, tmp_dstR;
+
+    const int lSplit = getLeftSplit(ctx, dpy);
+
+    if(lDest != OV_INVALID) {
+        tmp_cropL = crop;
+        tmp_dstL = dst;
+        hwc_rect_t scissor = {0, 0, lSplit, hw_h };
+        qhwc::calculate_crop_rects(tmp_cropL, tmp_dstL, scissor, 0);
+    }
+    if(rDest != OV_INVALID) {
+        tmp_cropR = crop;
+        tmp_dstR = dst;
+        hwc_rect_t scissor = {lSplit, 0, hw_w, hw_h };
+        qhwc::calculate_crop_rects(tmp_cropR, tmp_dstR, scissor, 0);
+    }
+
+    //When buffer is H-flipped, contents of mixer config also needs to swapped
+    //Not needed if the layer is confined to one half of the screen.
+    //If rotator has been used then it has also done the flips, so ignore them.
+    if((orient & OVERLAY_TRANSFORM_FLIP_H) && lDest != OV_INVALID
+            && rDest != OV_INVALID && (*rot) == NULL) {
+        hwc_rect_t new_cropR;
+        new_cropR.left = tmp_cropL.left;
+        new_cropR.right = new_cropR.left + (tmp_cropR.right - tmp_cropR.left);
+
+        hwc_rect_t new_cropL;
+        new_cropL.left  = new_cropR.right;
+        new_cropL.right = tmp_cropR.right;
+
+        tmp_cropL.left =  new_cropL.left;
+        tmp_cropL.right =  new_cropL.right;
+
+        tmp_cropR.left = new_cropR.left;
+        tmp_cropR.right =  new_cropR.right;
+
+    }
+
+    //For the mdp, since either we are pre-rotating or MDP does flips
+    orient = OVERLAY_TRANSFORM_0;
+    transform = 0;
+
+    //configure left mixer
+    if(lDest != OV_INVALID) {
+        PipeArgs pargL(mdpFlagsL, whf, z, isFg,
+                       static_cast<eRotFlags>(rotFlags), layer->planeAlpha,
+                       (ovutils::eBlending) getBlending(layer->blending));
+
+        if(configMdp(ctx->mOverlay, pargL, orient,
+                tmp_cropL, tmp_dstL, metadata, lDest) < 0) {
+            ALOGE("%s: commit failed for left mixer config", __FUNCTION__);
+            return -1;
+        }
+    }
+
+    //configure right mixer
+    if(rDest != OV_INVALID) {
+        PipeArgs pargR(mdpFlagsR, whf, z, isFg,
+                static_cast<eRotFlags>(rotFlags), layer->planeAlpha,
+                (ovutils::eBlending) getBlending(layer->blending));
+
+        tmp_dstR.right = tmp_dstR.right - lSplit;
+        tmp_dstR.left = tmp_dstR.left - lSplit;
+        if(configMdp(ctx->mOverlay, pargR, orient,
+                tmp_cropR, tmp_dstR, metadata, rDest) < 0) {
+            ALOGE("%s: commit failed for right mixer config", __FUNCTION__);
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+bool canUseRotator(hwc_context_t *ctx, int dpy) {
+    if(qdutils::MDPVersion::getInstance().is8x26() &&
+            isSecondaryConnected(ctx)) {
+        return false;
+    }
+    if(ctx->mMDP.version == qdutils::MDP_V3_0_4)
+        return false;
+    return true;
+}
+
+int getLeftSplit(hwc_context_t *ctx, const int& dpy) {
+    //Default even split for all displays with high res
+    int lSplit = ctx->dpyAttr[dpy].xres / 2;
+    if(dpy == HWC_DISPLAY_PRIMARY &&
+            qdutils::MDPVersion::getInstance().getLeftSplit()) {
+        //Override if split published by driver for primary
+        lSplit = qdutils::MDPVersion::getInstance().getLeftSplit();
+    }
+    return lSplit;
+}
+
+void setupSecondaryObjs(hwc_context_t *ctx, const int& dpy) {
+    const int rSplit = 0;
+    ctx->mFBUpdate[dpy] =
+            IFBUpdate::getObject(ctx->dpyAttr[dpy].xres, rSplit, dpy);
+    ctx->mMDPComp[dpy] =  MDPComp::getObject(
+            ctx->dpyAttr[dpy].xres, rSplit, dpy);
+
+    int compositionType =
+            qdutils::QCCompositionType::getInstance().getCompositionType();
+    if (compositionType & (qdutils::COMPOSITION_TYPE_DYN |
+                           qdutils::COMPOSITION_TYPE_MDP |
+                           qdutils::COMPOSITION_TYPE_C2D)) {
+        ctx->mCopyBit[dpy] = new CopyBit();
+    }
+
+    if(ctx->mFBUpdate[dpy])
+        ctx->mFBUpdate[dpy]->reset();
+    if(ctx->mMDPComp[dpy])
+        ctx->mMDPComp[dpy]->reset();
+    if(ctx->mCopyBit[dpy])
+        ctx->mCopyBit[dpy]->reset();
+}
+
+void clearSecondaryObjs(hwc_context_t *ctx, const int& dpy) {
+    if(ctx->mFBUpdate[dpy]) {
+        delete ctx->mFBUpdate[dpy];
+        ctx->mFBUpdate[dpy] = NULL;
+    }
+    if(ctx->mCopyBit[dpy]){
+        delete ctx->mCopyBit[dpy];
+        ctx->mCopyBit[dpy] = NULL;
+    }
+    if(ctx->mMDPComp[dpy]) {
+        delete ctx->mMDPComp[dpy];
+        ctx->mMDPComp[dpy] = NULL;
+    }
+}
+
+bool isGLESOnlyComp(hwc_context_t *ctx, const int& dpy) {
+    if(ctx->mMDPComp[dpy]) {
+        return (ctx->mMDPComp[dpy]->getMDPCompCount() == 0);
+    }
+    return true;
+}
+
+void BwcPM::setBwc(hwc_context_t *ctx, const hwc_rect_t& crop,
+            const hwc_rect_t& dst, const int& transform,
+            ovutils::eMdpFlags& mdpFlags) {
+    //Target doesnt support Bwc
+    if(!qdutils::MDPVersion::getInstance().supportsBWC()) {
+        return;
+    }
+    int src_w = crop.right - crop.left;
+    int src_h = crop.bottom - crop.top;
+    int dst_w = dst.right - dst.left;
+    int dst_h = dst.bottom - dst.top;
+    if(transform & HAL_TRANSFORM_ROT_90) {
+        swap(src_w, src_h);
+    }
+    //src width > MAX mixer supported dim
+    if(src_w > qdutils::MAX_DISPLAY_DIM) {
+        return;
+    }
+    //Secondary display connected
+    if(isSecondaryConnected(ctx)) {
+        return;
+    }
+    //Decimation necessary, cannot use BWC. H/W requirement.
+    if(qdutils::MDPVersion::getInstance().supportsDecimation()) {
+        uint8_t horzDeci = 0;
+        uint8_t vertDeci = 0;
+        ovutils::getDecimationFactor(src_w, src_h, dst_w, dst_h, horzDeci,
+                vertDeci);
+        if(horzDeci || vertDeci) return;
+    }
+    //Property
+    char value[PROPERTY_VALUE_MAX];
+    property_get("debug.disable.bwc", value, "0");
+     if(atoi(value)) return;
+
+    ovutils::setMdpFlags(mdpFlags, ovutils::OV_MDSS_MDP_BWC_EN);
+}
+
+void LayerRotMap::add(hwc_layer_1_t* layer, Rotator *rot) {
+    if(mCount >= MAX_SESS) return;
+    mLayer[mCount] = layer;
+    mRot[mCount] = rot;
+    mCount++;
+}
+
+void LayerRotMap::reset() {
+    for (int i = 0; i < MAX_SESS; i++) {
+        mLayer[i] = 0;
+        mRot[i] = 0;
+    }
+    mCount = 0;
+}
+
+void LayerRotMap::setReleaseFd(const int& fence) {
+    for(uint32_t i = 0; i < mCount; i++) {
+        mRot[i]->setReleaseFd(dup(fence));
+    }
+}
+
+};//namespace qhwc
diff --git a/msm8974/libhwcomposer/hwc_utils.h b/msm8974/libhwcomposer/hwc_utils.h
new file mode 100644
index 0000000..03575a7
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_utils.h
@@ -0,0 +1,419 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C)2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HWC_UTILS_H
+#define HWC_UTILS_H
+
+#define HWC_REMOVE_DEPRECATED_VERSIONS 1
+#include <fcntl.h>
+#include <math.h>
+#include <hardware/hwcomposer.h>
+#include <gr.h>
+#include <gralloc_priv.h>
+#include <utils/String8.h>
+#include <linux/fb.h>
+#include "qdMetaData.h"
+#include <overlayUtils.h>
+
+#define ALIGN_TO(x, align)     (((x) + ((align)-1)) & ~((align)-1))
+#define LIKELY( exp )       (__builtin_expect( (exp) != 0, true  ))
+#define UNLIKELY( exp )     (__builtin_expect( (exp) != 0, false ))
+#define MAX_NUM_APP_LAYERS 32
+
+// For support of virtual displays
+#define MAX_DISPLAYS            (HWC_NUM_DISPLAY_TYPES)
+
+//Fwrd decls
+struct hwc_context_t;
+
+namespace ovutils = overlay::utils;
+
+namespace overlay {
+class Overlay;
+class Rotator;
+class RotMgr;
+}
+
+namespace qhwc {
+//fwrd decl
+class QueuedBufferStore;
+class ExternalDisplay;
+class IFBUpdate;
+class IVideoOverlay;
+class MDPComp;
+class CopyBit;
+class AssertiveDisplay;
+
+
+struct MDPInfo {
+    int version;
+    char panel;
+    bool hasOverlay;
+};
+
+struct DisplayAttributes {
+    uint32_t vsync_period; //nanos
+    uint32_t xres;
+    uint32_t yres;
+    uint32_t stride;
+    float xdpi;
+    float ydpi;
+    int fd;
+    bool connected; //Applies only to secondary displays
+    //Connected does not mean it ready to use.
+    //It should be active also. (UNBLANKED)
+    bool isActive;
+    // In pause state, composition is bypassed
+    // used for WFD displays only
+    bool isPause;
+    //Secondary displays will have this set until they are able to acquire
+    //pipes.
+    bool isConfiguring;
+};
+
+struct ListStats {
+    int numAppLayers; //Total - 1, excluding FB layer.
+    int skipCount;
+    int fbLayerIndex; //Always last for now. = numAppLayers
+    //Video specific
+    int yuvCount;
+    int yuvIndices[MAX_NUM_APP_LAYERS];
+    bool needsAlphaScale;
+    bool preMultipliedAlpha;
+    bool planeAlpha;
+    bool isSecurePresent;
+};
+
+struct LayerProp {
+    uint32_t mFlags; //qcom specific layer flags
+    LayerProp():mFlags(0) {};
+};
+
+struct VsyncState {
+    bool enable;
+    bool fakevsync;
+};
+
+struct BwcPM {
+    static void setBwc(hwc_context_t *ctx, const hwc_rect_t& crop,
+            const hwc_rect_t& dst, const int& transform,
+            ovutils::eMdpFlags& mdpFlags);
+};
+
+// LayerProp::flag values
+enum {
+    HWC_MDPCOMP = 0x00000001,
+    HWC_COPYBIT = 0x00000002,
+};
+
+class LayerRotMap {
+public:
+    LayerRotMap() { reset(); }
+    enum { MAX_SESS = 3 };
+    void add(hwc_layer_1_t* layer, overlay::Rotator *rot);
+    void reset();
+    uint32_t getCount() const;
+    hwc_layer_1_t* getLayer(uint32_t index) const;
+    overlay::Rotator* getRot(uint32_t index) const;
+    void setReleaseFd(const int& fence);
+private:
+    hwc_layer_1_t* mLayer[MAX_SESS];
+    overlay::Rotator* mRot[MAX_SESS];
+    uint32_t mCount;
+};
+
+inline uint32_t LayerRotMap::getCount() const {
+    return mCount;
+}
+
+inline hwc_layer_1_t* LayerRotMap::getLayer(uint32_t index) const {
+    if(index >= mCount) return NULL;
+    return mLayer[index];
+}
+
+inline overlay::Rotator* LayerRotMap::getRot(uint32_t index) const {
+    if(index >= mCount) return NULL;
+    return mRot[index];
+}
+
+inline hwc_rect_t integerizeSourceCrop(const hwc_frect_t& cropF) {
+    hwc_rect_t cropI = {0};
+    cropI.left = int(ceilf(cropF.left));
+    cropI.top = int(ceilf(cropF.top));
+    cropI.right = int(floorf(cropF.right));
+    cropI.bottom = int(floorf(cropF.bottom));
+    return cropI;
+}
+
+inline bool isNonIntegralSourceCrop(const hwc_frect_t& cropF) {
+    if(cropF.left - roundf(cropF.left)     ||
+       cropF.top - roundf(cropF.top)       ||
+       cropF.right - roundf(cropF.right)   ||
+       cropF.bottom - roundf(cropF.bottom))
+        return true;
+    else
+        return false;
+}
+
+// -----------------------------------------------------------------------------
+// Utility functions - implemented in hwc_utils.cpp
+void dumpLayer(hwc_layer_1_t const* l);
+void setListStats(hwc_context_t *ctx, const hwc_display_contents_1_t *list,
+        int dpy);
+void initContext(hwc_context_t *ctx);
+void closeContext(hwc_context_t *ctx);
+//Crops source buffer against destination and FB boundaries
+void calculate_crop_rects(hwc_rect_t& crop, hwc_rect_t& dst,
+                         const hwc_rect_t& scissor, int orient);
+void getNonWormholeRegion(hwc_display_contents_1_t* list,
+                              hwc_rect_t& nwr);
+bool isSecuring(hwc_context_t* ctx, hwc_layer_1_t const* layer);
+bool isSecureModePolicy(int mdpVersion);
+bool needsScaling(hwc_context_t* ctx, hwc_layer_1_t const* layer, const int& dpy);
+bool isAlphaPresent(hwc_layer_1_t const* layer);
+int hwc_vsync_control(hwc_context_t* ctx, int dpy, int enable);
+int getBlending(int blending);
+bool isGLESOnlyComp(hwc_context_t *ctx, const int& dpy);
+
+//Helper function to dump logs
+void dumpsys_log(android::String8& buf, const char* fmt, ...);
+
+/* Calculates the destination position based on the action safe rectangle */
+void getActionSafePosition(hwc_context_t *ctx, int dpy, uint32_t& x,
+                                        uint32_t& y, uint32_t& w, uint32_t& h);
+
+//Close acquireFenceFds of all layers of incoming list
+void closeAcquireFds(hwc_display_contents_1_t* list, int dpy);
+
+//Sync point impl.
+int hwc_sync(hwc_context_t *ctx, hwc_display_contents_1_t* list, int dpy,
+        int fd);
+
+//Trims a layer's source crop which is outside of screen boundary.
+void trimLayer(hwc_context_t *ctx, const int& dpy, const int& transform,
+        hwc_rect_t& crop, hwc_rect_t& dst);
+
+//Sets appropriate mdp flags for a layer.
+void setMdpFlags(hwc_layer_1_t *layer,
+        ovutils::eMdpFlags &mdpFlags,
+        int rotDownscale);
+
+int configRotator(overlay::Rotator *rot, const ovutils::Whf& whf,
+        hwc_rect_t& crop, const ovutils::eMdpFlags& mdpFlags,
+        const ovutils::eTransform& orient, const int& downscale);
+
+int configMdp(overlay::Overlay *ov, const ovutils::PipeArgs& parg,
+        const ovutils::eTransform& orient, const hwc_rect_t& crop,
+        const hwc_rect_t& pos, const MetaData_t *metadata,
+        const ovutils::eDest& dest);
+
+void updateSource(ovutils::eTransform& orient, ovutils::Whf& whf,
+        hwc_rect_t& crop);
+
+//Routine to configure low resolution panels (<= 2048 width)
+int configureLowRes(hwc_context_t *ctx, hwc_layer_1_t *layer, const int& dpy,
+        ovutils::eMdpFlags& mdpFlags, const ovutils::eZorder& z,
+        const ovutils::eIsFg& isFg, const ovutils::eDest& dest,
+        overlay::Rotator **rot);
+
+//Routine to configure high resolution panels (> 2048 width)
+int configureHighRes(hwc_context_t *ctx, hwc_layer_1_t *layer, const int& dpy,
+        ovutils::eMdpFlags& mdpFlags, const ovutils::eZorder& z,
+        const ovutils::eIsFg& isFg, const ovutils::eDest& lDest,
+        const ovutils::eDest& rDest, overlay::Rotator **rot);
+
+//On certain targets DMA pipes are used for rotation and they won't be available
+//for line operations. On a per-target basis we can restrict certain use cases
+//from using rotator, since we know before-hand that such scenarios can lead to
+//extreme unavailability of pipes. This can also be done via hybrid calculations
+//also involving many more variables like number of write-back interfaces etc,
+//but the variety of scenarios is too high to warrant that.
+bool canUseRotator(hwc_context_t *ctx, int dpy);
+
+int getLeftSplit(hwc_context_t *ctx, const int& dpy);
+
+//Sets up composition objects for secondary displays when they are added.
+//Should be called with extlock held.
+void setupSecondaryObjs(hwc_context_t *ctx, const int& dpy);
+void clearSecondaryObjs(hwc_context_t *ctx, const int& dpy);
+
+// Inline utility functions
+static inline bool isSkipLayer(const hwc_layer_1_t* l) {
+    return (UNLIKELY(l && (l->flags & HWC_SKIP_LAYER)));
+}
+
+// Returns true if the buffer is yuv
+static inline bool isYuvBuffer(const private_handle_t* hnd) {
+    return (hnd && (hnd->bufferType == BUFFER_TYPE_VIDEO));
+}
+
+// Returns true if the buffer is secure
+static inline bool isSecureBuffer(const private_handle_t* hnd) {
+    return (hnd && (private_handle_t::PRIV_FLAGS_SECURE_BUFFER & hnd->flags));
+}
+
+// Returns true if the buffer is marked for L3 DRM
+static inline bool isL3SecureBuffer(const private_handle_t* hnd) {
+    return (hnd &&
+            (private_handle_t::PRIV_FLAGS_L3_SECURE_BUFFER & hnd->flags));
+}
+//Return true if buffer is marked locked
+static inline bool isBufferLocked(const private_handle_t* hnd) {
+    return (hnd && (private_handle_t::PRIV_FLAGS_HWC_LOCK & hnd->flags));
+}
+
+//Return true if buffer is for external display only
+static inline bool isExtOnly(const private_handle_t* hnd) {
+    return (hnd && (hnd->flags & private_handle_t::PRIV_FLAGS_EXTERNAL_ONLY));
+}
+
+//Return true if buffer is for external display only with a BLOCK flag.
+static inline bool isExtBlock(const private_handle_t* hnd) {
+    return (hnd && (hnd->flags & private_handle_t::PRIV_FLAGS_EXTERNAL_BLOCK));
+}
+
+//Return true if buffer is for external display only with a Close Caption flag.
+static inline bool isExtCC(const private_handle_t* hnd) {
+    return (hnd && (hnd->flags & private_handle_t::PRIV_FLAGS_EXTERNAL_CC));
+}
+
+static inline int getWidth(const private_handle_t* hnd) {
+    if(isYuvBuffer(hnd)) {
+        MetaData_t *metadata = (MetaData_t *)hnd->base_metadata;
+        if(metadata && metadata->operation & UPDATE_BUFFER_GEOMETRY) {
+            return metadata->bufferDim.sliceWidth;
+        }
+    }
+    return hnd->width;
+}
+
+static inline int getHeight(const private_handle_t* hnd) {
+    if(isYuvBuffer(hnd)) {
+        MetaData_t *metadata = (MetaData_t *)hnd->base_metadata;
+        if(metadata && metadata->operation & UPDATE_BUFFER_GEOMETRY) {
+            return metadata->bufferDim.sliceHeight;
+        }
+    }
+    return hnd->height;
+}
+
+template<typename T> inline T max(T a, T b) { return (a > b) ? a : b; }
+template<typename T> inline T min(T a, T b) { return (a < b) ? a : b; }
+
+// Initialize uevent thread
+void init_uevent_thread(hwc_context_t* ctx);
+// Initialize vsync thread
+void init_vsync_thread(hwc_context_t* ctx);
+
+inline void getLayerResolution(const hwc_layer_1_t* layer,
+                               int& width, int& height) {
+    hwc_rect_t displayFrame  = layer->displayFrame;
+    width = displayFrame.right - displayFrame.left;
+    height = displayFrame.bottom - displayFrame.top;
+}
+
+static inline int openFb(int dpy) {
+    int fd = -1;
+    const char *devtmpl = "/dev/graphics/fb%u";
+    char name[64] = {0};
+    snprintf(name, 64, devtmpl, dpy);
+    fd = open(name, O_RDWR);
+    return fd;
+}
+
+template <class T>
+inline void swap(T& a, T& b) {
+    T tmp = a;
+    a = b;
+    b = tmp;
+}
+
+}; //qhwc namespace
+
+// -----------------------------------------------------------------------------
+// HWC context
+// This structure contains overall state
+struct hwc_context_t {
+    hwc_composer_device_1_t device;
+    const hwc_procs_t* proc;
+
+    //CopyBit objects
+    qhwc::CopyBit *mCopyBit[MAX_DISPLAYS];
+
+    //Overlay object - NULL for non overlay devices
+    overlay::Overlay *mOverlay;
+    //Holds a few rot objects
+    overlay::RotMgr *mRotMgr;
+
+    //Primary and external FB updater
+    qhwc::IFBUpdate *mFBUpdate[MAX_DISPLAYS];
+    // External display related information
+    qhwc::ExternalDisplay *mExtDisplay;
+    qhwc::MDPInfo mMDP;
+    qhwc::VsyncState vstate;
+    qhwc::DisplayAttributes dpyAttr[MAX_DISPLAYS];
+    qhwc::ListStats listStats[MAX_DISPLAYS];
+    qhwc::LayerProp *layerProp[MAX_DISPLAYS];
+    qhwc::LayerRotMap *mLayerRotMap[MAX_DISPLAYS];
+    qhwc::MDPComp *mMDPComp[MAX_DISPLAYS];
+    qhwc::AssertiveDisplay *mAD;
+
+    //Securing in progress indicator
+    bool mSecuring;
+    //Display in secure mode indicator
+    bool mSecureMode;
+    //Lock to protect drawing data structures
+    mutable Locker mDrawLock;
+    //Drawing round when we use GPU
+    bool isPaddingRound;
+    //Flags the transition of a video session
+    bool mVideoTransFlag;
+};
+
+namespace qhwc {
+static inline bool isSkipPresent (hwc_context_t *ctx, int dpy) {
+    return  ctx->listStats[dpy].skipCount;
+}
+
+static inline bool isYuvPresent (hwc_context_t *ctx, int dpy) {
+    return  ctx->listStats[dpy].yuvCount;
+}
+
+static inline bool has90Transform(hwc_layer_1_t *layer) {
+    return (layer->transform & HWC_TRANSFORM_ROT_90);
+}
+
+inline bool isSecurePresent(hwc_context_t *ctx, int dpy) {
+    return ctx->listStats[dpy].isSecurePresent;
+}
+
+static inline bool isSecondaryConfiguring(hwc_context_t* ctx) {
+    return (ctx->dpyAttr[HWC_DISPLAY_EXTERNAL].isConfiguring ||
+            ctx->dpyAttr[HWC_DISPLAY_VIRTUAL].isConfiguring);
+}
+
+static inline bool isSecondaryConnected(hwc_context_t* ctx) {
+    return (ctx->dpyAttr[HWC_DISPLAY_EXTERNAL].connected ||
+            ctx->dpyAttr[HWC_DISPLAY_VIRTUAL].connected);
+}
+
+};
+
+#endif //HWC_UTILS_H
diff --git a/msm8974/libhwcomposer/hwc_vsync.cpp b/msm8974/libhwcomposer/hwc_vsync.cpp
new file mode 100644
index 0000000..65d842c
--- /dev/null
+++ b/msm8974/libhwcomposer/hwc_vsync.cpp
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cutils/properties.h>
+#include <utils/Log.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/msm_mdp.h>
+#include <sys/resource.h>
+#include <sys/prctl.h>
+#include <poll.h>
+#include "hwc_utils.h"
+#include "string.h"
+#include "external.h"
+
+namespace qhwc {
+
+#define HWC_VSYNC_THREAD_NAME "hwcVsyncThread"
+#define MAX_SYSFS_FILE_PATH             255
+
+int hwc_vsync_control(hwc_context_t* ctx, int dpy, int enable)
+{
+    int ret = 0;
+    if(!ctx->vstate.fakevsync &&
+       ioctl(ctx->dpyAttr[dpy].fd, MSMFB_OVERLAY_VSYNC_CTRL,
+             &enable) < 0) {
+        ALOGE("%s: vsync control failed. Dpy=%d, enable=%d : %s",
+              __FUNCTION__, dpy, enable, strerror(errno));
+        ret = -errno;
+    }
+    return ret;
+}
+
+static void *vsync_loop(void *param)
+{
+    hwc_context_t * ctx = reinterpret_cast<hwc_context_t *>(param);
+
+    char thread_name[64] = HWC_VSYNC_THREAD_NAME;
+    prctl(PR_SET_NAME, (unsigned long) &thread_name, 0, 0, 0);
+    setpriority(PRIO_PROCESS, 0, HAL_PRIORITY_URGENT_DISPLAY +
+                android::PRIORITY_MORE_FAVORABLE);
+
+    const int MAX_DATA = 64;
+    char vdata[MAX_DATA];
+    bool logvsync = false;
+
+    struct pollfd pfd[2];
+    int fb_fd[2];
+    uint64_t timestamp[2];
+    int num_displays;
+
+    char property[PROPERTY_VALUE_MAX];
+    if(property_get("debug.hwc.fakevsync", property, NULL) > 0) {
+        if(atoi(property) == 1)
+            ctx->vstate.fakevsync = true;
+    }
+
+    if(property_get("debug.hwc.logvsync", property, 0) > 0) {
+        if(atoi(property) == 1)
+            logvsync = true;
+    }
+
+    if (ctx->mExtDisplay->getHDMIIndex() > 0)
+        num_displays = 2;
+    else
+        num_displays = 1;
+
+    char vsync_node_path[MAX_SYSFS_FILE_PATH];
+    for (int dpy = HWC_DISPLAY_PRIMARY; dpy < num_displays; dpy++) {
+        snprintf(vsync_node_path, sizeof(vsync_node_path),
+                "/sys/class/graphics/fb%d/vsync_event",
+                dpy == HWC_DISPLAY_PRIMARY ? 0 :
+                ctx->mExtDisplay->getHDMIIndex());
+        ALOGI("%s: Reading vsync for dpy=%d from %s", __FUNCTION__, dpy,
+                vsync_node_path);
+        fb_fd[dpy] = open(vsync_node_path, O_RDONLY);
+
+        if (fb_fd[dpy] < 0) {
+            // Make sure fb device is opened before starting this thread so this
+            // never happens.
+            ALOGE ("%s:not able to open vsync node for dpy=%d, %s",
+                    __FUNCTION__, dpy, strerror(errno));
+            if (dpy == HWC_DISPLAY_PRIMARY) {
+                ctx->vstate.fakevsync = true;
+                break;
+            }
+        }
+        // Read once from the fds to clear the first notify
+        pread(fb_fd[dpy], vdata , MAX_DATA, 0);
+
+        pfd[dpy].fd = fb_fd[dpy];
+        if (pfd[dpy].fd >= 0)
+            pfd[dpy].events = POLLPRI | POLLERR;
+    }
+
+    if (LIKELY(!ctx->vstate.fakevsync)) {
+        do {
+            int err = poll(pfd, num_displays, -1);
+            if(err > 0) {
+                for (int dpy = HWC_DISPLAY_PRIMARY; dpy < num_displays; dpy++) {
+                    if (pfd[dpy].revents & POLLPRI) {
+                        int len = pread(pfd[dpy].fd, vdata, MAX_DATA, 0);
+                        if (UNLIKELY(len < 0)) {
+                            // If the read was just interrupted - it is not a
+                            // fatal error. Just continue in this case
+                            ALOGE ("%s: Unable to read vsync for dpy=%d : %s",
+                                    __FUNCTION__, dpy, strerror(errno));
+                            continue;
+                        }
+                        // extract timestamp
+                        if (!strncmp(vdata, "VSYNC=", strlen("VSYNC="))) {
+                            timestamp[dpy] = strtoull(vdata + strlen("VSYNC="),
+                                    NULL, 0);
+                        }
+                        // send timestamp to SurfaceFlinger
+                        ALOGD_IF (logvsync,
+                                "%s: timestamp %llu sent to SF for dpy=%d",
+                                __FUNCTION__, timestamp[dpy], dpy);
+                        ctx->proc->vsync(ctx->proc, dpy, timestamp[dpy]);
+                    }
+                }
+
+            } else {
+                ALOGE("%s: vsync poll failed errno: %s", __FUNCTION__,
+                        strerror(errno));
+                continue;
+            }
+        } while (true);
+
+    } else {
+
+        //Fake vsync is used only when set explicitly through a property or when
+        //the vsync timestamp node cannot be opened at bootup. There is no
+        //fallback to fake vsync from the true vsync loop, ever, as the
+        //condition can easily escape detection.
+        //Also, fake vsync is delivered only for the primary display.
+        do {
+            usleep(16666);
+            timestamp[HWC_DISPLAY_PRIMARY] = systemTime();
+            ctx->proc->vsync(ctx->proc, HWC_DISPLAY_PRIMARY,
+                    timestamp[HWC_DISPLAY_PRIMARY]);
+
+        } while (true);
+    }
+
+    for (int dpy = HWC_DISPLAY_PRIMARY; dpy <= HWC_DISPLAY_EXTERNAL; dpy++ ) {
+        if(fb_fd[dpy] >= 0)
+            close (fb_fd[dpy]);
+    }
+
+    return NULL;
+}
+
+void init_vsync_thread(hwc_context_t* ctx)
+{
+    int ret;
+    pthread_t vsync_thread;
+    ALOGI("Initializing VSYNC Thread");
+    ret = pthread_create(&vsync_thread, NULL, vsync_loop, (void*) ctx);
+    if (ret) {
+        ALOGE("%s: failed to create %s: %s", __FUNCTION__,
+              HWC_VSYNC_THREAD_NAME, strerror(ret));
+    }
+}
+
+}; //namespace
diff --git a/msm8974/liblight/Android.mk b/msm8974/liblight/Android.mk
new file mode 100644
index 0000000..40115d5
--- /dev/null
+++ b/msm8974/liblight/Android.mk
@@ -0,0 +1,27 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH:= $(call my-dir)
+# HAL module implemenation stored in
+# hw/<COPYPIX_HARDWARE_MODULE_ID>.<ro.board.platform>.so
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := lights.c
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_SHARED_LIBRARIES := liblog
+LOCAL_CFLAGS := $(common_flags) -DLOG_TAG=\"qdlights\"
+LOCAL_MODULE := lights.$(TARGET_BOARD_PLATFORM)
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/msm8974/liblight/NOTICE b/msm8974/liblight/NOTICE
new file mode 100644
index 0000000..7340b9e
--- /dev/null
+++ b/msm8974/liblight/NOTICE
@@ -0,0 +1,190 @@
+
+   Copyright (c) 2008, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/msm8974/liblight/lights.c b/msm8974/liblight/lights.c
new file mode 100644
index 0000000..bbc4c17
--- /dev/null
+++ b/msm8974/liblight/lights.c
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+// #define LOG_NDEBUG 0
+
+#include <cutils/log.h>
+
+#include <malloc.h>
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+
+#include <sys/ioctl.h>
+#include <sys/types.h>
+
+#include <hardware/lights.h>
+
+/******************************************************************************/
+
+#define MAX_PATH_SIZE 80
+
+static pthread_once_t g_init = PTHREAD_ONCE_INIT;
+static pthread_mutex_t g_lock = PTHREAD_MUTEX_INITIALIZER;
+static struct light_state_t g_notification;
+static struct light_state_t g_battery;
+static int g_attention = 0;
+
+char const*const RED_LED_FILE
+        = "/sys/class/leds/red/brightness";
+
+char const*const GREEN_LED_FILE
+        = "/sys/class/leds/green/brightness";
+
+char const*const BLUE_LED_FILE
+        = "/sys/class/leds/blue/brightness";
+
+char const*const WHITE_LED_FILE
+        = "/sys/class/leds/white/brightness";
+
+char const*const LCD_FILE
+        = "/sys/class/leds/lcd-backlight/brightness";
+
+char const*const LED_FREQ_FILE
+        = "/sys/class/leds/%s/device/grpfreq";
+
+char const*const LED_PWM_FILE
+        = "/sys/class/leds/%s/device/grppwm";
+
+char const*const LED_BLINK_FILE
+        = "/sys/class/leds/%s/device/blink";
+
+char const*const LED_LOCK_UPDATE_FILE
+        = "/sys/class/leds/%s/device/lock";
+
+/**
+ * device methods
+ */
+
+void init_globals(void)
+{
+    // init the mutex
+    pthread_mutex_init(&g_lock, NULL);
+}
+
+static int
+write_int(char const* path, int value)
+{
+    int fd;
+    static int already_warned = 0;
+
+    fd = open(path, O_RDWR);
+    if (fd >= 0) {
+        char buffer[20];
+        int bytes = sprintf(buffer, "%d\n", value);
+        int amt = write(fd, buffer, bytes);
+        close(fd);
+        return amt == -1 ? -errno : 0;
+    } else {
+        if (already_warned == 0) {
+            ALOGE("write_int failed to open %s\n", path);
+            already_warned = 1;
+        }
+        return -errno;
+    }
+}
+
+static int
+is_avail(char const* path)
+{
+    int fd = open(path, O_RDWR);
+    if (fd >= 0) {
+        close(fd);
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+static int
+is_lit(struct light_state_t const* state)
+{
+    return state->color & 0x00ffffff;
+}
+
+static int
+rgb_to_brightness(struct light_state_t const* state)
+{
+    int color = state->color & 0x00ffffff;
+    return ((77*((color>>16)&0x00ff))
+            + (150*((color>>8)&0x00ff)) + (29*(color&0x00ff))) >> 8;
+}
+
+static int
+set_light_backlight(struct light_device_t* dev,
+        struct light_state_t const* state)
+{
+    int err = 0;
+    int brightness = rgb_to_brightness(state);
+    pthread_mutex_lock(&g_lock);
+    err = write_int(LCD_FILE, brightness);
+    pthread_mutex_unlock(&g_lock);
+    return err;
+}
+
+static int
+set_speaker_light_locked(struct light_device_t* dev,
+        struct light_state_t const* state)
+{
+    int rgb;
+    int blink, freq, pwm;
+    int onMS, offMS;
+    unsigned int colorRGB;
+
+    switch (state->flashMode) {
+        case LIGHT_FLASH_TIMED:
+            onMS = state->flashOnMS;
+            offMS = state->flashOffMS;
+            break;
+        case LIGHT_FLASH_NONE:
+        default:
+            onMS = 0;
+            offMS = 0;
+            break;
+    }
+
+    colorRGB = state->color;
+
+#if 0
+    ALOGD("set_speaker_light_locked mode %d, colorRGB=%08X, onMS=%d, offMS=%d\n",
+            state->flashMode, colorRGB, onMS, offMS);
+#endif
+
+    if (onMS > 0 && offMS > 0) {
+        int totalMS = onMS + offMS;
+
+        // the LED appears to blink about once per second if freq is 20
+        // 1000ms / 20 = 50
+        freq = totalMS / 50;
+        // pwm specifies the ratio of ON versus OFF
+        // pwm = 0 -> always off
+        // pwm = 255 => always on
+        pwm = (onMS * 255) / totalMS;
+
+        // the low 4 bits are ignored, so round up if necessary
+        if (pwm > 0 && pwm < 16)
+            pwm = 16;
+
+        blink = 1;
+    } else {
+        blink = 0;
+        freq = 0;
+        pwm = 0;
+    }
+
+    // Prefer RGB LEDs, fallback to white LED
+    rgb = is_avail(RED_LED_FILE) && is_avail(GREEN_LED_FILE) && is_avail(BLUE_LED_FILE);
+
+    char lock_update_file[MAX_PATH_SIZE];
+    char freq_file[MAX_PATH_SIZE];
+    char pwm_file[MAX_PATH_SIZE];
+    char blink_file[MAX_PATH_SIZE];
+    sprintf(lock_update_file, LED_LOCK_UPDATE_FILE, rgb ? "red" : "white");
+    sprintf(freq_file, LED_FREQ_FILE, rgb ? "red" : "white");
+    sprintf(pwm_file, LED_PWM_FILE, rgb ? "red" : "white");
+    sprintf(blink_file, LED_BLINK_FILE, rgb ? "red" : "white");
+
+    write_int(lock_update_file, 1); // for LED On/Off synchronization
+
+    if (rgb) {
+        write_int(RED_LED_FILE, (colorRGB >> 16) & 0xFF);
+        write_int(GREEN_LED_FILE, (colorRGB >> 8) & 0xFF);
+        write_int(BLUE_LED_FILE, colorRGB & 0xFF);
+    } else {
+        // See hardware/libhardware/include/hardware/lights.h
+        int brightness = ((77 * ((colorRGB >> 16) & 0xFF)) +
+                          (150 * ((colorRGB >> 8) & 0xFF)) +
+                          (29 * (colorRGB & 0xFF))) >> 8;
+        write_int(WHITE_LED_FILE, (int) brightness);
+    }
+
+    if (blink) {
+        write_int(freq_file, freq);
+        write_int(pwm_file, pwm);
+    }
+    write_int(blink_file, blink);
+
+    write_int(lock_update_file, 0);
+
+    return 0;
+}
+
+static void
+handle_speaker_battery_locked(struct light_device_t* dev)
+{
+    if (is_lit(&g_battery)) {
+        set_speaker_light_locked(dev, &g_battery);
+    } else {
+        set_speaker_light_locked(dev, &g_notification);
+    }
+}
+
+static int
+set_light_notifications(struct light_device_t* dev,
+        struct light_state_t const* state)
+{
+    pthread_mutex_lock(&g_lock);
+    g_notification = *state;
+    handle_speaker_battery_locked(dev);
+    pthread_mutex_unlock(&g_lock);
+    return 0;
+}
+
+static int
+set_light_attention(struct light_device_t* dev,
+        struct light_state_t const* state)
+{
+    pthread_mutex_lock(&g_lock);
+    if (state->flashMode == LIGHT_FLASH_HARDWARE) {
+        g_attention = state->flashOnMS;
+    } else if (state->flashMode == LIGHT_FLASH_NONE) {
+        g_attention = 0;
+    }
+    handle_speaker_battery_locked(dev);
+    pthread_mutex_unlock(&g_lock);
+    return 0;
+}
+
+
+/** Close the lights device */
+static int
+close_lights(struct light_device_t *dev)
+{
+    if (dev) {
+        free(dev);
+    }
+    return 0;
+}
+
+
+/******************************************************************************/
+
+/**
+ * module methods
+ */
+
+/** Open a new instance of a lights device using name */
+static int open_lights(const struct hw_module_t* module, char const* name,
+        struct hw_device_t** device)
+{
+    int (*set_light)(struct light_device_t* dev,
+            struct light_state_t const* state);
+
+    if (0 == strcmp(LIGHT_ID_BACKLIGHT, name))
+        set_light = set_light_backlight;
+    else if (0 == strcmp(LIGHT_ID_NOTIFICATIONS, name))
+        set_light = set_light_notifications;
+    else if (0 == strcmp(LIGHT_ID_ATTENTION, name))
+        set_light = set_light_attention;
+    else
+        return -EINVAL;
+
+    pthread_once(&g_init, init_globals);
+
+    struct light_device_t *dev = malloc(sizeof(struct light_device_t));
+    memset(dev, 0, sizeof(*dev));
+
+    dev->common.tag = HARDWARE_DEVICE_TAG;
+    dev->common.version = 0;
+    dev->common.module = (struct hw_module_t*)module;
+    dev->common.close = (int (*)(struct hw_device_t*))close_lights;
+    dev->set_light = set_light;
+
+    *device = (struct hw_device_t*)dev;
+    return 0;
+}
+
+static struct hw_module_methods_t lights_module_methods = {
+    .open =  open_lights,
+};
+
+/*
+ * The lights Module
+ */
+struct hw_module_t HAL_MODULE_INFO_SYM = {
+    .tag = HARDWARE_MODULE_TAG,
+    .version_major = 1,
+    .version_minor = 0,
+    .id = LIGHTS_HARDWARE_MODULE_ID,
+    .name = "lights Module",
+    .author = "Google, Inc.",
+    .methods = &lights_module_methods,
+};
diff --git a/msm8974/libmemtrack/Android.mk b/msm8974/libmemtrack/Android.mk
new file mode 100644
index 0000000..306eb07
--- /dev/null
+++ b/msm8974/libmemtrack/Android.mk
@@ -0,0 +1,26 @@
+# Copyright (C) 2013 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(call my-dir)
+
+# HAL module implemenation stored in
+# hw/<POWERS_HARDWARE_MODULE_ID>.<ro.hardware>.so
+include $(CLEAR_VARS)
+
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+LOCAL_C_INCLUDES += hardware/libhardware/include
+LOCAL_SHARED_LIBRARIES := liblog
+LOCAL_SRC_FILES := memtrack_msm.c kgsl.c
+LOCAL_MODULE := memtrack.$(TARGET_BOARD_PLATFORM)
+include $(BUILD_SHARED_LIBRARY)
diff --git a/msm8974/libmemtrack/kgsl.c b/msm8974/libmemtrack/kgsl.c
new file mode 100644
index 0000000..16ed85d
--- /dev/null
+++ b/msm8974/libmemtrack/kgsl.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/mman.h>
+
+#include <hardware/memtrack.h>
+
+#include "memtrack_msm.h"
+
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
+#define min(x, y) ((x) < (y) ? (x) : (y))
+
+struct memtrack_record record_templates[] = {
+    {
+        .flags = MEMTRACK_FLAG_SMAPS_ACCOUNTED |
+                 MEMTRACK_FLAG_PRIVATE |
+                 MEMTRACK_FLAG_NONSECURE,
+    },
+    {
+        .flags = MEMTRACK_FLAG_SMAPS_UNACCOUNTED |
+                 MEMTRACK_FLAG_PRIVATE |
+                 MEMTRACK_FLAG_NONSECURE,
+    },
+};
+
+int kgsl_memtrack_get_memory(pid_t pid, enum memtrack_type type,
+                             struct memtrack_record *records,
+                             size_t *num_records)
+{
+    size_t allocated_records = min(*num_records, ARRAY_SIZE(record_templates));
+    int i;
+    FILE *fp;
+    char line[1024];
+    char tmp[128];
+    bool is_surfaceflinger = false;
+    size_t accounted_size = 0;
+    size_t unaccounted_size = 0;
+
+    *num_records = ARRAY_SIZE(record_templates);
+
+    /* fastpath to return the necessary number of records */
+    if (allocated_records == 0) {
+        return 0;
+    }
+
+    snprintf(tmp, sizeof(tmp), "/proc/%d/cmdline", pid);
+    fp = fopen(tmp, "r");
+    if (fp != NULL) {
+        if (fgets(line, sizeof(line), fp)) {
+            if (strcmp(line, "/system/bin/surfaceflinger") == 0)
+                is_surfaceflinger = true;
+        }
+        fclose(fp);
+    }
+
+    memcpy(records, record_templates,
+           sizeof(struct memtrack_record) * allocated_records);
+
+    sprintf(tmp, "/d/kgsl/proc/%d/mem", pid);
+    fp = fopen(tmp, "r");
+    if (fp == NULL) {
+        return -errno;
+    }
+
+    /* Go through each line of <pid>/mem file and for every entry of type "gpumem"
+     * check if the gpubuffer entry is usermapped or not. If the entry is usermapped
+     * count the entry as accounted else count the entry as unaccounted.
+     */
+    while (1) {
+        unsigned long size;
+        char line_type[7];
+        char flags[7];
+        char line_usage[19];
+        int ret;
+
+        if (fgets(line, sizeof(line), fp) == NULL) {
+            break;
+        }
+
+        /* Format:
+         *  gpuaddr useraddr     size    id flags       type            usage sglen
+         * 545ba000 545ba000     4096     1 ----pY     gpumem      arraybuffer     1
+         */
+        ret = sscanf(line, "%*x %*lx %lu %*d %6s %6s %18s %*d\n",
+                     &size, flags, line_type, line_usage);
+        if (ret != 4) {
+            continue;
+        }
+
+        if (type == MEMTRACK_TYPE_GL && strcmp(line_type, "gpumem") == 0) {
+            if (flags[5] == 'Y')
+                accounted_size += size;
+            else
+                unaccounted_size += size;
+        } else if (type == MEMTRACK_TYPE_GRAPHICS && strcmp(line_type, "ion") == 0) {
+            if (!is_surfaceflinger || strcmp(line_usage, "egl_image") != 0) {
+                unaccounted_size += size;
+            }
+        }
+    }
+
+    if (allocated_records > 0) {
+        records[0].size_in_bytes = accounted_size;
+    }
+    if (allocated_records > 1) {
+        records[1].size_in_bytes = unaccounted_size;
+    }
+
+    fclose(fp);
+
+    return 0;
+}
diff --git a/msm8974/libmemtrack/memtrack_msm.c b/msm8974/libmemtrack/memtrack_msm.c
new file mode 100644
index 0000000..ac93f44
--- /dev/null
+++ b/msm8974/libmemtrack/memtrack_msm.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+
+#include <hardware/memtrack.h>
+
+#include "memtrack_msm.h"
+
+int msm_memtrack_init(const struct memtrack_module *module)
+{
+    return 0;
+}
+
+int msm_memtrack_get_memory(const struct memtrack_module *module,
+                                pid_t pid,
+                                int type,
+                                struct memtrack_record *records,
+                                size_t *num_records)
+{
+    if (type == MEMTRACK_TYPE_GL || type == MEMTRACK_TYPE_GRAPHICS) {
+        return kgsl_memtrack_get_memory(pid, type, records, num_records);
+    }
+
+    return -EINVAL;
+}
+
+static struct hw_module_methods_t memtrack_module_methods = {
+    .open = NULL,
+};
+
+struct memtrack_module HAL_MODULE_INFO_SYM = {
+    common: {
+        tag: HARDWARE_MODULE_TAG,
+        module_api_version: MEMTRACK_MODULE_API_VERSION_0_1,
+        hal_api_version: HARDWARE_HAL_API_VERSION,
+        id: MEMTRACK_HARDWARE_MODULE_ID,
+        name: "MSM Memory Tracker HAL",
+        author: "The Android Open Source Project",
+        methods: &memtrack_module_methods,
+    },
+
+    init: msm_memtrack_init,
+    getMemory: msm_memtrack_get_memory,
+};
+
diff --git a/msm8974/libmemtrack/memtrack_msm.h b/msm8974/libmemtrack/memtrack_msm.h
new file mode 100644
index 0000000..ff2db3c
--- /dev/null
+++ b/msm8974/libmemtrack/memtrack_msm.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _MEMTRACK_QCOM_H_
+#define _MEMTRACK_QCOM_H_
+
+int kgsl_memtrack_get_memory(pid_t pid, enum memtrack_type type,
+                             struct memtrack_record *records,
+                             size_t *num_records);
+
+#endif
diff --git a/msm8974/liboverlay/Android.mk b/msm8974/liboverlay/Android.mk
new file mode 100644
index 0000000..560b57f
--- /dev/null
+++ b/msm8974/liboverlay/Android.mk
@@ -0,0 +1,22 @@
+LOCAL_PATH := $(call my-dir)
+include $(LOCAL_PATH)/../common.mk
+include $(CLEAR_VARS)
+
+LOCAL_MODULE                  := liboverlay
+LOCAL_MODULE_PATH             := $(TARGET_OUT_SHARED_LIBRARIES)
+LOCAL_MODULE_TAGS             := optional
+LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)
+LOCAL_SHARED_LIBRARIES        := $(common_libs) libqdutils libmemalloc libsync
+LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"qdoverlay\"
+LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
+LOCAL_SRC_FILES := \
+      overlay.cpp \
+      overlayUtils.cpp \
+      overlayMdp.cpp \
+      overlayRotator.cpp \
+      overlayMdpRot.cpp \
+      overlayMdssRot.cpp \
+      overlayWriteback.cpp \
+      pipes/overlayGenPipe.cpp
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/msm8974/liboverlay/mdpWrapper.h b/msm8974/liboverlay/mdpWrapper.h
new file mode 100644
index 0000000..99b131b
--- /dev/null
+++ b/msm8974/liboverlay/mdpWrapper.h
@@ -0,0 +1,361 @@
+/*
+* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef MDP_WRAPPER_H
+#define MDP_WRAPPER_H
+#define ATRACE_TAG (ATRACE_TAG_GRAPHICS | ATRACE_TAG_HAL)
+
+/*
+* In order to make overlay::mdp_wrapper shorter, please do something like:
+* namespace mdpwrap = overlay::mdp_wrapper;
+* */
+
+#include <linux/msm_mdp.h>
+#include <linux/msm_rotator.h>
+#include <sys/ioctl.h>
+#include <utils/Log.h>
+#include <errno.h>
+#include "overlayUtils.h"
+#include <utils/Trace.h>
+
+namespace overlay{
+
+namespace mdp_wrapper{
+/* FBIOGET_FSCREENINFO */
+bool getFScreenInfo(int fd, fb_fix_screeninfo& finfo);
+
+/* FBIOGET_VSCREENINFO */
+bool getVScreenInfo(int fd, fb_var_screeninfo& vinfo);
+
+/* FBIOPUT_VSCREENINFO */
+bool setVScreenInfo(int fd, fb_var_screeninfo& vinfo);
+
+/* MSM_ROTATOR_IOCTL_START */
+bool startRotator(int fd, msm_rotator_img_info& rot);
+
+/* MSM_ROTATOR_IOCTL_ROTATE */
+bool rotate(int fd, msm_rotator_data_info& rot);
+
+/* MSMFB_OVERLAY_SET */
+bool setOverlay(int fd, mdp_overlay& ov);
+
+/* MSM_ROTATOR_IOCTL_FINISH */
+bool endRotator(int fd, int sessionId);
+
+/* MSMFB_OVERLAY_UNSET */
+bool unsetOverlay(int fd, int ovId);
+
+/* MSMFB_OVERLAY_GET */
+bool getOverlay(int fd, mdp_overlay& ov);
+
+/* MSMFB_OVERLAY_PLAY */
+bool play(int fd, msmfb_overlay_data& od);
+
+/* MSMFB_OVERLAY_3D */
+bool set3D(int fd, msmfb_overlay_3d& ov);
+
+/* MSMFB_DISPLAY_COMMIT */
+bool displayCommit(int fd);
+
+/* MSMFB_WRITEBACK_INIT, MSMFB_WRITEBACK_START */
+bool wbInitStart(int fbfd);
+
+/* MSMFB_WRITEBACK_STOP, MSMFB_WRITEBACK_TERMINATE */
+bool wbStopTerminate(int fbfd);
+
+/* MSMFB_WRITEBACK_QUEUE_BUFFER */
+bool wbQueueBuffer(int fbfd, struct msmfb_data& fbData);
+
+/* MSMFB_WRITEBACK_DEQUEUE_BUFFER */
+bool wbDequeueBuffer(int fbfd, struct msmfb_data& fbData);
+
+/* the following are helper functions for dumping
+ * msm_mdp and friends*/
+void dump(const char* const s, const msmfb_overlay_data& ov);
+void dump(const char* const s, const msmfb_data& ov);
+void dump(const char* const s, const mdp_overlay& ov);
+void dump(const char* const s, const msmfb_overlay_3d& ov);
+void dump(const char* const s, const uint32_t u[], uint32_t cnt);
+void dump(const char* const s, const msmfb_img& ov);
+void dump(const char* const s, const mdp_rect& ov);
+
+/* and rotator */
+void dump(const char* const s, const msm_rotator_img_info& rot);
+void dump(const char* const s, const msm_rotator_data_info& rot);
+
+/* info */
+void dump(const char* const s, const fb_fix_screeninfo& finfo);
+void dump(const char* const s, const fb_var_screeninfo& vinfo);
+
+//---------------Inlines -------------------------------------
+
+inline bool getFScreenInfo(int fd, fb_fix_screeninfo& finfo) {
+    ATRACE_CALL();
+    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) < 0) {
+        ALOGE("Failed to call ioctl FBIOGET_FSCREENINFO err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool getVScreenInfo(int fd, fb_var_screeninfo& vinfo) {
+    ATRACE_CALL();
+    if (ioctl(fd, FBIOGET_VSCREENINFO, &vinfo) < 0) {
+        ALOGE("Failed to call ioctl FBIOGET_VSCREENINFO err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool setVScreenInfo(int fd, fb_var_screeninfo& vinfo) {
+    ATRACE_CALL();
+    if (ioctl(fd, FBIOPUT_VSCREENINFO, &vinfo) < 0) {
+        ALOGE("Failed to call ioctl FBIOPUT_VSCREENINFO err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool startRotator(int fd, msm_rotator_img_info& rot) {
+    ATRACE_CALL();
+    if (ioctl(fd, MSM_ROTATOR_IOCTL_START, &rot) < 0){
+        ALOGE("Failed to call ioctl MSM_ROTATOR_IOCTL_START err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool rotate(int fd, msm_rotator_data_info& rot) {
+    ATRACE_CALL();
+    if (ioctl(fd, MSM_ROTATOR_IOCTL_ROTATE, &rot) < 0) {
+        ALOGE("Failed to call ioctl MSM_ROTATOR_IOCTL_ROTATE err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool setOverlay(int fd, mdp_overlay& ov) {
+    ATRACE_CALL();
+    if (ioctl(fd, MSMFB_OVERLAY_SET, &ov) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_OVERLAY_SET err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool endRotator(int fd, uint32_t sessionId) {
+    ATRACE_CALL();
+    if (ioctl(fd, MSM_ROTATOR_IOCTL_FINISH, &sessionId) < 0) {
+        ALOGE("Failed to call ioctl MSM_ROTATOR_IOCTL_FINISH err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool unsetOverlay(int fd, int ovId) {
+    ATRACE_CALL();
+    if (ioctl(fd, MSMFB_OVERLAY_UNSET, &ovId) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_OVERLAY_UNSET err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool getOverlay(int fd, mdp_overlay& ov) {
+    ATRACE_CALL();
+    if (ioctl(fd, MSMFB_OVERLAY_GET, &ov) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_OVERLAY_GET err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool play(int fd, msmfb_overlay_data& od) {
+    ATRACE_CALL();
+    if (ioctl(fd, MSMFB_OVERLAY_PLAY, &od) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_OVERLAY_PLAY err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool set3D(int fd, msmfb_overlay_3d& ov) {
+    ATRACE_CALL();
+    if (ioctl(fd, MSMFB_OVERLAY_3D, &ov) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_OVERLAY_3D err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool displayCommit(int fd, mdp_display_commit& info) {
+    ATRACE_CALL();
+    if(ioctl(fd, MSMFB_DISPLAY_COMMIT, &info) == -1) {
+        ALOGE("Failed to call ioctl MSMFB_DISPLAY_COMMIT err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool wbInitStart(int fbfd) {
+    ATRACE_CALL();
+    if(ioctl(fbfd, MSMFB_WRITEBACK_INIT, NULL) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_WRITEBACK_INIT err=%s",
+                strerror(errno));
+        return false;
+    }
+    if(ioctl(fbfd, MSMFB_WRITEBACK_START, NULL) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_WRITEBACK_START err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool wbStopTerminate(int fbfd) {
+    ATRACE_CALL();
+    if(ioctl(fbfd, MSMFB_WRITEBACK_STOP, NULL) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_WRITEBACK_STOP err=%s",
+                strerror(errno));
+        return false;
+    }
+    if(ioctl(fbfd, MSMFB_WRITEBACK_TERMINATE, NULL) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_WRITEBACK_TERMINATE err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool wbQueueBuffer(int fbfd, struct msmfb_data& fbData) {
+    ATRACE_CALL();
+    if(ioctl(fbfd, MSMFB_WRITEBACK_QUEUE_BUFFER, &fbData) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_WRITEBACK_QUEUE_BUFFER err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+inline bool wbDequeueBuffer(int fbfd, struct msmfb_data& fbData) {
+    ATRACE_CALL();
+    if(ioctl(fbfd, MSMFB_WRITEBACK_DEQUEUE_BUFFER, &fbData) < 0) {
+        ALOGE("Failed to call ioctl MSMFB_WRITEBACK_DEQUEUE_BUFFER err=%s",
+                strerror(errno));
+        return false;
+    }
+    return true;
+}
+
+/* dump funcs */
+inline void dump(const char* const s, const msmfb_overlay_data& ov) {
+    ALOGE("%s msmfb_overlay_data id=%d",
+            s, ov.id);
+    dump("data", ov.data);
+}
+inline void dump(const char* const s, const msmfb_data& ov) {
+    ALOGE("%s msmfb_data offset=%d memid=%d id=%d flags=0x%x priv=%d",
+            s, ov.offset, ov.memory_id, ov.id, ov.flags, ov.priv);
+}
+inline void dump(const char* const s, const mdp_overlay& ov) {
+    ALOGE("%s mdp_overlay z=%d fg=%d alpha=%d mask=%d flags=0x%x id=%d",
+            s, ov.z_order, ov.is_fg, ov.alpha,
+            ov.transp_mask, ov.flags, ov.id);
+    dump("src", ov.src);
+    dump("src_rect", ov.src_rect);
+    dump("dst_rect", ov.dst_rect);
+    /*
+    Commented off to prevent verbose logging, since user_data could have 8 or so
+    fields which are mostly 0
+    dump("user_data", ov.user_data,
+            sizeof(ov.user_data)/sizeof(ov.user_data[0]));
+    */
+}
+inline void dump(const char* const s, const msmfb_img& ov) {
+    ALOGE("%s msmfb_img w=%d h=%d format=%d %s",
+            s, ov.width, ov.height, ov.format,
+            overlay::utils::getFormatString(ov.format));
+}
+inline void dump(const char* const s, const mdp_rect& ov) {
+    ALOGE("%s mdp_rect x=%d y=%d w=%d h=%d",
+            s, ov.x, ov.y, ov.w, ov.h);
+}
+
+inline void dump(const char* const s, const msmfb_overlay_3d& ov) {
+    ALOGE("%s msmfb_overlay_3d 3d=%d w=%d h=%d",
+            s, ov.is_3d, ov.width, ov.height);
+
+}
+inline void dump(const char* const s, const uint32_t u[], uint32_t cnt) {
+    ALOGE("%s user_data cnt=%d", s, cnt);
+    for(uint32_t i=0; i < cnt; ++i) {
+        ALOGE("i=%d val=%d", i, u[i]);
+    }
+}
+inline void dump(const char* const s, const msm_rotator_img_info& rot) {
+    ALOGE("%s msm_rotator_img_info sessid=%u dstx=%d dsty=%d rot=%d, ena=%d scale=%d",
+            s, rot.session_id, rot.dst_x, rot.dst_y,
+            rot.rotations, rot.enable, rot.downscale_ratio);
+    dump("src", rot.src);
+    dump("dst", rot.dst);
+    dump("src_rect", rot.src_rect);
+}
+inline void dump(const char* const s, const msm_rotator_data_info& rot) {
+    ALOGE("%s msm_rotator_data_info sessid=%u verkey=%d",
+            s, rot.session_id, rot.version_key);
+    dump("src", rot.src);
+    dump("dst", rot.dst);
+    dump("src_chroma", rot.src_chroma);
+    dump("dst_chroma", rot.dst_chroma);
+}
+inline void dump(const char* const s, const fb_fix_screeninfo& finfo) {
+    ALOGE("%s fb_fix_screeninfo type=%d", s, finfo.type);
+}
+inline void dump(const char* const s, const fb_var_screeninfo& vinfo) {
+    ALOGE("%s fb_var_screeninfo xres=%d yres=%d",
+            s, vinfo.xres, vinfo.yres);
+}
+
+} // mdp_wrapper
+
+} // overlay
+
+#endif // MDP_WRAPPER_H
diff --git a/msm8974/liboverlay/overlay.cpp b/msm8974/liboverlay/overlay.cpp
new file mode 100644
index 0000000..5bb4965
--- /dev/null
+++ b/msm8974/liboverlay/overlay.cpp
@@ -0,0 +1,397 @@
+/*
+* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "overlay.h"
+#include "pipes/overlayGenPipe.h"
+#include "mdp_version.h"
+#include "qdMetaData.h"
+
+#define PIPE_DEBUG 0
+
+namespace overlay {
+using namespace utils;
+
+Overlay::Overlay() {
+    PipeBook::NUM_PIPES = qdutils::MDPVersion::getInstance().getTotalPipes();
+    for(int i = 0; i < PipeBook::NUM_PIPES; i++) {
+        mPipeBook[i].init();
+    }
+
+    mDumpStr[0] = '\0';
+}
+
+Overlay::~Overlay() {
+    for(int i = 0; i < PipeBook::NUM_PIPES; i++) {
+        mPipeBook[i].destroy();
+    }
+}
+
+void Overlay::configBegin() {
+    for(int i = 0; i < PipeBook::NUM_PIPES; i++) {
+        //Mark as available for this round.
+        PipeBook::resetUse(i);
+        PipeBook::resetAllocation(i);
+    }
+    sForceSetBitmap = 0;
+    mDumpStr[0] = '\0';
+}
+
+void Overlay::configDone() {
+    for(int i = 0; i < PipeBook::NUM_PIPES; i++) {
+        if(PipeBook::isNotUsed(i)) {
+            //Forces UNSET on pipes, flushes rotator memory and session, closes
+            //fds
+            if(mPipeBook[i].valid()) {
+                char str[32];
+                sprintf(str, "Unset=%s dpy=%d mix=%d; ",
+                        PipeBook::getDestStr((eDest)i),
+                        mPipeBook[i].mDisplay, mPipeBook[i].mMixer);
+#if PIPE_DEBUG
+                strncat(mDumpStr, str, strlen(str));
+#endif
+            }
+            mPipeBook[i].destroy();
+        }
+    }
+    dump();
+    PipeBook::save();
+}
+
+eDest Overlay::nextPipe(eMdpPipeType type, int dpy, int mixer) {
+    eDest dest = OV_INVALID;
+
+    for(int i = 0; i < PipeBook::NUM_PIPES; i++) {
+        if( (type == OV_MDP_PIPE_ANY || //Pipe type match
+             type == PipeBook::getPipeType((eDest)i)) &&
+            (mPipeBook[i].mDisplay == DPY_UNUSED || //Free or same display
+             mPipeBook[i].mDisplay == dpy) &&
+            (mPipeBook[i].mMixer == MIXER_UNUSED || //Free or same mixer
+             mPipeBook[i].mMixer == mixer) &&
+            PipeBook::isNotAllocated(i) && //Free pipe
+            !(sDMAMode == DMA_BLOCK_MODE && //DMA pipe in Line mode
+               PipeBook::getPipeType((eDest)i) == OV_MDP_PIPE_DMA)) {
+            dest = (eDest)i;
+            PipeBook::setAllocation(i);
+            break;
+        }
+    }
+
+    if(dest != OV_INVALID) {
+        int index = (int)dest;
+        mPipeBook[index].mDisplay = dpy;
+        mPipeBook[index].mMixer = mixer;
+        if(not mPipeBook[index].valid()) {
+            mPipeBook[index].mPipe = new GenericPipe(dpy);
+            char str[32];
+            snprintf(str, 32, "Set=%s dpy=%d mix=%d; ",
+                     PipeBook::getDestStr(dest), dpy, mixer);
+#if PIPE_DEBUG
+            strncat(mDumpStr, str, strlen(str));
+#endif
+        }
+    } else {
+        ALOGD_IF(PIPE_DEBUG, "Pipe unavailable type=%d display=%d mixer=%d",
+                (int)type, dpy, mixer);
+    }
+
+    return dest;
+}
+
+bool Overlay::isPipeTypeAttached(eMdpPipeType type) {
+    for(int i = 0; i < PipeBook::NUM_PIPES; i++) {
+        if(type == PipeBook::getPipeType((eDest)i) &&
+                mPipeBook[i].mDisplay != DPY_UNUSED) {
+            return true;
+        }
+    }
+    return false;
+}
+
+bool Overlay::commit(utils::eDest dest) {
+    bool ret = false;
+    int index = (int)dest;
+    validate(index);
+
+    if(mPipeBook[index].mPipe->commit()) {
+        ret = true;
+        PipeBook::setUse((int)dest);
+        if(sForceSetBitmap & (1 << mPipeBook[index].mDisplay)) {
+            mPipeBook[index].mPipe->forceSet();
+        }
+    } else {
+        int dpy = mPipeBook[index].mDisplay;
+        for(int i = 0; i < PipeBook::NUM_PIPES; i++)
+            if (mPipeBook[i].mDisplay == dpy) {
+                PipeBook::resetAllocation(i);
+                PipeBook::resetUse(i);
+                if(mPipeBook[i].valid()) {
+                    mPipeBook[i].mPipe->forceSet();
+                }
+            }
+    }
+    return ret;
+}
+
+bool Overlay::queueBuffer(int fd, uint32_t offset,
+        utils::eDest dest) {
+    int index = (int)dest;
+    bool ret = false;
+    validate(index);
+    //Queue only if commit() has succeeded (and the bit set)
+    if(PipeBook::isUsed((int)dest)) {
+        ret = mPipeBook[index].mPipe->queueBuffer(fd, offset);
+    }
+    return ret;
+}
+
+void Overlay::setCrop(const utils::Dim& d,
+        utils::eDest dest) {
+    int index = (int)dest;
+    validate(index);
+    mPipeBook[index].mPipe->setCrop(d);
+}
+
+void Overlay::setPosition(const utils::Dim& d,
+        utils::eDest dest) {
+    int index = (int)dest;
+    validate(index);
+    mPipeBook[index].mPipe->setPosition(d);
+}
+
+void Overlay::setTransform(const int orient,
+        utils::eDest dest) {
+    int index = (int)dest;
+    validate(index);
+
+    utils::eTransform transform =
+            static_cast<utils::eTransform>(orient);
+    mPipeBook[index].mPipe->setTransform(transform);
+
+}
+
+void Overlay::setSource(const utils::PipeArgs args,
+        utils::eDest dest) {
+    int index = (int)dest;
+    validate(index);
+
+    PipeArgs newArgs(args);
+    if(PipeBook::getPipeType(dest) == OV_MDP_PIPE_VG) {
+        setMdpFlags(newArgs.mdpFlags, OV_MDP_PIPE_SHARE);
+    } else {
+        clearMdpFlags(newArgs.mdpFlags, OV_MDP_PIPE_SHARE);
+    }
+
+    if(PipeBook::getPipeType(dest) == OV_MDP_PIPE_DMA) {
+        setMdpFlags(newArgs.mdpFlags, OV_MDP_PIPE_FORCE_DMA);
+    } else {
+        clearMdpFlags(newArgs.mdpFlags, OV_MDP_PIPE_FORCE_DMA);
+    }
+
+    mPipeBook[index].mPipe->setSource(newArgs);
+}
+
+void Overlay::setVisualParams(const MetaData_t& metadata, utils::eDest dest) {
+    int index = (int)dest;
+    validate(index);
+    mPipeBook[index].mPipe->setVisualParams(metadata);
+}
+
+Overlay* Overlay::getInstance() {
+    if(sInstance == NULL) {
+        sInstance = new Overlay();
+    }
+    return sInstance;
+}
+
+// Clears any VG pipes allocated to the fb devices
+// Generates a LUT for pipe types.
+int Overlay::initOverlay() {
+    int mdpVersion = qdutils::MDPVersion::getInstance().getMDPVersion();
+    int numPipesXType[OV_MDP_PIPE_ANY] = {0};
+    numPipesXType[OV_MDP_PIPE_RGB] =
+            qdutils::MDPVersion::getInstance().getRGBPipes();
+    numPipesXType[OV_MDP_PIPE_VG] =
+            qdutils::MDPVersion::getInstance().getVGPipes();
+    numPipesXType[OV_MDP_PIPE_DMA] =
+            qdutils::MDPVersion::getInstance().getDMAPipes();
+
+    int index = 0;
+    for(int X = 0; X < (int)OV_MDP_PIPE_ANY; X++) { //iterate over types
+        for(int j = 0; j < numPipesXType[X]; j++) { //iterate over num
+            PipeBook::pipeTypeLUT[index] = (utils::eMdpPipeType)X;
+            index++;
+        }
+    }
+
+    if (mdpVersion < qdutils::MDSS_V5 && mdpVersion != qdutils::MDP_V3_0_4) {
+        msmfb_mixer_info_req  req;
+        mdp_mixer_info *minfo = NULL;
+        char name[64];
+        int fd = -1;
+        for(int i = 0; i < MAX_FB_DEVICES; i++) {
+            snprintf(name, 64, FB_DEVICE_TEMPLATE, i);
+            ALOGD("initoverlay:: opening the device:: %s", name);
+            fd = ::open(name, O_RDWR, 0);
+            if(fd < 0) {
+                ALOGE("cannot open framebuffer(%d)", i);
+                return -1;
+            }
+            //Get the mixer configuration */
+            req.mixer_num = i;
+            if (ioctl(fd, MSMFB_MIXER_INFO, &req) == -1) {
+                ALOGE("ERROR: MSMFB_MIXER_INFO ioctl failed");
+                close(fd);
+                return -1;
+            }
+            minfo = req.info;
+            for (int j = 0; j < req.cnt; j++) {
+                ALOGD("ndx=%d num=%d z_order=%d", minfo->pndx, minfo->pnum,
+                      minfo->z_order);
+                // clear any pipe connected to mixer including base pipe.
+                int index = minfo->pndx;
+                ALOGD("Unset overlay with index: %d at mixer %d", index, i);
+                if(ioctl(fd, MSMFB_OVERLAY_UNSET, &index) == -1) {
+                    ALOGE("ERROR: MSMFB_OVERLAY_UNSET failed");
+                    close(fd);
+                    return -1;
+                }
+                minfo++;
+            }
+            close(fd);
+            fd = -1;
+        }
+    }
+
+    FILE *displayDeviceFP = NULL;
+    const int MAX_FRAME_BUFFER_NAME_SIZE = 128;
+    char fbType[MAX_FRAME_BUFFER_NAME_SIZE];
+    char msmFbTypePath[MAX_FRAME_BUFFER_NAME_SIZE];
+    const char *strDtvPanel = "dtv panel";
+    const char *strWbPanel = "writeback panel";
+
+    for(int num = 1; num < MAX_FB_DEVICES; num++) {
+        snprintf (msmFbTypePath, sizeof(msmFbTypePath),
+                "/sys/class/graphics/fb%d/msm_fb_type", num);
+        displayDeviceFP = fopen(msmFbTypePath, "r");
+
+        if(displayDeviceFP){
+            fread(fbType, sizeof(char), MAX_FRAME_BUFFER_NAME_SIZE,
+                    displayDeviceFP);
+
+            if(strncmp(fbType, strDtvPanel, strlen(strDtvPanel)) == 0) {
+                sDpyFbMap[DPY_EXTERNAL] = num;
+            } else if(strncmp(fbType, strWbPanel, strlen(strWbPanel)) == 0) {
+                sDpyFbMap[DPY_WRITEBACK] = num;
+            }
+
+            fclose(displayDeviceFP);
+        }
+    }
+
+    return 0;
+}
+
+bool Overlay::displayCommit(const int& fd) {
+    //Commit
+    struct mdp_display_commit info;
+    memset(&info, 0, sizeof(struct mdp_display_commit));
+    info.flags = MDP_DISPLAY_COMMIT_OVERLAY;
+    if(!mdp_wrapper::displayCommit(fd, info)) {
+       ALOGE("%s: commit failed", __func__);
+       return false;
+    }
+    return true;
+}
+
+void Overlay::dump() const {
+#if PIPE_DEBUG
+    if(strlen(mDumpStr)) { //dump only on state change
+        ALOGD("%s\n", mDumpStr);
+    }
+#endif
+}
+
+void Overlay::getDump(char *buf, size_t len) {
+    int totalPipes = 0;
+    const char *str = "\nOverlay State\n\n";
+    strncat(buf, str, strlen(str));
+    for(int i = 0; i < PipeBook::NUM_PIPES; i++) {
+        if(mPipeBook[i].valid()) {
+            mPipeBook[i].mPipe->getDump(buf, len);
+            char str[64] = {'\0'};
+            snprintf(str, 64, "Display=%d\n\n", mPipeBook[i].mDisplay);
+            strncat(buf, str, strlen(str));
+            totalPipes++;
+        }
+    }
+    char str_pipes[64] = {'\0'};
+    snprintf(str_pipes, 64, "Pipes=%d\n\n", totalPipes);
+    strncat(buf, str_pipes, strlen(str_pipes));
+}
+
+void Overlay::clear(int dpy) {
+    for(int i = 0; i < PipeBook::NUM_PIPES; i++) {
+        if (mPipeBook[i].mDisplay == dpy) {
+            // Mark as available for this round
+            PipeBook::resetUse(i);
+            PipeBook::resetAllocation(i);
+            if(mPipeBook[i].valid()) {
+                mPipeBook[i].mPipe->forceSet();
+            }
+        }
+    }
+}
+
+void Overlay::PipeBook::init() {
+    mPipe = NULL;
+    mDisplay = DPY_UNUSED;
+    mMixer = MIXER_UNUSED;
+}
+
+void Overlay::PipeBook::destroy() {
+    if(mPipe) {
+        delete mPipe;
+        mPipe = NULL;
+    }
+    mDisplay = DPY_UNUSED;
+    mMixer = MIXER_UNUSED;
+}
+
+Overlay* Overlay::sInstance = 0;
+int Overlay::sDpyFbMap[DPY_MAX] = {0, -1, -1};
+int Overlay::sDMAMode = DMA_LINE_MODE;
+int Overlay::sForceSetBitmap = 0;
+int Overlay::PipeBook::NUM_PIPES = 0;
+int Overlay::PipeBook::sPipeUsageBitmap = 0;
+int Overlay::PipeBook::sLastUsageBitmap = 0;
+int Overlay::PipeBook::sAllocatedBitmap = 0;
+utils::eMdpPipeType Overlay::PipeBook::pipeTypeLUT[utils::OV_MAX] =
+    {utils::OV_MDP_PIPE_ANY};
+
+}; // namespace overlay
diff --git a/msm8974/liboverlay/overlay.h b/msm8974/liboverlay/overlay.h
new file mode 100644
index 0000000..280223c
--- /dev/null
+++ b/msm8974/liboverlay/overlay.h
@@ -0,0 +1,279 @@
+/*
+* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation. nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef OVERLAY_H
+#define OVERLAY_H
+
+#include "overlayUtils.h"
+#include "utils/threads.h"
+
+struct MetaData_t;
+
+namespace overlay {
+class GenericPipe;
+
+class Overlay : utils::NoCopy {
+public:
+    enum { DMA_BLOCK_MODE, DMA_LINE_MODE };
+    //Abstract Display types. Each backed by a LayerMixer,
+    //represented by a fb node.
+    //High res panels can be backed by 2 layer mixers and a single fb node.
+    enum { DPY_PRIMARY, DPY_EXTERNAL, DPY_WRITEBACK, DPY_UNUSED };
+    enum { DPY_MAX = DPY_UNUSED };
+    enum { MIXER_LEFT, MIXER_RIGHT, MIXER_UNUSED };
+    enum { MIXER_DEFAULT = MIXER_LEFT, MIXER_MAX = MIXER_UNUSED };
+    enum { MAX_FB_DEVICES = DPY_MAX };
+
+    /* dtor close */
+    ~Overlay();
+
+    /* Marks the beginning of a drawing round, resets usage bits on pipes
+     * Should be called when drawing begins before any pipe config is done.
+     */
+    void configBegin();
+
+    /* Marks the end of config for this drawing round
+     * Will do garbage collection of pipe objects and thus calling UNSETs,
+     * closing FDs, removing rotator objects and memory, if allocated.
+     * Should be called after all pipe configs are done.
+     */
+    void configDone();
+
+    /* Returns an available pipe based on the type of pipe requested. When ANY
+     * is requested, the first available VG or RGB is returned. If no pipe is
+     * available for the display "dpy" then INV is returned. Note: If a pipe is
+     * assigned to a certain display, then it cannot be assigned to another
+     * display without being garbage-collected once. To add if a pipe is
+     * asisgned to a mixer within a display it cannot be reused for another
+     * mixer without being UNSET once*/
+    utils::eDest nextPipe(utils::eMdpPipeType, int dpy, int mixer);
+
+    void setSource(const utils::PipeArgs args, utils::eDest dest);
+    void setCrop(const utils::Dim& d, utils::eDest dest);
+    void setTransform(const int orientation, utils::eDest dest);
+    void setPosition(const utils::Dim& dim, utils::eDest dest);
+    void setVisualParams(const MetaData_t& data, utils::eDest dest);
+    bool commit(utils::eDest dest);
+    bool queueBuffer(int fd, uint32_t offset, utils::eDest dest);
+
+    /* Returns available ("unallocated") pipes for a display's mixer */
+    int availablePipes(int dpy, int mixer);
+    /* Returns if any of the requested pipe type is attached to any of the
+     * displays
+     */
+    bool isPipeTypeAttached(utils::eMdpPipeType type);
+    /* Returns pipe dump. Expects a NULL terminated buffer of big enough size
+     * to populate.
+     */
+    void getDump(char *buf, size_t len);
+    /* Reset usage and allocation bits on all pipes for given display */
+    void clear(int dpy);
+    /* Marks the display, whose pipes need to be forcibaly configured */
+    void forceSet(const int& dpy);
+
+    /* Closes open pipes, called during startup */
+    static int initOverlay();
+    /* Returns the singleton instance of overlay */
+    static Overlay* getInstance();
+    static void setDMAMode(const int& mode);
+    static int getDMAMode();
+    /* Returns the framebuffer node backing up the display */
+    static int getFbForDpy(const int& dpy);
+    static bool displayCommit(const int& fd);
+
+private:
+    /* Ctor setup */
+    explicit Overlay();
+    /*Validate index range, abort if invalid */
+    void validate(int index);
+    void dump() const;
+
+    /* Just like a Facebook for pipes, but much less profile info */
+    struct PipeBook {
+        void init();
+        void destroy();
+        /* Check if pipe exists and return true, false otherwise */
+        bool valid();
+
+        /* Hardware pipe wrapper */
+        GenericPipe *mPipe;
+        /* Display using this pipe. Refer to enums above */
+        int mDisplay;
+        /* Mixer within a split display this pipe is attached to */
+        int mMixer;
+
+        /* operations on bitmap */
+        static bool pipeUsageUnchanged();
+        static void setUse(int index);
+        static void resetUse(int index);
+        static bool isUsed(int index);
+        static bool isNotUsed(int index);
+        static void save();
+
+        static void setAllocation(int index);
+        static void resetAllocation(int index);
+        static bool isAllocated(int index);
+        static bool isNotAllocated(int index);
+
+        static utils::eMdpPipeType getPipeType(utils::eDest dest);
+        static const char* getDestStr(utils::eDest dest);
+
+        static int NUM_PIPES;
+        static utils::eMdpPipeType pipeTypeLUT[utils::OV_MAX];
+
+
+    private:
+        //usage tracks if a successful commit happened. So a pipe could be
+        //allocated to a display, but it may not end up using it for various
+        //reasons. If one display actually uses a pipe then it amy not be
+        //used by another display, without an UNSET in between.
+        static int sPipeUsageBitmap;
+        static int sLastUsageBitmap;
+        //Tracks which pipe objects are allocated. This does not imply that they
+        //will actually be used. For example, a display might choose to acquire
+        //3 pipe objects in one shot and proceed with config only if it gets all
+        //3. The bitmap helps allocate different pipe objects on each request.
+        static int sAllocatedBitmap;
+    };
+
+    PipeBook mPipeBook[utils::OV_INVALID]; //Used as max
+
+    /* Dump string */
+    char mDumpStr[1024];
+
+    /* Singleton Instance*/
+    static Overlay *sInstance;
+    static int sDpyFbMap[DPY_MAX];
+    static int sDMAMode;
+    static int sForceSetBitmap;
+};
+
+inline void Overlay::validate(int index) {
+    OVASSERT(index >=0 && index < PipeBook::NUM_PIPES, \
+        "%s, Index out of bounds: %d", __FUNCTION__, index);
+    OVASSERT(mPipeBook[index].valid(), "Pipe does not exist %s",
+            PipeBook::getDestStr((utils::eDest)index));
+}
+
+inline int Overlay::availablePipes(int dpy, int mixer) {
+    int avail = 0;
+    for(int i = 0; i < PipeBook::NUM_PIPES; i++) {
+        if( (mPipeBook[i].mDisplay == DPY_UNUSED ||
+             mPipeBook[i].mDisplay == dpy) &&
+            (mPipeBook[i].mMixer == MIXER_UNUSED ||
+             mPipeBook[i].mMixer == mixer) &&
+            PipeBook::isNotAllocated(i) &&
+            !(Overlay::getDMAMode() == Overlay::DMA_BLOCK_MODE &&
+              PipeBook::getPipeType((utils::eDest)i) ==
+              utils::OV_MDP_PIPE_DMA)) {
+            avail++;
+        }
+    }
+    return avail;
+}
+
+inline void Overlay::setDMAMode(const int& mode) {
+    if(mode == DMA_LINE_MODE || mode == DMA_BLOCK_MODE)
+        sDMAMode = mode;
+}
+
+inline int Overlay::getDMAMode() {
+    return sDMAMode;
+}
+
+inline int Overlay::getFbForDpy(const int& dpy) {
+    OVASSERT(dpy >= 0 && dpy < DPY_MAX, "Invalid dpy %d", dpy);
+    return sDpyFbMap[dpy];
+}
+
+inline void Overlay::forceSet(const int& dpy) {
+    sForceSetBitmap |= (1 << dpy);
+}
+
+inline bool Overlay::PipeBook::valid() {
+    return (mPipe != NULL);
+}
+
+inline bool Overlay::PipeBook::pipeUsageUnchanged() {
+    return (sPipeUsageBitmap == sLastUsageBitmap);
+}
+
+inline void Overlay::PipeBook::setUse(int index) {
+    sPipeUsageBitmap |= (1 << index);
+}
+
+inline void Overlay::PipeBook::resetUse(int index) {
+    sPipeUsageBitmap &= ~(1 << index);
+}
+
+inline bool Overlay::PipeBook::isUsed(int index) {
+    return sPipeUsageBitmap & (1 << index);
+}
+
+inline bool Overlay::PipeBook::isNotUsed(int index) {
+    return !isUsed(index);
+}
+
+inline void Overlay::PipeBook::save() {
+    sLastUsageBitmap = sPipeUsageBitmap;
+}
+
+inline void Overlay::PipeBook::setAllocation(int index) {
+    sAllocatedBitmap |= (1 << index);
+}
+
+inline void Overlay::PipeBook::resetAllocation(int index) {
+    sAllocatedBitmap &= ~(1 << index);
+}
+
+inline bool Overlay::PipeBook::isAllocated(int index) {
+    return sAllocatedBitmap & (1 << index);
+}
+
+inline bool Overlay::PipeBook::isNotAllocated(int index) {
+    return !isAllocated(index);
+}
+
+inline utils::eMdpPipeType Overlay::PipeBook::getPipeType(utils::eDest dest) {
+    return pipeTypeLUT[(int)dest];
+}
+
+inline const char* Overlay::PipeBook::getDestStr(utils::eDest dest) {
+    switch(getPipeType(dest)) {
+        case utils::OV_MDP_PIPE_RGB: return "RGB";
+        case utils::OV_MDP_PIPE_VG: return "VG";
+        case utils::OV_MDP_PIPE_DMA: return "DMA";
+        default: return "Invalid";
+    }
+    return "Invalid";
+}
+
+}; // overlay
+
+#endif // OVERLAY_H
diff --git a/msm8974/liboverlay/overlayCtrl.cpp b/msm8974/liboverlay/overlayCtrl.cpp
new file mode 100644
index 0000000..1f76c96
--- /dev/null
+++ b/msm8974/liboverlay/overlayCtrl.cpp
@@ -0,0 +1,90 @@
+/*
+* Copyright (C) 2008 The Android Open Source Project
+* Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include <cutils/properties.h>
+#include "overlayCtrlData.h"
+#include "gralloc_priv.h" //for interlace
+
+namespace overlay{
+
+bool Ctrl::init(uint32_t fbnum) {
+    // MDP/FD init
+    if(!mMdp.init(fbnum)) {
+        ALOGE("Ctrl failed to init fbnum=%d", fbnum);
+        return false;
+    }
+
+    if(!getScreenInfo(mInfo)) {
+        ALOGE("Ctrl failed to getScreenInfo");
+        return false;
+    }
+
+    return true;
+}
+
+bool Ctrl::setSource(const utils::PipeArgs& args)
+{
+    return mMdp.setSource(args);
+}
+
+bool Ctrl::setPosition(const utils::Dim& dim)
+{
+    if(!dim.check(mInfo.mFBWidth, mInfo.mFBHeight)) {
+        ALOGE("Ctrl setPosition error in dim");
+        dim.dump();
+        return false;
+    }
+
+    if(!mMdp.setPosition(dim, mInfo.mFBWidth, mInfo.mFBHeight)) {
+        ALOGE("Ctrl failed MDP setPosition");
+        return false;
+    }
+    return true;
+}
+
+bool Ctrl::setTransform(const utils::eTransform& orient)
+{
+    if(!mMdp.setTransform(orient)) {
+        ALOGE("Ctrl setTransform failed for Mdp");
+        return false;
+    }
+    return true;
+}
+
+void Ctrl::setRotatorUsed(const bool& rotUsed) {
+    mMdp.setRotatorUsed(rotUsed);
+}
+
+bool Ctrl::setCrop(const utils::Dim& d)
+{
+    if(!mMdp.setCrop(d)) {
+        ALOGE("Data setCrop failed in MDP setCrop");
+        return false;
+    }
+    return true;
+}
+
+utils::FrameBufferInfo* utils::FrameBufferInfo::sFBInfoInstance = 0;
+
+void Ctrl::dump() const {
+    ALOGE("== Dump Ctrl start ==");
+    mInfo.dump("mInfo");
+    mMdp.dump();
+    ALOGE("== Dump Ctrl end ==");
+}
+
+} // overlay
diff --git a/msm8974/liboverlay/overlayCtrlData.h b/msm8974/liboverlay/overlayCtrlData.h
new file mode 100644
index 0000000..c3a7aa3
--- /dev/null
+++ b/msm8974/liboverlay/overlayCtrlData.h
@@ -0,0 +1,274 @@
+/*
+* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef OVERLAY_CTRLDATA_H
+#define OVERLAY_CTRLDATA_H
+
+#include "overlayUtils.h"
+#include "overlayMdp.h"
+#include "gralloc_priv.h" // INTERLACE_MASK
+
+namespace ovutils = overlay::utils;
+
+namespace overlay {
+
+/*
+* Sequence to use:
+* init
+* start
+* setXXX
+* close
+* */
+class Ctrl : utils::NoCopy {
+public:
+
+    /* ctor */
+    explicit Ctrl();
+    /* dtor close */
+    ~Ctrl();
+    /* init fd etc*/
+    bool init(uint32_t fbnum);
+    /* close underlying mdp */
+    bool close();
+
+    /* set source using whf, orient and wait flag */
+    void setSource(const utils::PipeArgs& args);
+    /* set crop info and pass it down to mdp */
+    void setCrop(const utils::Dim& d);
+    /* set orientation */
+    void setTransform(const utils::eTransform& p);
+    /* set mdp position using dim */
+    void setPosition(const utils::Dim& dim);
+    /* set mdp visual params using metadata */
+    bool setVisualParams(const MetaData_t &metadata);
+    /* mdp set overlay/commit changes */
+    bool commit();
+
+    /* ctrl id */
+    int  getPipeId() const;
+    /* ctrl fd */
+    int  getFd() const;
+    /* retrieve crop data */
+    utils::Dim getCrop() const;
+    utils::Dim getPosition() const;
+    /* Set downscale */
+    void setDownscale(int dscale_factor);
+    /* Update the src format based on rotator's dest */
+    void updateSrcFormat(const uint32_t& rotDstFormat);
+    /* dump the state of the object */
+    void dump() const;
+    /* Return the dump in the specified buffer */
+    void getDump(char *buf, size_t len);
+    void forceSet();
+
+private:
+    // mdp ctrl struct(info e.g.)
+    MdpCtrl mMdp;
+};
+
+
+class Data : utils::NoCopy {
+public:
+    /* init, reset */
+    explicit Data();
+    /* calls close */
+    ~Data();
+    /* init fd etc */
+    bool init(uint32_t fbnum);
+    /* calls underlying mdp close */
+    bool close();
+    /* set overlay pipe id in the mdp struct */
+    void setPipeId(int id);
+    /* get overlay id in the mdp struct */
+    int getPipeId() const;
+    /* queue buffer to the overlay */
+    bool queueBuffer(int fd, uint32_t offset);
+    /* sump the state of the obj */
+    void dump() const;
+    /* Return the dump in the specified buffer */
+    void getDump(char *buf, size_t len);
+
+private:
+    // mdp data struct
+    MdpData mMdp;
+};
+
+/* This class just creates a Ctrl Data pair to be used by a pipe.
+ * Although this was legacy design, this separation still makes sense, since we
+ * need to use the Ctrl channel in hwc_prepare (i.e config stage) and Data
+ * channel in hwc_set (i.e draw stage)
+ */
+struct CtrlData {
+    Ctrl ctrl;
+    Data data;
+};
+
+//-------------Inlines-------------------------------
+
+inline Ctrl::Ctrl() {
+    mMdp.reset();
+}
+
+inline Ctrl::~Ctrl() {
+    close();
+}
+
+inline bool Ctrl::close() {
+    if(!mMdp.close())
+        return false;
+    return true;
+}
+
+inline bool Ctrl::init(uint32_t fbnum) {
+    // MDP/FD init
+    if(!mMdp.init(fbnum)) {
+        ALOGE("Ctrl failed to init fbnum=%d", fbnum);
+        return false;
+    }
+    return true;
+}
+
+inline void Ctrl::setSource(const utils::PipeArgs& args)
+{
+    mMdp.setSource(args);
+}
+
+inline void Ctrl::setPosition(const utils::Dim& dim)
+{
+    mMdp.setPosition(dim);
+}
+
+inline void Ctrl::setTransform(const utils::eTransform& orient)
+{
+    mMdp.setTransform(orient);
+}
+
+inline void Ctrl::setCrop(const utils::Dim& d)
+{
+    mMdp.setCrop(d);
+}
+
+inline bool Ctrl::setVisualParams(const MetaData_t &metadata)
+{
+    if (!mMdp.setVisualParams(metadata)) {
+        ALOGE("Ctrl setVisualParams failed in MDP setVisualParams");
+        return false;
+    }
+    return true;
+}
+
+inline void Ctrl::dump() const {
+    ALOGE("== Dump Ctrl start ==");
+    mMdp.dump();
+    ALOGE("== Dump Ctrl end ==");
+}
+
+inline bool Ctrl::commit() {
+    if(!mMdp.set()) {
+        ALOGE("Ctrl commit failed set overlay");
+        return false;
+    }
+    return true;
+}
+
+inline int Ctrl::getPipeId() const {
+    return mMdp.getPipeId();
+}
+
+inline int Ctrl::getFd() const {
+    return mMdp.getFd();
+}
+
+inline void Ctrl::updateSrcFormat(const uint32_t& rotDstFmt) {
+    mMdp.updateSrcFormat(rotDstFmt);
+}
+
+inline utils::Dim Ctrl::getCrop() const {
+    return mMdp.getSrcRectDim();
+}
+
+inline utils::Dim Ctrl::getPosition() const {
+    return mMdp.getDstRectDim();
+}
+
+inline void Ctrl::setDownscale(int dscale_factor) {
+    mMdp.setDownscale(dscale_factor);
+}
+
+inline void Ctrl::getDump(char *buf, size_t len) {
+    mMdp.getDump(buf, len);
+}
+
+inline void Ctrl::forceSet() {
+    mMdp.forceSet();
+}
+
+inline Data::Data() {
+    mMdp.reset();
+}
+
+inline Data::~Data() { close(); }
+
+inline void Data::setPipeId(int id) { mMdp.setPipeId(id); }
+
+inline int Data::getPipeId() const { return mMdp.getPipeId(); }
+
+inline bool Data::init(uint32_t fbnum) {
+    if(!mMdp.init(fbnum)) {
+        ALOGE("Data cannot init mdp");
+        return false;
+    }
+    return true;
+}
+
+inline bool Data::close() {
+    if(!mMdp.close()) {
+        ALOGE("Data close failed");
+        return false;
+    }
+    return true;
+}
+
+inline bool Data::queueBuffer(int fd, uint32_t offset) {
+    return mMdp.play(fd, offset);
+}
+
+inline void Data::dump() const {
+    ALOGE("== Dump Data MDP start ==");
+    mMdp.dump();
+    ALOGE("== Dump Data MDP end ==");
+}
+
+inline void Data::getDump(char *buf, size_t len) {
+    mMdp.getDump(buf, len);
+}
+
+} // overlay
+
+#endif
diff --git a/msm8974/liboverlay/overlayMdp.cpp b/msm8974/liboverlay/overlayMdp.cpp
new file mode 100644
index 0000000..761815b
--- /dev/null
+++ b/msm8974/liboverlay/overlayMdp.cpp
@@ -0,0 +1,344 @@
+/*
+* Copyright (C) 2008 The Android Open Source Project
+* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include <math.h>
+#include <mdp_version.h>
+#include "overlayUtils.h"
+#include "overlayMdp.h"
+#include "mdp_version.h"
+
+#define HSIC_SETTINGS_DEBUG 0
+
+using namespace qdutils;
+
+static inline bool isEqual(float f1, float f2) {
+        return ((int)(f1*100) == (int)(f2*100)) ? true : false;
+}
+
+namespace ovutils = overlay::utils;
+namespace overlay {
+
+bool MdpCtrl::init(uint32_t fbnum) {
+    // FD init
+    if(!utils::openDev(mFd, fbnum,
+                Res::fbPath, O_RDWR)){
+        ALOGE("Ctrl failed to init fbnum=%d", fbnum);
+        return false;
+    }
+    return true;
+}
+
+void MdpCtrl::reset() {
+    utils::memset0(mOVInfo);
+    utils::memset0(mLkgo);
+    mOVInfo.id = MSMFB_NEW_REQUEST;
+    mLkgo.id = MSMFB_NEW_REQUEST;
+    mOrientation = utils::OVERLAY_TRANSFORM_0;
+    mDownscale = 0;
+    mForceSet = false;
+#ifdef USES_POST_PROCESSING
+    mPPChanged = false;
+    memset(&mParams, 0, sizeof(struct compute_params));
+    mParams.params.conv_params.order = hsic_order_hsc_i;
+    mParams.params.conv_params.interface = interface_rec601;
+    mParams.params.conv_params.cc_matrix[0][0] = 1;
+    mParams.params.conv_params.cc_matrix[1][1] = 1;
+    mParams.params.conv_params.cc_matrix[2][2] = 1;
+#endif
+}
+
+bool MdpCtrl::close() {
+    bool result = true;
+    if(MSMFB_NEW_REQUEST != static_cast<int>(mOVInfo.id)) {
+        if(!mdp_wrapper::unsetOverlay(mFd.getFD(), mOVInfo.id)) {
+            ALOGE("MdpCtrl close error in unset");
+            result = false;
+        }
+    }
+#ifdef USES_POST_PROCESSING
+    /* free allocated memory in PP */
+    if (mOVInfo.overlay_pp_cfg.igc_cfg.c0_c1_data)
+            free(mOVInfo.overlay_pp_cfg.igc_cfg.c0_c1_data);
+#endif
+    reset();
+
+    if(!mFd.close()) {
+        result = false;
+    }
+
+    return result;
+}
+
+void MdpCtrl::setSource(const utils::PipeArgs& args) {
+    setSrcWhf(args.whf);
+
+    //TODO These are hardcoded. Can be moved out of setSource.
+    mOVInfo.transp_mask = 0xffffffff;
+
+    //TODO These calls should ideally be a part of setPipeParams API
+    setFlags(args.mdpFlags);
+    setZ(args.zorder);
+    setIsFg(args.isFg);
+    setPlaneAlpha(args.planeAlpha);
+    setBlending(args.blending);
+}
+
+void MdpCtrl::setCrop(const utils::Dim& d) {
+    setSrcRectDim(d);
+}
+
+void MdpCtrl::setPosition(const overlay::utils::Dim& d) {
+    setDstRectDim(d);
+}
+
+void MdpCtrl::setTransform(const utils::eTransform& orient) {
+    int rot = utils::getMdpOrient(orient);
+    setUserData(rot);
+    mOrientation = static_cast<utils::eTransform>(rot);
+}
+
+void MdpCtrl::doTransform() {
+    setRotationFlags();
+    utils::Whf whf = getSrcWhf();
+    utils::Dim dim = getSrcRectDim();
+    utils::preRotateSource(mOrientation, whf, dim);
+    setSrcWhf(whf);
+    setSrcRectDim(dim);
+}
+
+void MdpCtrl::doDownscale() {
+    int mdpVersion = MDPVersion::getInstance().getMDPVersion();
+    if(mdpVersion < MDSS_V5) {
+        mOVInfo.src_rect.x >>= mDownscale;
+        mOVInfo.src_rect.y >>= mDownscale;
+        mOVInfo.src_rect.w >>= mDownscale;
+        mOVInfo.src_rect.h >>= mDownscale;
+    } else if(MDPVersion::getInstance().supportsDecimation()) {
+        utils::getDecimationFactor(mOVInfo.src_rect.w, mOVInfo.src_rect.h,
+                mOVInfo.dst_rect.w, mOVInfo.dst_rect.h, mOVInfo.horz_deci,
+                mOVInfo.vert_deci);
+    }
+}
+
+bool MdpCtrl::set() {
+    int mdpVersion = MDPVersion::getInstance().getMDPVersion();
+    //deferred calcs, so APIs could be called in any order.
+    doTransform();
+    utils::Whf whf = getSrcWhf();
+    if(utils::isYuv(whf.format)) {
+        utils::normalizeCrop(mOVInfo.src_rect.x, mOVInfo.src_rect.w);
+        utils::normalizeCrop(mOVInfo.src_rect.y, mOVInfo.src_rect.h);
+        if(mdpVersion < MDSS_V5) {
+            utils::even_floor(mOVInfo.dst_rect.w);
+            utils::even_floor(mOVInfo.dst_rect.h);
+        } else if (mOVInfo.flags & MDP_DEINTERLACE) {
+            // For interlaced, crop.h should be 4-aligned
+            if (!(mOVInfo.flags & MDP_SOURCE_ROTATED_90) &&
+                (mOVInfo.src_rect.h % 4))
+                mOVInfo.src_rect.h = utils::aligndown(mOVInfo.src_rect.h, 4);
+        }
+    } else {
+        if (mdpVersion >= MDSS_V5) {
+            // Check for 1-pixel down-scaling
+            if (mOVInfo.src_rect.w - mOVInfo.dst_rect.w == 1)
+                mOVInfo.src_rect.w -= 1;
+            if (mOVInfo.src_rect.h - mOVInfo.dst_rect.h == 1)
+                mOVInfo.src_rect.h -= 1;
+        }
+    }
+
+    doDownscale();
+
+    if(this->ovChanged() || mForceSet) {
+        mForceSet = false;
+        if(!mdp_wrapper::setOverlay(mFd.getFD(), mOVInfo)) {
+            ALOGE("MdpCtrl failed to setOverlay, restoring last known "
+                  "good ov info");
+            mdp_wrapper::dump("== Bad OVInfo is: ", mOVInfo);
+            mdp_wrapper::dump("== Last good known OVInfo is: ", mLkgo);
+            this->restore();
+            return false;
+        }
+        this->save();
+    }
+
+    return true;
+}
+
+bool MdpCtrl::get() {
+    mdp_overlay ov;
+    ov.id = mOVInfo.id;
+    if (!mdp_wrapper::getOverlay(mFd.getFD(), ov)) {
+        ALOGE("MdpCtrl get failed");
+        return false;
+    }
+    mOVInfo = ov;
+    return true;
+}
+
+//Update src format based on rotator's destination format.
+void MdpCtrl::updateSrcFormat(const uint32_t& rotDestFmt) {
+    utils::Whf whf = getSrcWhf();
+    whf.format =  rotDestFmt;
+    setSrcWhf(whf);
+}
+
+void MdpCtrl::dump() const {
+    ALOGE("== Dump MdpCtrl start ==");
+    mFd.dump();
+    mdp_wrapper::dump("mOVInfo", mOVInfo);
+    ALOGE("== Dump MdpCtrl end ==");
+}
+
+void MdpCtrl::getDump(char *buf, size_t len) {
+    ovutils::getDump(buf, len, "Ctrl", mOVInfo);
+}
+
+void MdpData::dump() const {
+    ALOGE("== Dump MdpData start ==");
+    mFd.dump();
+    mdp_wrapper::dump("mOvData", mOvData);
+    ALOGE("== Dump MdpData end ==");
+}
+
+void MdpData::getDump(char *buf, size_t len) {
+    ovutils::getDump(buf, len, "Data", mOvData);
+}
+
+void MdpCtrl3D::dump() const {
+    ALOGE("== Dump MdpCtrl start ==");
+    mFd.dump();
+    ALOGE("== Dump MdpCtrl end ==");
+}
+
+bool MdpCtrl::setVisualParams(const MetaData_t& data) {
+#ifdef USES_POST_PROCESSING
+    bool needUpdate = false;
+    /* calculate the data */
+    if (data.operation & PP_PARAM_HSIC) {
+        if (mParams.params.pa_params.hue != data.hsicData.hue) {
+            ALOGD_IF(HSIC_SETTINGS_DEBUG,
+                "Hue has changed from %d to %d",
+                mParams.params.pa_params.hue,data.hsicData.hue);
+            needUpdate = true;
+        }
+
+        if (!isEqual(mParams.params.pa_params.sat,
+            data.hsicData.saturation)) {
+            ALOGD_IF(HSIC_SETTINGS_DEBUG,
+                "Saturation has changed from %f to %f",
+                mParams.params.pa_params.sat,
+                data.hsicData.saturation);
+            needUpdate = true;
+        }
+
+        if (mParams.params.pa_params.intensity != data.hsicData.intensity) {
+            ALOGD_IF(HSIC_SETTINGS_DEBUG,
+                "Intensity has changed from %d to %d",
+                mParams.params.pa_params.intensity,
+                data.hsicData.intensity);
+            needUpdate = true;
+        }
+
+        if (!isEqual(mParams.params.pa_params.contrast,
+            data.hsicData.contrast)) {
+            ALOGD_IF(HSIC_SETTINGS_DEBUG,
+                "Contrast has changed from %f to %f",
+                mParams.params.pa_params.contrast,
+                data.hsicData.contrast);
+            needUpdate = true;
+        }
+
+        if (needUpdate) {
+            mParams.params.pa_params.hue = data.hsicData.hue;
+            mParams.params.pa_params.sat = data.hsicData.saturation;
+            mParams.params.pa_params.intensity = data.hsicData.intensity;
+            mParams.params.pa_params.contrast = data.hsicData.contrast;
+            mParams.params.pa_params.ops = MDP_PP_OPS_WRITE | MDP_PP_OPS_ENABLE;
+            mParams.operation |= PP_OP_PA;
+        }
+    }
+
+    if (data.operation & PP_PARAM_SHARP2) {
+        if (mParams.params.sharp_params.strength != data.Sharp2Data.strength) {
+            needUpdate = true;
+        }
+        if (mParams.params.sharp_params.edge_thr != data.Sharp2Data.edge_thr) {
+            needUpdate = true;
+        }
+        if (mParams.params.sharp_params.smooth_thr !=
+                data.Sharp2Data.smooth_thr) {
+            needUpdate = true;
+        }
+        if (mParams.params.sharp_params.noise_thr !=
+                data.Sharp2Data.noise_thr) {
+            needUpdate = true;
+        }
+
+        if (needUpdate) {
+            mParams.params.sharp_params.strength = data.Sharp2Data.strength;
+            mParams.params.sharp_params.edge_thr = data.Sharp2Data.edge_thr;
+            mParams.params.sharp_params.smooth_thr =
+                data.Sharp2Data.smooth_thr;
+            mParams.params.sharp_params.noise_thr = data.Sharp2Data.noise_thr;
+            mParams.params.sharp_params.ops =
+                MDP_PP_OPS_WRITE | MDP_PP_OPS_ENABLE;
+            mParams.operation |= PP_OP_SHARP;
+        }
+    }
+
+    if (data.operation & PP_PARAM_IGC) {
+        if (mOVInfo.overlay_pp_cfg.igc_cfg.c0_c1_data == NULL){
+            uint32_t *igcData
+                = (uint32_t *)malloc(2 * MAX_IGC_LUT_ENTRIES * sizeof(uint32_t));
+            if (!igcData) {
+                ALOGE("IGC storage allocated failed");
+                return false;
+            }
+            mOVInfo.overlay_pp_cfg.igc_cfg.c0_c1_data = igcData;
+            mOVInfo.overlay_pp_cfg.igc_cfg.c2_data
+                = igcData + MAX_IGC_LUT_ENTRIES;
+        }
+
+        memcpy(mParams.params.igc_lut_params.c0,
+            data.igcData.c0, sizeof(uint16_t) * MAX_IGC_LUT_ENTRIES);
+        memcpy(mParams.params.igc_lut_params.c1,
+            data.igcData.c1, sizeof(uint16_t) * MAX_IGC_LUT_ENTRIES);
+        memcpy(mParams.params.igc_lut_params.c2,
+            data.igcData.c2, sizeof(uint16_t) * MAX_IGC_LUT_ENTRIES);
+
+        mParams.params.igc_lut_params.ops
+            = MDP_PP_OPS_WRITE | MDP_PP_OPS_ENABLE;
+        mParams.operation |= PP_OP_IGC;
+        needUpdate = true;
+    }
+
+    if (data.operation & PP_PARAM_VID_INTFC) {
+        mParams.params.conv_params.interface =
+            (interface_type) data.video_interface;
+        needUpdate = true;
+    }
+
+    if (needUpdate) {
+        display_pp_compute_params(&mParams, &mOVInfo.overlay_pp_cfg);
+        mPPChanged = true;
+    }
+#endif
+    return true;
+}
+
+} // overlay
diff --git a/msm8974/liboverlay/overlayMdp.h b/msm8974/liboverlay/overlayMdp.h
new file mode 100644
index 0000000..5bfec6b
--- /dev/null
+++ b/msm8974/liboverlay/overlayMdp.h
@@ -0,0 +1,438 @@
+/*
+* Copyright (C) 2008 The Android Open Source Project
+* Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef OVERLAY_MDP_H
+#define OVERLAY_MDP_H
+
+#include <linux/msm_mdp.h>
+
+#include "overlayUtils.h"
+#include "mdpWrapper.h"
+#include "qdMetaData.h"
+#ifdef USES_POST_PROCESSING
+#include "lib-postproc.h"
+#endif
+
+namespace overlay{
+
+/*
+* Mdp Ctrl holds corresponding fd and MDP related struct.
+* It is simple wrapper to MDP services
+* */
+class MdpCtrl {
+public:
+    /* ctor reset */
+    explicit MdpCtrl();
+    /* dtor close */
+    ~MdpCtrl();
+    /* init underlying device using fbnum */
+    bool init(uint32_t fbnum);
+    /* unset overlay, reset and close fd */
+    bool close();
+    /* reset and set ov id to -1 / MSMFB_NEW_REQUEST */
+    void reset();
+    /* calls overlay set
+     * Set would always consult last good known ov instance.
+     * Only if it is different, set would actually exectue ioctl.
+     * On a sucess ioctl. last good known ov instance is updated */
+    bool set();
+    /* Sets the source total width, height, format */
+    void setSource(const utils::PipeArgs& pargs);
+    /*
+     * Sets ROI, the unpadded region, for source buffer.
+     * Dim - ROI dimensions.
+     */
+    void setCrop(const utils::Dim& d);
+    void setTransform(const utils::eTransform& orient);
+    /* given a dim and w/h, set overlay dim */
+    void setPosition(const utils::Dim& dim);
+    /* using user_data, sets/unsets roationvalue in mdp flags */
+    void setRotationFlags();
+    /* Performs downscale calculations */
+    void setDownscale(int dscale_factor);
+    /* Update the src format with rotator's dest*/
+    void updateSrcFormat(const uint32_t& rotDstFormat);
+    /* dump state of the object */
+    void dump() const;
+    /* Return the dump in the specified buffer */
+    void getDump(char *buf, size_t len);
+
+    /* returns session id */
+    int getPipeId() const;
+    /* returns the fd associated to ctrl*/
+    int getFd() const;
+    /* returns a copy ro dst rect dim */
+    utils::Dim getDstRectDim() const;
+    /* returns a copy to src rect dim */
+    utils::Dim getSrcRectDim() const;
+    /* setVisualParam */
+    bool setVisualParams(const MetaData_t& data);
+    void forceSet();
+
+private:
+    /* Perform transformation calculations */
+    void doTransform();
+    void doDownscale();
+    /* get orient / user_data[0] */
+        int getOrient() const;
+    /* overlay get */
+    bool get();
+    /* returns flags from mdp structure */
+    int getFlags() const;
+    /* set flags to mdp structure */
+    void setFlags(int f);
+    /* set z order */
+    void setZ(utils::eZorder z);
+    /* set isFg flag */
+    void setIsFg(utils::eIsFg isFg);
+    /* return a copy of src whf*/
+    utils::Whf getSrcWhf() const;
+    /* set plane alpha */
+    void setPlaneAlpha(int planeAlpha);
+    /* set blending method */
+    void setBlending(overlay::utils::eBlending blending);
+
+    /* set src whf */
+    void setSrcWhf(const utils::Whf& whf);
+    /* set src/dst rect dim */
+    void setSrcRectDim(const utils::Dim d);
+    void setDstRectDim(const utils::Dim d);
+    /* returns user_data[0]*/
+    int getUserData() const;
+    /* sets user_data[0] */
+    void setUserData(int v);
+    /* return true if current overlay is different
+     * than last known good overlay */
+    bool ovChanged() const;
+    /* save mOVInfo to be last known good ov*/
+    void save();
+    /* restore last known good ov to be the current */
+    void restore();
+
+    utils::eTransform mOrientation; //Holds requested orientation
+    /* last good known ov info */
+    mdp_overlay   mLkgo;
+    /* Actual overlay mdp structure */
+    mdp_overlay   mOVInfo;
+    /* FD for the mdp fbnum */
+    OvFD          mFd;
+    int mDownscale;
+    bool mForceSet;
+
+#ifdef USES_POST_PROCESSING
+    /* PP Compute Params */
+    struct compute_params mParams;
+    /* indicate if PP params have been changed */
+    bool mPPChanged;
+#endif
+};
+
+
+/* MDP 3D related ctrl */
+class MdpCtrl3D {
+public:
+    /* ctor reset data */
+    MdpCtrl3D();
+    /* calls MSMFB_OVERLAY_3D */
+    bool close();
+    /* set w/h. format is ignored*/
+    void setWh(const utils::Whf& whf);
+    /* set is_3d calls MSMFB_OVERLAY_3D */
+    bool useVirtualFB();
+    /* set fd to be used in ioctl */
+    void setFd(int fd);
+    /* dump */
+    void dump() const;
+private:
+    /* reset */
+    void reset();
+    /* actual MSM 3D info */
+    msmfb_overlay_3d m3DOVInfo;
+    /* FD for the mdp 3D */
+    OvFD mFd;
+};
+
+/* MDP data */
+class MdpData {
+public:
+    /* ctor reset data */
+    explicit MdpData();
+    /* dtor close*/
+    ~MdpData();
+    /* init FD */
+    bool init(uint32_t fbnum);
+    /* memset0 the underlying mdp object */
+    void reset();
+    /* close fd, and reset */
+    bool close();
+    /* set id of mdp data */
+    void setPipeId(int id);
+    /* return ses id of data */
+    int getPipeId() const;
+    /* get underlying fd*/
+    int getFd() const;
+    /* get memory_id */
+    int getSrcMemoryId() const;
+    /* calls wrapper play */
+    bool play(int fd, uint32_t offset);
+    /* dump state of the object */
+    void dump() const;
+    /* Return the dump in the specified buffer */
+    void getDump(char *buf, size_t len);
+
+private:
+
+    /* actual overlay mdp data */
+    msmfb_overlay_data mOvData;
+    /* fd to mdp fbnum */
+    OvFD mFd;
+};
+
+//--------------Inlines---------------------------------
+
+/////   MdpCtrl  //////
+
+inline MdpCtrl::MdpCtrl() {
+    reset();
+}
+
+inline MdpCtrl::~MdpCtrl() {
+    close();
+}
+
+inline int MdpCtrl::getOrient() const {
+    return getUserData();
+}
+
+inline int MdpCtrl::getPipeId() const {
+    return mOVInfo.id;
+}
+
+inline int MdpCtrl::getFd() const {
+    return mFd.getFD();
+}
+
+inline int MdpCtrl::getFlags() const {
+    return mOVInfo.flags;
+}
+
+inline void MdpCtrl::setFlags(int f) {
+    mOVInfo.flags = f;
+}
+
+inline void MdpCtrl::setZ(overlay::utils::eZorder z) {
+    mOVInfo.z_order = z;
+}
+
+inline void MdpCtrl::setIsFg(overlay::utils::eIsFg isFg) {
+    mOVInfo.is_fg = isFg;
+}
+
+inline void MdpCtrl::setDownscale(int dscale) {
+    mDownscale = dscale;
+}
+
+inline void MdpCtrl::setPlaneAlpha(int planeAlpha) {
+    mOVInfo.alpha = planeAlpha;
+}
+
+inline void MdpCtrl::setBlending(overlay::utils::eBlending blending) {
+    switch((int) blending) {
+    case utils::OVERLAY_BLENDING_OPAQUE:
+        mOVInfo.blend_op = BLEND_OP_OPAQUE;
+        break;
+    case utils::OVERLAY_BLENDING_PREMULT:
+        mOVInfo.blend_op = BLEND_OP_PREMULTIPLIED;
+        break;
+    case utils::OVERLAY_BLENDING_COVERAGE:
+    default:
+        mOVInfo.blend_op = BLEND_OP_COVERAGE;
+    }
+}
+
+inline bool MdpCtrl::ovChanged() const {
+#ifdef USES_POST_PROCESSING
+    // Some pp params are stored as pointer address,
+    // so can't compare their content directly.
+    if (mPPChanged) {
+        return true;
+    }
+#endif
+    // 0 means same
+    if(0 == ::memcmp(&mOVInfo, &mLkgo, sizeof (mdp_overlay))) {
+        return false;
+    }
+    return true;
+}
+
+inline void MdpCtrl::save() {
+    if(static_cast<ssize_t>(mOVInfo.id) == MSMFB_NEW_REQUEST) {
+        ALOGE("MdpCtrl current ov has id -1, will not save");
+        return;
+    }
+    mLkgo = mOVInfo;
+}
+
+inline void MdpCtrl::restore() {
+    if(static_cast<ssize_t>(mLkgo.id) == MSMFB_NEW_REQUEST) {
+        ALOGE("MdpCtrl Lkgo ov has id -1, will not restore");
+        return;
+    }
+    mOVInfo = mLkgo;
+}
+
+inline overlay::utils::Whf MdpCtrl::getSrcWhf() const {
+    return utils::Whf(  mOVInfo.src.width,
+                        mOVInfo.src.height,
+                        mOVInfo.src.format);
+}
+
+inline void MdpCtrl::setSrcWhf(const overlay::utils::Whf& whf) {
+    mOVInfo.src.width  = whf.w;
+    mOVInfo.src.height = whf.h;
+    mOVInfo.src.format = whf.format;
+}
+
+inline overlay::utils::Dim MdpCtrl::getSrcRectDim() const {
+    return utils::Dim(  mOVInfo.src_rect.x,
+                        mOVInfo.src_rect.y,
+                        mOVInfo.src_rect.w,
+                        mOVInfo.src_rect.h);
+}
+
+inline void MdpCtrl::setSrcRectDim(const overlay::utils::Dim d) {
+    mOVInfo.src_rect.x = d.x;
+    mOVInfo.src_rect.y = d.y;
+    mOVInfo.src_rect.w = d.w;
+    mOVInfo.src_rect.h = d.h;
+}
+
+inline overlay::utils::Dim MdpCtrl::getDstRectDim() const {
+    return utils::Dim(  mOVInfo.dst_rect.x,
+                        mOVInfo.dst_rect.y,
+                        mOVInfo.dst_rect.w,
+                        mOVInfo.dst_rect.h);
+}
+
+inline void MdpCtrl::setDstRectDim(const overlay::utils::Dim d) {
+    mOVInfo.dst_rect.x = d.x;
+    mOVInfo.dst_rect.y = d.y;
+    mOVInfo.dst_rect.w = d.w;
+    mOVInfo.dst_rect.h = d.h;
+}
+
+inline int MdpCtrl::getUserData() const { return mOVInfo.user_data[0]; }
+
+inline void MdpCtrl::setUserData(int v) { mOVInfo.user_data[0] = v; }
+
+inline void MdpCtrl::setRotationFlags() {
+    const int u = getUserData();
+    if (u & MDP_ROT_90)
+        mOVInfo.flags |= MDP_SOURCE_ROTATED_90;
+}
+
+inline void MdpCtrl::forceSet() {
+    mForceSet = true;
+}
+
+///////    MdpCtrl3D //////
+
+inline MdpCtrl3D::MdpCtrl3D() { reset(); }
+inline bool MdpCtrl3D::close() {
+    if (m3DOVInfo.is_3d) {
+        m3DOVInfo.is_3d = 0;
+        if(!mdp_wrapper::set3D(mFd.getFD(), m3DOVInfo)) {
+            ALOGE("MdpCtrl3D close failed set3D with 0");
+            return false;
+        }
+    }
+    reset();
+    return true;
+}
+inline void MdpCtrl3D::reset() {
+    utils::memset0(m3DOVInfo);
+}
+
+inline void MdpCtrl3D::setFd(int fd) {
+    mFd.copy(fd);
+    OVASSERT(mFd.valid(), "MdpCtrl3D setFd, FD should be valid");
+}
+
+inline void MdpCtrl3D::setWh(const utils::Whf& whf) {
+    // ignore fmt. Needed for useVirtualFB callflow
+    m3DOVInfo.width = whf.w;
+    m3DOVInfo.height = whf.h;
+}
+
+inline bool MdpCtrl3D::useVirtualFB() {
+    if(!m3DOVInfo.is_3d) {
+        m3DOVInfo.is_3d = 1;
+        if(!mdp_wrapper::set3D(mFd.getFD(), m3DOVInfo)) {
+            ALOGE("MdpCtrl3D close failed set3D with 0");
+            return false;
+        }
+    }
+    return true;
+}
+
+///////    MdpData   //////
+
+inline MdpData::MdpData() { reset(); }
+
+inline MdpData::~MdpData() { close(); }
+
+inline bool MdpData::init(uint32_t fbnum) {
+    // FD init
+    if(!utils::openDev(mFd, fbnum, Res::fbPath, O_RDWR)){
+        ALOGE("Ctrl failed to init fbnum=%d", fbnum);
+        return false;
+    }
+    return true;
+}
+
+inline void MdpData::reset() {
+    overlay::utils::memset0(mOvData);
+    mOvData.data.memory_id = -1;
+}
+
+inline bool MdpData::close() {
+    reset();
+    return mFd.close();
+}
+
+inline int MdpData::getSrcMemoryId() const { return mOvData.data.memory_id; }
+
+inline void MdpData::setPipeId(int id) { mOvData.id = id; }
+
+inline int MdpData::getPipeId() const { return mOvData.id; }
+
+inline int MdpData::getFd() const { return mFd.getFD(); }
+
+inline bool MdpData::play(int fd, uint32_t offset) {
+    mOvData.data.memory_id = fd;
+    mOvData.data.offset = offset;
+    if(!mdp_wrapper::play(mFd.getFD(), mOvData)){
+        ALOGE("MdpData failed to play");
+        dump();
+        return false;
+    }
+    return true;
+}
+
+} // overlay
+
+#endif // OVERLAY_MDP_H
diff --git a/msm8974/liboverlay/overlayMdpRot.cpp b/msm8974/liboverlay/overlayMdpRot.cpp
new file mode 100755
index 0000000..ce2ef5b
--- /dev/null
+++ b/msm8974/liboverlay/overlayMdpRot.cpp
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+*/
+
+#include "overlayUtils.h"
+#include "overlayRotator.h"
+
+namespace ovutils = overlay::utils;
+
+namespace overlay {
+
+MdpRot::MdpRot() {
+    reset();
+    init();
+}
+
+MdpRot::~MdpRot() { close(); }
+
+bool MdpRot::enabled() const { return mRotImgInfo.enable; }
+
+void MdpRot::setRotations(uint32_t r) { mRotImgInfo.rotations = r; }
+
+int MdpRot::getDstMemId() const {
+    return mRotDataInfo.dst.memory_id;
+}
+
+uint32_t MdpRot::getDstOffset() const {
+    return mRotDataInfo.dst.offset;
+}
+
+uint32_t MdpRot::getDstFormat() const {
+    return mRotImgInfo.dst.format;
+}
+
+uint32_t MdpRot::getSessId() const { return mRotImgInfo.session_id; }
+
+void MdpRot::setDownscale(int ds) {
+    if ((utils::ROT_DS_EIGHTH == ds) && (mRotImgInfo.src_rect.h & 0xF)) {
+        // Ensure src_rect.h is a multiple of 16 for 1/8 downscaling.
+        // This is an undocumented MDP Rotator constraint.
+        mRotImgInfo.src_rect.h = utils::aligndown(mRotImgInfo.src_rect.h, 16);
+    }
+    mRotImgInfo.downscale_ratio = ds;
+}
+
+void MdpRot::save() {
+    mLSRotImgInfo = mRotImgInfo;
+}
+
+bool MdpRot::rotConfChanged() const {
+    // 0 means same
+    if(0 == ::memcmp(&mRotImgInfo, &mLSRotImgInfo,
+                sizeof (msm_rotator_img_info))) {
+        return false;
+    }
+    return true;
+}
+
+bool MdpRot::init()
+{
+    if(!mFd.open(Res::rotPath, O_RDWR)){
+        ALOGE("MdpRot failed to init %s", Res::rotPath);
+        return false;
+    }
+    return true;
+}
+
+void MdpRot::setSource(const overlay::utils::Whf& awhf) {
+    utils::Whf whf(awhf);
+    mRotImgInfo.src.format = whf.format;
+
+    mRotImgInfo.src.width = whf.w;
+    mRotImgInfo.src.height = whf.h;
+
+    mRotImgInfo.src_rect.w = whf.w;
+    mRotImgInfo.src_rect.h = whf.h;
+
+    mRotImgInfo.dst.width = whf.w;
+    mRotImgInfo.dst.height = whf.h;
+}
+
+void MdpRot::setCrop(const utils::Dim& crop) {
+    // NO-OP for non-mdss rotator due to possible h/w limitations
+}
+
+void MdpRot::setFlags(const utils::eMdpFlags& flags) {
+    mRotImgInfo.secure = 0;
+    if(flags & utils::OV_MDP_SECURE_OVERLAY_SESSION)
+        mRotImgInfo.secure = 1;
+}
+
+void MdpRot::setTransform(const utils::eTransform& rot)
+{
+    int r = utils::getMdpOrient(rot);
+    setRotations(r);
+    mOrientation = static_cast<utils::eTransform>(r);
+    ALOGE_IF(DEBUG_OVERLAY, "%s: r=%d", __FUNCTION__, r);
+}
+
+void MdpRot::doTransform() {
+    if(mOrientation & utils::OVERLAY_TRANSFORM_ROT_90)
+        utils::swap(mRotImgInfo.dst.width, mRotImgInfo.dst.height);
+}
+
+bool MdpRot::commit() {
+    doTransform();
+    if(rotConfChanged()) {
+        mRotImgInfo.enable = 1;
+        if(!overlay::mdp_wrapper::startRotator(mFd.getFD(), mRotImgInfo)) {
+            ALOGE("MdpRot commit failed");
+            dump();
+            mRotImgInfo.enable = 0;
+            return false;
+        }
+        save();
+        mRotDataInfo.session_id = mRotImgInfo.session_id;
+    }
+    return true;
+}
+
+uint32_t MdpRot::calcOutputBufSize() {
+    ovutils::Whf destWhf(mRotImgInfo.dst.width,
+            mRotImgInfo.dst.height, mRotImgInfo.dst.format);
+    return Rotator::calcOutputBufSize(destWhf);
+}
+
+bool MdpRot::open_i(uint32_t numbufs, uint32_t bufsz)
+{
+    OvMem mem;
+
+    OVASSERT(MAP_FAILED == mem.addr(), "MAP failed in open_i");
+
+    if(!mem.open(numbufs, bufsz, mRotImgInfo.secure)){
+        ALOGE("%s: Failed to open", __func__);
+        mem.close();
+        return false;
+    }
+
+    OVASSERT(MAP_FAILED != mem.addr(), "MAP failed");
+    OVASSERT(mem.getFD() != -1, "getFd is -1");
+
+    mRotDataInfo.dst.memory_id = mem.getFD();
+    mRotDataInfo.dst.offset = 0;
+    mMem.curr().m = mem;
+    return true;
+}
+
+bool MdpRot::close() {
+    bool success = true;
+    if(mFd.valid() && (getSessId() != 0)) {
+        if(!mdp_wrapper::endRotator(mFd.getFD(), getSessId())) {
+            ALOGE("Mdp Rot error endRotator, fd=%d sessId=%u",
+                    mFd.getFD(), getSessId());
+            success = false;
+        }
+    }
+    if (!mFd.close()) {
+        ALOGE("Mdp Rot error closing fd");
+        success = false;
+    }
+    if (!mMem.close()) {
+        ALOGE("Mdp Rot error closing mem");
+        success = false;
+    }
+    reset();
+    return success;
+}
+
+bool MdpRot::remap(uint32_t numbufs) {
+    // if current size changed, remap
+    uint32_t opBufSize = calcOutputBufSize();
+    if(opBufSize == mMem.curr().size()) {
+        ALOGE_IF(DEBUG_OVERLAY, "%s: same size %d", __FUNCTION__, opBufSize);
+        return true;
+    }
+
+    ALOGE_IF(DEBUG_OVERLAY, "%s: size changed - remapping", __FUNCTION__);
+    OVASSERT(!mMem.prev().valid(), "Prev should not be valid");
+
+    // ++mMem will make curr to be prev, and prev will be curr
+    ++mMem;
+    if(!open_i(numbufs, opBufSize)) {
+        ALOGE("%s Error could not open", __FUNCTION__);
+        return false;
+    }
+    for (uint32_t i = 0; i < numbufs; ++i) {
+        mMem.curr().mRotOffset[i] = i * opBufSize;
+    }
+    return true;
+}
+
+void MdpRot::reset() {
+    ovutils::memset0(mRotImgInfo);
+    ovutils::memset0(mLSRotImgInfo);
+    ovutils::memset0(mRotDataInfo);
+    ovutils::memset0(mMem.curr().mRotOffset);
+    ovutils::memset0(mMem.prev().mRotOffset);
+    mMem.curr().mCurrOffset = 0;
+    mMem.prev().mCurrOffset = 0;
+    mOrientation = utils::OVERLAY_TRANSFORM_0;
+}
+
+bool MdpRot::queueBuffer(int fd, uint32_t offset) {
+    if(enabled()) {
+        mRotDataInfo.src.memory_id = fd;
+        mRotDataInfo.src.offset = offset;
+
+        remap(RotMem::Mem::ROT_NUM_BUFS);
+        OVASSERT(mMem.curr().m.numBufs(),
+                "queueBuffer numbufs is 0");
+        mRotDataInfo.dst.offset =
+                mMem.curr().mRotOffset[mMem.curr().mCurrOffset];
+        mMem.curr().mCurrOffset =
+                (mMem.curr().mCurrOffset + 1) % mMem.curr().m.numBufs();
+
+        if(!overlay::mdp_wrapper::rotate(mFd.getFD(), mRotDataInfo)) {
+            ALOGE("MdpRot failed rotate");
+            dump();
+            return false;
+        }
+
+        // if the prev mem is valid, we need to close
+        if(mMem.prev().valid()) {
+            // FIXME if no wait for vsync the above
+            // play will return immediatly and might cause
+            // tearing when prev.close is called.
+            if(!mMem.prev().close()) {
+                ALOGE("%s error in closing prev rot mem", __FUNCTION__);
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
+void MdpRot::dump() const {
+    ALOGE("== Dump MdpRot start ==");
+    mFd.dump();
+    mMem.curr().m.dump();
+    mdp_wrapper::dump("mRotImgInfo", mRotImgInfo);
+    mdp_wrapper::dump("mRotDataInfo", mRotDataInfo);
+    ALOGE("== Dump MdpRot end ==");
+}
+
+void MdpRot::getDump(char *buf, size_t len) const {
+    ovutils::getDump(buf, len, "MdpRotCtrl", mRotImgInfo);
+    ovutils::getDump(buf, len, "MdpRotData", mRotDataInfo);
+}
+
+} // namespace overlay
diff --git a/msm8974/liboverlay/overlayMdssRot.cpp b/msm8974/liboverlay/overlayMdssRot.cpp
new file mode 100644
index 0000000..95f22c6
--- /dev/null
+++ b/msm8974/liboverlay/overlayMdssRot.cpp
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+*/
+
+#include "overlayUtils.h"
+#include "overlayRotator.h"
+
+#define DEBUG_MDSS_ROT 0
+
+#ifdef VENUS_COLOR_FORMAT
+#include <media/msm_media_info.h>
+#else
+#define VENUS_BUFFER_SIZE(args...) 0
+#endif
+
+#ifndef MDSS_MDP_ROT_ONLY
+#define MDSS_MDP_ROT_ONLY 0x80
+#endif
+
+#define SIZE_1M 0x00100000
+#define MDSS_ROT_MASK (MDP_ROT_90 | MDP_FLIP_UD | MDP_FLIP_LR)
+
+namespace ovutils = overlay::utils;
+
+namespace overlay {
+MdssRot::MdssRot() {
+    reset();
+    init();
+}
+
+MdssRot::~MdssRot() { close(); }
+
+bool MdssRot::enabled() const { return mEnabled; }
+
+void MdssRot::setRotations(uint32_t flags) { mRotInfo.flags |= flags; }
+
+int MdssRot::getDstMemId() const {
+    return mRotData.dst_data.memory_id;
+}
+
+uint32_t MdssRot::getDstOffset() const {
+    return mRotData.dst_data.offset;
+}
+
+uint32_t MdssRot::getDstFormat() const {
+    //For mdss src and dst formats are same
+    return mRotInfo.src.format;
+}
+
+uint32_t MdssRot::getSessId() const { return mRotInfo.id; }
+
+bool MdssRot::init() {
+    if(!utils::openDev(mFd, 0, Res::fbPath, O_RDWR)) {
+        ALOGE("MdssRot failed to init fb0");
+        return false;
+    }
+    return true;
+}
+
+void MdssRot::setSource(const overlay::utils::Whf& awhf) {
+    utils::Whf whf(awhf);
+
+    mRotInfo.src.format = whf.format;
+    mRotInfo.src.width = whf.w;
+    mRotInfo.src.height = whf.h;
+}
+
+void MdssRot::setCrop(const utils::Dim& crop) {
+
+    mRotInfo.src_rect.x = crop.x;
+    mRotInfo.src_rect.y = crop.y;
+    mRotInfo.src_rect.w = crop.w;
+    mRotInfo.src_rect.h = crop.h;
+
+    mRotInfo.dst_rect.x = 0;
+    mRotInfo.dst_rect.y = 0;
+    mRotInfo.dst_rect.w = crop.w;
+    mRotInfo.dst_rect.h = crop.h;
+}
+
+void MdssRot::setDownscale(int ds) {}
+
+void MdssRot::setFlags(const utils::eMdpFlags& flags) {
+    mRotInfo.flags = flags;
+}
+
+void MdssRot::setTransform(const utils::eTransform& rot)
+{
+    // reset rotation flags to avoid stale orientation values
+    mRotInfo.flags &= ~MDSS_ROT_MASK;
+    int flags = utils::getMdpOrient(rot);
+    if (flags != -1)
+        setRotations(flags);
+    mOrientation = static_cast<utils::eTransform>(flags);
+    ALOGE_IF(DEBUG_OVERLAY, "%s: rot=%d", __FUNCTION__, flags);
+}
+
+void MdssRot::doTransform() {
+    mRotInfo.flags |= mOrientation;
+    if(mOrientation & utils::OVERLAY_TRANSFORM_ROT_90)
+        utils::swap(mRotInfo.dst_rect.w, mRotInfo.dst_rect.h);
+}
+
+bool MdssRot::commit() {
+    doTransform();
+    mRotInfo.flags |= MDSS_MDP_ROT_ONLY;
+    mEnabled = true;
+    if(!overlay::mdp_wrapper::setOverlay(mFd.getFD(), mRotInfo)) {
+        ALOGE("MdssRot commit failed!");
+        dump();
+        return (mEnabled = false);
+    }
+    mRotData.id = mRotInfo.id;
+    return true;
+}
+
+bool MdssRot::queueBuffer(int fd, uint32_t offset) {
+    if(enabled()) {
+        mRotData.data.memory_id = fd;
+        mRotData.data.offset = offset;
+
+        remap(RotMem::Mem::ROT_NUM_BUFS);
+        OVASSERT(mMem.curr().m.numBufs(), "queueBuffer numbufs is 0");
+
+        mRotData.dst_data.offset =
+                mMem.curr().mRotOffset[mMem.curr().mCurrOffset];
+        mMem.curr().mCurrOffset =
+                (mMem.curr().mCurrOffset + 1) % mMem.curr().m.numBufs();
+
+        if(!overlay::mdp_wrapper::play(mFd.getFD(), mRotData)) {
+            ALOGE("MdssRot play failed!");
+            dump();
+            return false;
+        }
+
+        // if the prev mem is valid, we need to close
+        if(mMem.prev().valid()) {
+            // FIXME if no wait for vsync the above
+            // play will return immediatly and might cause
+            // tearing when prev.close is called.
+            if(!mMem.prev().close()) {
+                ALOGE("%s error in closing prev rot mem", __FUNCTION__);
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
+bool MdssRot::open_i(uint32_t numbufs, uint32_t bufsz)
+{
+    OvMem mem;
+    OVASSERT(MAP_FAILED == mem.addr(), "MAP failed in open_i");
+    bool isSecure = mRotInfo.flags & utils::OV_MDP_SECURE_OVERLAY_SESSION;
+
+    if(!mem.open(numbufs, bufsz, isSecure)){
+        ALOGE("%s: Failed to open", __func__);
+        mem.close();
+        return false;
+    }
+
+    OVASSERT(MAP_FAILED != mem.addr(), "MAP failed");
+    OVASSERT(mem.getFD() != -1, "getFd is -1");
+
+    mRotData.dst_data.memory_id = mem.getFD();
+    mRotData.dst_data.offset = 0;
+    mMem.curr().m = mem;
+    return true;
+}
+
+bool MdssRot::remap(uint32_t numbufs) {
+    // Calculate the size based on rotator's dst format, w and h.
+    uint32_t opBufSize = calcOutputBufSize();
+    // If current size changed, remap
+    if(opBufSize == mMem.curr().size()) {
+        ALOGE_IF(DEBUG_OVERLAY, "%s: same size %d", __FUNCTION__, opBufSize);
+        return true;
+    }
+
+    ALOGE_IF(DEBUG_OVERLAY, "%s: size changed - remapping", __FUNCTION__);
+    OVASSERT(!mMem.prev().valid(), "Prev should not be valid");
+
+    // ++mMem will make curr to be prev, and prev will be curr
+    ++mMem;
+    if(!open_i(numbufs, opBufSize)) {
+        ALOGE("%s Error could not open", __FUNCTION__);
+        return false;
+    }
+    for (uint32_t i = 0; i < numbufs; ++i) {
+        mMem.curr().mRotOffset[i] = i * opBufSize;
+    }
+    return true;
+}
+
+bool MdssRot::close() {
+    bool success = true;
+    if(mFd.valid() && (getSessId() != (uint32_t) MSMFB_NEW_REQUEST)) {
+        if(!mdp_wrapper::unsetOverlay(mFd.getFD(), getSessId())) {
+            ALOGE("MdssRot::close unsetOverlay failed, fd=%d sessId=%d",
+                  mFd.getFD(), getSessId());
+            success = false;
+        }
+    }
+
+    if (!mFd.close()) {
+        ALOGE("Mdss Rot error closing fd");
+        success = false;
+    }
+    if (!mMem.close()) {
+        ALOGE("Mdss Rot error closing mem");
+        success = false;
+    }
+    reset();
+    return success;
+}
+
+void MdssRot::reset() {
+    ovutils::memset0(mRotInfo);
+    ovutils::memset0(mRotData);
+    mRotData.data.memory_id = -1;
+    mRotInfo.id = MSMFB_NEW_REQUEST;
+    ovutils::memset0(mMem.curr().mRotOffset);
+    ovutils::memset0(mMem.prev().mRotOffset);
+    mMem.curr().mCurrOffset = 0;
+    mMem.prev().mCurrOffset = 0;
+    mOrientation = utils::OVERLAY_TRANSFORM_0;
+}
+
+void MdssRot::dump() const {
+    ALOGE("== Dump MdssRot start ==");
+    mFd.dump();
+    mMem.curr().m.dump();
+    mdp_wrapper::dump("mRotInfo", mRotInfo);
+    mdp_wrapper::dump("mRotData", mRotData);
+    ALOGE("== Dump MdssRot end ==");
+}
+
+uint32_t MdssRot::calcOutputBufSize() {
+    uint32_t opBufSize = 0;
+    ovutils::Whf destWhf(mRotInfo.dst_rect.w, mRotInfo.dst_rect.h,
+            mRotInfo.src.format); //mdss src and dst formats are same.
+
+    if (mRotInfo.flags & ovutils::OV_MDSS_MDP_BWC_EN) {
+        opBufSize = calcCompressedBufSize(destWhf);
+    } else {
+        opBufSize = Rotator::calcOutputBufSize(destWhf);
+    }
+
+    if (mRotInfo.flags & utils::OV_MDP_SECURE_OVERLAY_SESSION)
+        opBufSize = utils::align(opBufSize, SIZE_1M);
+
+    return opBufSize;
+}
+
+void MdssRot::getDump(char *buf, size_t len) const {
+    ovutils::getDump(buf, len, "MdssRotCtrl", mRotInfo);
+    ovutils::getDump(buf, len, "MdssRotData", mRotData);
+}
+
+// Calculate the compressed o/p buffer size for BWC
+uint32_t MdssRot::calcCompressedBufSize(const ovutils::Whf& destWhf) {
+    uint32_t bufSize = 0;
+    int aWidth = ovutils::align(destWhf.w, 64);
+    int aHeight = ovutils::align(destWhf.h, 4);
+    int rau_cnt = aWidth/64;
+    int stride0 = (64 * 4 * rau_cnt) + rau_cnt/8;
+    int stride1 = ((64 * 2 * rau_cnt) + rau_cnt/8) * 2;
+    int stride0_off = (aHeight/4);
+    int stride1_off = (aHeight/2);
+
+    //New o/p size for BWC
+    bufSize = (stride0 * stride0_off + stride1 * stride1_off) +
+                (rau_cnt * 2 * (stride0_off + stride1_off));
+    ALOGD_IF(DEBUG_MDSS_ROT, "%s: width = %d, height = %d raucount = %d"
+         "opBufSize = %d ", __FUNCTION__, aWidth, aHeight, rau_cnt, bufSize);
+    return bufSize;
+}
+
+} // namespace overlay
diff --git a/msm8974/liboverlay/overlayMem.h b/msm8974/liboverlay/overlayMem.h
new file mode 100644
index 0000000..061d197
--- /dev/null
+++ b/msm8974/liboverlay/overlayMem.h
@@ -0,0 +1,211 @@
+/*
+* Copyright (c) 2011, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#ifndef OVERLAY_MEM_H
+#define OVERLAY_MEM_H
+
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <alloc_controller.h>
+#include <memalloc.h>
+
+#include "gralloc_priv.h"
+#include "overlayUtils.h"
+
+namespace overlay {
+
+/*
+* Holds base address, offset and the fd
+* */
+class OvMem {
+public:
+    /* ctor init*/
+    explicit OvMem();
+
+    /* dtor DO NOT call close so it can be copied */
+    ~OvMem();
+
+    /* Use libgralloc to retrieve fd, base addr, alloc type */
+    bool open(uint32_t numbufs,
+            uint32_t bufSz, bool isSecure);
+
+    /* close fd. assign base address to invalid*/
+    bool close();
+
+    /* return underlying fd */
+    int getFD() const;
+
+    /* return true if fd is valid and base address is valid */
+    bool valid() const;
+
+    /* dump the state of the object */
+    void dump() const;
+
+    /* return underlying address */
+    void* addr() const;
+
+    /* return underlying offset */
+    uint32_t bufSz() const;
+
+    /* return number of bufs */
+    uint32_t numBufs() const ;
+
+private:
+    /* actual os fd */
+    int mFd;
+
+    /* points to base addr (mmap)*/
+    void* mBaseAddr;
+
+    /* allocated buffer type determined by gralloc (ashmem, ion, etc) */
+    int mAllocType;
+
+    /* holds buf size */
+    uint32_t mBufSz;
+
+    /* num of bufs */
+    uint32_t mNumBuffers;
+
+    /* gralloc alloc controller */
+    gralloc::IAllocController* mAlloc;
+};
+
+//-------------------Inlines-----------------------------------
+
+using gralloc::IMemAlloc;
+using gralloc::alloc_data;
+
+inline OvMem::OvMem() {
+    mFd = -1;
+    mBaseAddr = MAP_FAILED;
+    mAllocType = 0;
+    mBufSz = 0;
+    mNumBuffers = 0;
+    mAlloc = gralloc::IAllocController::getInstance();
+}
+
+inline OvMem::~OvMem() { }
+
+inline bool OvMem::open(uint32_t numbufs,
+        uint32_t bufSz, bool isSecure)
+{
+    alloc_data data;
+    int allocFlags = GRALLOC_USAGE_PRIVATE_IOMMU_HEAP;
+    if(isSecure) {
+        allocFlags = GRALLOC_USAGE_PRIVATE_MM_HEAP;
+        allocFlags |= GRALLOC_USAGE_PROTECTED;
+    }
+    // Allocate uncached rotator buffers
+    allocFlags |= GRALLOC_USAGE_PRIVATE_UNCACHED;
+
+    int err = 0;
+    OVASSERT(numbufs && bufSz, "numbufs=%d bufSz=%d", numbufs, bufSz);
+
+    mBufSz = bufSz;
+    mNumBuffers = numbufs;
+
+    data.base = 0;
+    data.fd = -1;
+    data.offset = 0;
+    data.size = mBufSz * mNumBuffers;
+    data.align = getpagesize();
+    data.uncached = true;
+
+    err = mAlloc->allocate(data, allocFlags);
+    if (err != 0) {
+        ALOGE("OvMem: Error allocating memory");
+        return false;
+    }
+
+    mFd = data.fd;
+    mBaseAddr = data.base;
+    mAllocType = data.allocType;
+
+    return true;
+}
+
+inline bool OvMem::close()
+{
+    int ret = 0;
+
+    if(!valid()) {
+        return true;
+    }
+
+    IMemAlloc* memalloc = mAlloc->getAllocator(mAllocType);
+    ret = memalloc->free_buffer(mBaseAddr, mBufSz * mNumBuffers, 0, mFd);
+    if (ret != 0) {
+        ALOGE("OvMem: error freeing buffer");
+        return false;
+    }
+
+    mFd = -1;
+    mBaseAddr = MAP_FAILED;
+    mAllocType = 0;
+    mBufSz = 0;
+    mNumBuffers = 0;
+    return true;
+}
+
+inline bool OvMem::valid() const
+{
+    return (mFd != -1) && (mBaseAddr != MAP_FAILED);
+}
+
+inline int OvMem::getFD() const
+{
+    return mFd;
+}
+
+inline void* OvMem::addr() const
+{
+    return mBaseAddr;
+}
+
+inline uint32_t OvMem::bufSz() const
+{
+    return mBufSz;
+}
+
+inline uint32_t OvMem::numBufs() const
+{
+    return mNumBuffers;
+}
+
+inline void OvMem::dump() const
+{
+    ALOGE("== Dump OvMem start ==");
+    ALOGE("fd=%d addr=%p type=%d bufsz=%u", mFd, mBaseAddr, mAllocType, mBufSz);
+    ALOGE("== Dump OvMem end ==");
+}
+
+} // overlay
+
+#endif // OVERLAY_MEM_H
diff --git a/msm8974/liboverlay/overlayRotator.cpp b/msm8974/liboverlay/overlayRotator.cpp
new file mode 100644
index 0000000..906e81b
--- /dev/null
+++ b/msm8974/liboverlay/overlayRotator.cpp
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (c) 2010-2012, The Linux Foundation. All rights reserved.
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+*/
+
+#include <sync/sync.h>
+#include "overlayRotator.h"
+#include "overlayUtils.h"
+#include "mdp_version.h"
+#include "gr.h"
+
+namespace ovutils = overlay::utils;
+
+namespace overlay {
+
+//============Rotator=========================
+
+Rotator::~Rotator() {}
+
+Rotator* Rotator::getRotator() {
+    int type = getRotatorHwType();
+    if(type == TYPE_MDP) {
+        return new MdpRot(); //will do reset
+    } else if(type == TYPE_MDSS) {
+        return new MdssRot();
+    } else {
+        ALOGE("%s Unknown h/w type %d", __FUNCTION__, type);
+        return NULL;
+    }
+}
+
+uint32_t Rotator::calcOutputBufSize(const utils::Whf& destWhf) {
+    //dummy aligned w & h.
+    int alW = 0, alH = 0;
+    int halFormat = ovutils::getHALFormat(destWhf.format);
+    //A call into gralloc/memalloc
+    return getBufferSizeAndDimensions(
+            destWhf.w, destWhf.h, halFormat, alW, alH);
+}
+
+int Rotator::getRotatorHwType() {
+    int mdpVersion = qdutils::MDPVersion::getInstance().getMDPVersion();
+    if (mdpVersion == qdutils::MDSS_V5)
+        return TYPE_MDSS;
+    return TYPE_MDP;
+}
+
+
+//============RotMem=========================
+
+bool RotMem::close() {
+    bool ret = true;
+    for(uint32_t i=0; i < RotMem::MAX_ROT_MEM; ++i) {
+        // skip current, and if valid, close
+        if(m[i].valid()) {
+            if(m[i].close() == false) {
+                ALOGE("%s error in closing rot mem %d", __FUNCTION__, i);
+                ret = false;
+            }
+        }
+    }
+    return ret;
+}
+
+RotMem::Mem::Mem() : mCurrOffset(0) {
+    utils::memset0(mRotOffset);
+    for(int i = 0; i < ROT_NUM_BUFS; i++) {
+        mRelFence[i] = -1;
+    }
+}
+
+RotMem::Mem::~Mem() {
+    for(int i = 0; i < ROT_NUM_BUFS; i++) {
+        ::close(mRelFence[i]);
+        mRelFence[i] = -1;
+    }
+}
+
+void RotMem::Mem::setReleaseFd(const int& fence) {
+    int ret = 0;
+
+    if(mRelFence[mCurrOffset] >= 0) {
+        //Wait for previous usage of this buffer to be over.
+        //Can happen if rotation takes > vsync and a fast producer. i.e queue
+        //happens in subsequent vsyncs either because content is 60fps or
+        //because the producer is hasty sometimes.
+        ret = sync_wait(mRelFence[mCurrOffset], 1000);
+        if(ret < 0) {
+            ALOGE("%s: sync_wait error!! error no = %d err str = %s",
+                __FUNCTION__, errno, strerror(errno));
+        }
+        ::close(mRelFence[mCurrOffset]);
+    }
+    mRelFence[mCurrOffset] = fence;
+}
+
+//============RotMgr=========================
+
+RotMgr::RotMgr() {
+    for(int i = 0; i < MAX_ROT_SESS; i++) {
+        mRot[i] = 0;
+    }
+    mUseCount = 0;
+    mRotDevFd = -1;
+}
+
+RotMgr::~RotMgr() {
+    clear();
+}
+
+void RotMgr::configBegin() {
+    //Reset the number of objects used
+    mUseCount = 0;
+}
+
+void RotMgr::configDone() {
+    //Remove the top most unused objects. Videos come and go.
+    for(int i = mUseCount; i < MAX_ROT_SESS; i++) {
+        if(mRot[i]) {
+            delete mRot[i];
+            mRot[i] = 0;
+        }
+    }
+}
+
+Rotator* RotMgr::getNext() {
+    //Return a rot object, creating one if necessary
+    overlay::Rotator *rot = NULL;
+    if(mUseCount >= MAX_ROT_SESS) {
+        ALOGE("%s, MAX rotator sessions reached", __func__);
+    } else {
+        if(mRot[mUseCount] == NULL)
+            mRot[mUseCount] = overlay::Rotator::getRotator();
+        rot = mRot[mUseCount++];
+    }
+    return rot;
+}
+
+void RotMgr::clear() {
+    //Brute force obj destruction, helpful in suspend.
+    for(int i = 0; i < MAX_ROT_SESS; i++) {
+        if(mRot[i]) {
+            delete mRot[i];
+            mRot[i] = 0;
+        }
+    }
+    mUseCount = 0;
+    ::close(mRotDevFd);
+    mRotDevFd = -1;
+}
+
+void RotMgr::getDump(char *buf, size_t len) {
+    for(int i = 0; i < MAX_ROT_SESS; i++) {
+        if(mRot[i]) {
+            mRot[i]->getDump(buf, len);
+        }
+    }
+    char str[4] = {'\0'};
+    snprintf(str, 4, "\n");
+    strncat(buf, str, strlen(str));
+}
+
+int RotMgr::getRotDevFd() {
+    if(mRotDevFd < 0 && Rotator::getRotatorHwType() == Rotator::TYPE_MDSS) {
+        mRotDevFd = ::open("/dev/graphics/fb0", O_RDWR, 0);
+        if(mRotDevFd < 0) {
+            ALOGE("%s failed to open fb0", __FUNCTION__);
+        }
+    }
+    return mRotDevFd;
+}
+
+}
diff --git a/msm8974/liboverlay/overlayRotator.h b/msm8974/liboverlay/overlayRotator.h
new file mode 100644
index 0000000..f551f1d
--- /dev/null
+++ b/msm8974/liboverlay/overlayRotator.h
@@ -0,0 +1,250 @@
+/*
+* Copyright (c) 2011,2013 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation. nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef OVERlAY_ROTATOR_H
+#define OVERlAY_ROTATOR_H
+
+#include <stdlib.h>
+
+#include "mdpWrapper.h"
+#include "overlayUtils.h"
+#include "overlayMem.h"
+
+namespace overlay {
+
+/*
+   Manages the case where new rotator memory needs to be
+   allocated, before previous is freed, due to resolution change etc. If we make
+   rotator memory to be always max size, irrespctive of source resolution then
+   we don't need this RotMem wrapper. The inner class is sufficient.
+*/
+struct RotMem {
+    // Max rotator memory allocations
+    enum { MAX_ROT_MEM = 2};
+
+    //Manages the rotator buffer offsets.
+    struct Mem {
+        Mem();
+        ~Mem();
+        bool valid() { return m.valid(); }
+        bool close() { return m.close(); }
+        uint32_t size() const { return m.bufSz(); }
+        void setReleaseFd(const int& fence);
+        // Max rotator buffers
+        enum { ROT_NUM_BUFS = 2 };
+        // rotator data info dst offset
+        uint32_t mRotOffset[ROT_NUM_BUFS];
+        int mRelFence[ROT_NUM_BUFS];
+        // current offset slot from mRotOffset
+        uint32_t mCurrOffset;
+        OvMem m;
+    };
+
+    RotMem() : _curr(0) {}
+    Mem& curr() { return m[_curr % MAX_ROT_MEM]; }
+    const Mem& curr() const { return m[_curr % MAX_ROT_MEM]; }
+    Mem& prev() { return m[(_curr+1) % MAX_ROT_MEM]; }
+    RotMem& operator++() { ++_curr; return *this; }
+    void setReleaseFd(const int& fence) { curr().setReleaseFd(fence); }
+    bool close();
+    uint32_t _curr;
+    Mem m[MAX_ROT_MEM];
+};
+
+class Rotator
+{
+public:
+    enum { TYPE_MDP, TYPE_MDSS };
+    virtual ~Rotator();
+    virtual void setSource(const utils::Whf& wfh) = 0;
+    virtual void setCrop(const utils::Dim& crop) = 0;
+    virtual void setFlags(const utils::eMdpFlags& flags) = 0;
+    virtual void setTransform(const utils::eTransform& rot) = 0;
+    virtual bool commit() = 0;
+    virtual void setDownscale(int ds) = 0;
+    virtual int getDstMemId() const = 0;
+    virtual uint32_t getDstOffset() const = 0;
+    virtual uint32_t getDstFormat() const = 0;
+    virtual uint32_t getSessId() const = 0;
+    virtual bool queueBuffer(int fd, uint32_t offset) = 0;
+    virtual void dump() const = 0;
+    virtual void getDump(char *buf, size_t len) const = 0;
+    void setReleaseFd(const int& fence) { mMem.setReleaseFd(fence); }
+    static Rotator *getRotator();
+
+protected:
+    /* Rotator memory manager */
+    RotMem mMem;
+    explicit Rotator() {}
+    static uint32_t calcOutputBufSize(const utils::Whf& destWhf);
+
+private:
+    /*Returns rotator h/w type */
+    static int getRotatorHwType();
+    friend class RotMgr;
+};
+
+/*
+* MDP rot holds MDP's rotation related structures.
+*
+* */
+class MdpRot : public Rotator {
+public:
+    virtual ~MdpRot();
+    virtual void setSource(const utils::Whf& wfh);
+    virtual void setCrop(const utils::Dim& crop);
+    virtual void setFlags(const utils::eMdpFlags& flags);
+    virtual void setTransform(const utils::eTransform& rot);
+    virtual bool commit();
+    virtual void setDownscale(int ds);
+    virtual int getDstMemId() const;
+    virtual uint32_t getDstOffset() const;
+    virtual uint32_t getDstFormat() const;
+    virtual uint32_t getSessId() const;
+    virtual bool queueBuffer(int fd, uint32_t offset);
+    virtual void dump() const;
+    virtual void getDump(char *buf, size_t len) const;
+
+private:
+    explicit MdpRot();
+    bool init();
+    bool close();
+    void setRotations(uint32_t r);
+    bool enabled () const;
+    /* remap rot buffers */
+    bool remap(uint32_t numbufs);
+    bool open_i(uint32_t numbufs, uint32_t bufsz);
+    /* Deferred transform calculations */
+    void doTransform();
+    /* reset underlying data, basically memset 0 */
+    void reset();
+    /* return true if current rotator config is different
+     * than last known config */
+    bool rotConfChanged() const;
+    /* save mRotImgInfo to be last known good config*/
+    void save();
+    /* Calculates the rotator's o/p buffer size post the transform calcs and
+     * knowing the o/p format depending on whether fastYuv is enabled or not */
+    uint32_t calcOutputBufSize();
+
+    /* rot info*/
+    msm_rotator_img_info mRotImgInfo;
+    /* Last saved rot info*/
+    msm_rotator_img_info mLSRotImgInfo;
+    /* rot data */
+    msm_rotator_data_info mRotDataInfo;
+    /* Orientation */
+    utils::eTransform mOrientation;
+    /* rotator fd */
+    OvFD mFd;
+
+    friend Rotator* Rotator::getRotator();
+};
+
+/*
++* MDSS Rot holds MDSS's rotation related structures.
++*
++* */
+class MdssRot : public Rotator {
+public:
+    virtual ~MdssRot();
+    virtual void setSource(const utils::Whf& wfh);
+    virtual void setCrop(const utils::Dim& crop);
+    virtual void setFlags(const utils::eMdpFlags& flags);
+    virtual void setTransform(const utils::eTransform& rot);
+    virtual bool commit();
+    virtual void setDownscale(int ds);
+    virtual int getDstMemId() const;
+    virtual uint32_t getDstOffset() const;
+    virtual uint32_t getDstFormat() const;
+    virtual uint32_t getSessId() const;
+    virtual bool queueBuffer(int fd, uint32_t offset);
+    virtual void dump() const;
+    virtual void getDump(char *buf, size_t len) const;
+
+private:
+    explicit MdssRot();
+    bool init();
+    bool close();
+    void setRotations(uint32_t r);
+    bool enabled () const;
+    /* remap rot buffers */
+    bool remap(uint32_t numbufs);
+    bool open_i(uint32_t numbufs, uint32_t bufsz);
+    /* Deferred transform calculations */
+    void doTransform();
+    /* reset underlying data, basically memset 0 */
+    void reset();
+    /* Calculates the rotator's o/p buffer size post the transform calcs and
+     * knowing the o/p format depending on whether fastYuv is enabled or not */
+    uint32_t calcOutputBufSize();
+    // Calculate the compressed o/p buffer size for BWC
+    uint32_t calcCompressedBufSize(const utils::Whf& destWhf);
+
+    /* MdssRot info structure */
+    mdp_overlay   mRotInfo;
+    /* MdssRot data structure */
+    msmfb_overlay_data mRotData;
+    /* Orientation */
+    utils::eTransform mOrientation;
+    /* rotator fd */
+    OvFD mFd;
+    /* Enable/Disable Mdss Rot*/
+    bool mEnabled;
+
+    friend Rotator* Rotator::getRotator();
+};
+
+// Holder of rotator objects. Manages lifetimes
+class RotMgr {
+public:
+    //Maximum sessions based on VG pipes, since rotator is used only for videos.
+    //Even though we can have 4 mixer stages, that much may be unnecessary.
+    enum { MAX_ROT_SESS = 3 };
+    RotMgr();
+    ~RotMgr();
+    void configBegin();
+    void configDone();
+    overlay::Rotator *getNext();
+    void clear(); //Removes all instances
+    /* Returns rot dump.
+     * Expects a NULL terminated buffer of big enough size.
+     */
+    void getDump(char *buf, size_t len);
+    int getRotDevFd();
+private:
+    overlay::Rotator *mRot[MAX_ROT_SESS];
+    int mUseCount;
+    int mRotDevFd;
+};
+
+
+} // overlay
+
+#endif // OVERlAY_ROTATOR_H
diff --git a/msm8974/liboverlay/overlayUtils.cpp b/msm8974/liboverlay/overlayUtils.cpp
new file mode 100644
index 0000000..d029694
--- /dev/null
+++ b/msm8974/liboverlay/overlayUtils.cpp
@@ -0,0 +1,487 @@
+/*
+* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <stdlib.h>
+#include <math.h>
+#include <utils/Log.h>
+#include <linux/msm_mdp.h>
+#include <cutils/properties.h>
+#include "gralloc_priv.h"
+#include "overlayUtils.h"
+#include "mdpWrapper.h"
+#include "mdp_version.h"
+
+// just a helper static thingy
+namespace {
+struct IOFile {
+    IOFile(const char* s, const char* mode) : fp(0) {
+        fp = ::fopen(s, mode);
+        if(!fp) {
+            ALOGE("Failed open %s", s);
+        }
+    }
+    template <class T>
+            size_t read(T& r, size_t elem) {
+                if(fp) {
+                    return ::fread(&r, sizeof(T), elem, fp);
+                }
+                return 0;
+            }
+    size_t write(const char* s, uint32_t val) {
+        if(fp) {
+            return ::fprintf(fp, s, val);
+        }
+        return 0;
+    }
+    bool valid() const { return fp != 0; }
+    ~IOFile() {
+        if(fp) ::fclose(fp);
+        fp=0;
+    }
+    FILE* fp;
+};
+}
+
+namespace overlay {
+
+//----------From class Res ------------------------------
+const char* const Res::fbPath = "/dev/graphics/fb%u";
+const char* const Res::rotPath = "/dev/msm_rotator";
+const char* const Res::format3DFile =
+        "/sys/class/graphics/fb1/format_3d";
+const char* const Res::edid3dInfoFile =
+        "/sys/class/graphics/fb1/3d_present";
+const char* const Res::barrierFile =
+        "/sys/devices/platform/mipi_novatek.0/enable_3d_barrier";
+//--------------------------------------------------------
+
+
+
+namespace utils {
+
+//--------------------------------------------------------
+//Refer to graphics.h, gralloc_priv.h, msm_mdp.h
+int getMdpFormat(int format) {
+    switch (format) {
+        //From graphics.h
+        case HAL_PIXEL_FORMAT_RGBA_8888 :
+            return MDP_RGBA_8888;
+        case HAL_PIXEL_FORMAT_RGBX_8888:
+            return MDP_RGBX_8888;
+        case HAL_PIXEL_FORMAT_RGB_888:
+            return MDP_RGB_888;
+        case HAL_PIXEL_FORMAT_RGB_565:
+            return MDP_RGB_565;
+        case HAL_PIXEL_FORMAT_BGRA_8888:
+            return MDP_BGRA_8888;
+        case HAL_PIXEL_FORMAT_YV12:
+            return MDP_Y_CR_CB_GH2V2;
+        case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+            return MDP_Y_CBCR_H2V1;
+        case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+            return MDP_Y_CRCB_H2V2;
+
+        //From gralloc_priv.h
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
+            return MDP_Y_CBCR_H2V2_TILE;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+            return MDP_Y_CBCR_H2V2;
+        case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+            return MDP_Y_CRCB_H2V1;
+        case HAL_PIXEL_FORMAT_YCbCr_444_SP:
+            return MDP_Y_CBCR_H1V1;
+        case HAL_PIXEL_FORMAT_YCrCb_444_SP:
+            return MDP_Y_CRCB_H1V1;
+        case HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS:
+        case HAL_PIXEL_FORMAT_NV12_ENCODEABLE:
+            //NV12 encodeable format maps to the venus format on
+            //B-Family targets
+            return MDP_Y_CBCR_H2V2_VENUS;
+        default:
+            //Unsupported by MDP
+            //---graphics.h--------
+            //HAL_PIXEL_FORMAT_RGBA_5551
+            //HAL_PIXEL_FORMAT_RGBA_4444
+            //HAL_PIXEL_FORMAT_YCbCr_422_I
+            //---gralloc_priv.h-----
+            //HAL_PIXEL_FORMAT_YCrCb_420_SP_ADRENO    = 0x7FA30C01
+            //HAL_PIXEL_FORMAT_R_8                    = 0x10D
+            //HAL_PIXEL_FORMAT_RG_88                  = 0x10E
+            ALOGE("%s: Unsupported HAL format = 0x%x", __func__, format);
+            return -1;
+    }
+    // not reached
+    return -1;
+}
+
+//Takes mdp format as input and translates to equivalent HAL format
+//Refer to graphics.h, gralloc_priv.h, msm_mdp.h for formats.
+int getHALFormat(int mdpFormat) {
+    switch (mdpFormat) {
+        //From graphics.h
+        case MDP_RGBA_8888:
+            return HAL_PIXEL_FORMAT_RGBA_8888;
+        case MDP_RGBX_8888:
+            return HAL_PIXEL_FORMAT_RGBX_8888;
+        case MDP_RGB_888:
+            return HAL_PIXEL_FORMAT_RGB_888;
+        case MDP_RGB_565:
+            return HAL_PIXEL_FORMAT_RGB_565;
+        case MDP_BGRA_8888:
+            return HAL_PIXEL_FORMAT_BGRA_8888;
+        case MDP_Y_CR_CB_GH2V2:
+            return HAL_PIXEL_FORMAT_YV12;
+        case MDP_Y_CBCR_H2V1:
+            return HAL_PIXEL_FORMAT_YCbCr_422_SP;
+        case MDP_Y_CRCB_H2V2:
+            return HAL_PIXEL_FORMAT_YCrCb_420_SP;
+
+        //From gralloc_priv.h
+        case MDP_Y_CBCR_H2V2_TILE:
+            return HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED;
+        case MDP_Y_CBCR_H2V2:
+            return HAL_PIXEL_FORMAT_YCbCr_420_SP;
+        case MDP_Y_CRCB_H2V1:
+            return HAL_PIXEL_FORMAT_YCrCb_422_SP;
+        case MDP_Y_CBCR_H1V1:
+            return HAL_PIXEL_FORMAT_YCbCr_444_SP;
+        case MDP_Y_CRCB_H1V1:
+            return HAL_PIXEL_FORMAT_YCrCb_444_SP;
+        case MDP_Y_CBCR_H2V2_VENUS:
+            return HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS;
+        default:
+            ALOGE("%s: Unsupported MDP format = 0x%x", __func__, mdpFormat);
+            return -1;
+    }
+    // not reached
+    return -1;
+}
+
+int getMdpOrient(eTransform rotation) {
+    int retTrans = 0;
+    bool trans90 = false;
+    int mdpVersion = qdutils::MDPVersion::getInstance().getMDPVersion();
+    bool aFamily = (mdpVersion < qdutils::MDSS_V5);
+
+    ALOGD_IF(DEBUG_OVERLAY, "%s: In rotation = %d", __FUNCTION__, rotation);
+    if(rotation & OVERLAY_TRANSFORM_ROT_90) {
+        retTrans |= MDP_ROT_90;
+        trans90 = true;
+    }
+
+    if(rotation & OVERLAY_TRANSFORM_FLIP_H) {
+        if(trans90 && aFamily) {
+            //Swap for a-family, since its driver does 90 first
+            retTrans |= MDP_FLIP_UD;
+        } else {
+            retTrans |= MDP_FLIP_LR;
+        }
+    }
+
+    if(rotation & OVERLAY_TRANSFORM_FLIP_V) {
+        if(trans90 && aFamily) {
+            //Swap for a-family, since its driver does 90 first
+            retTrans |= MDP_FLIP_LR;
+        } else {
+            retTrans |= MDP_FLIP_UD;
+        }
+    }
+
+    ALOGD_IF(DEBUG_OVERLAY, "%s: Out rotation = %d", __FUNCTION__, retTrans);
+    return retTrans;
+}
+
+int getDownscaleFactor(const int& src_w, const int& src_h,
+        const int& dst_w, const int& dst_h) {
+    int dscale_factor = utils::ROT_DS_NONE;
+    // The tolerance is an empirical grey area that needs to be adjusted
+    // manually so that we always err on the side of caution
+    float fDscaleTolerance = 0.05;
+    // We need this check to engage the rotator whenever possible to assist MDP
+    // in performing video downscale.
+    // This saves bandwidth and avoids causing the driver to make too many panel
+    // -mode switches between BLT (writeback) and non-BLT (Direct) modes.
+    // Use-case: Video playback [with downscaling and rotation].
+    if (dst_w && dst_h)
+    {
+        float fDscale =  sqrtf((float)(src_w * src_h) / (float)(dst_w * dst_h)) +
+                         fDscaleTolerance;
+
+        // On our MTP 1080p playback case downscale after sqrt is coming to 1.87
+        // we were rounding to 1. So entirely MDP has to do the downscaling.
+        // BW requirement and clock requirement is high across MDP4 targets.
+        // It is unable to downscale 1080p video to panel resolution on 8960.
+        // round(x) will round it to nearest integer and avoids above issue.
+        uint32_t dscale = round(fDscale);
+
+        if(dscale < 2) {
+            // Down-scale to > 50% of orig.
+            dscale_factor = utils::ROT_DS_NONE;
+        } else if(dscale < 4) {
+            // Down-scale to between > 25% to <= 50% of orig.
+            dscale_factor = utils::ROT_DS_HALF;
+        } else if(dscale < 8) {
+            // Down-scale to between > 12.5% to <= 25% of orig.
+            dscale_factor = utils::ROT_DS_FOURTH;
+        } else {
+            // Down-scale to <= 12.5% of orig.
+            dscale_factor = utils::ROT_DS_EIGHTH;
+        }
+    }
+    return dscale_factor;
+}
+
+void getDecimationFactor(const int& src_w, const int& src_h,
+        const int& dst_w, const int& dst_h, uint8_t& horzDeci,
+        uint8_t& vertDeci) {
+    horzDeci = 0;
+    vertDeci = 0;
+    float horDscale = ceilf((float)src_w / (float)dst_w);
+    float verDscale = ceilf((float)src_h / (float)dst_h);
+
+    //Next power of 2, if not already
+    horDscale = powf(2.0f, ceilf(log2f(horDscale)));
+    verDscale = powf(2.0f, ceilf(log2f(verDscale)));
+
+    //Since MDP can do 1/4 dscale and has better quality, split the task
+    //between decimator and MDP downscale
+    horDscale /= 4.0f;
+    verDscale /= 4.0f;
+
+    if((int)horDscale)
+        horzDeci = (uint8_t)log2f(horDscale);
+
+    if((int)verDscale)
+        vertDeci = (uint8_t)log2f(verDscale);
+
+    if(src_w > 2048) {
+        //If the client sends us something > what a layer mixer supports
+        //then it means it doesn't want to use split-pipe but wants us to
+        //decimate. A minimum decimation of 2 will ensure that the width is
+        //always within layer mixer limits.
+        if(horzDeci < 2)
+            horzDeci = 2;
+    }
+}
+
+static inline int compute(const uint32_t& x, const uint32_t& y,
+        const uint32_t& z) {
+    return x - ( y + z );
+}
+
+void preRotateSource(const eTransform& tr, Whf& whf, Dim& srcCrop) {
+    if(tr & OVERLAY_TRANSFORM_FLIP_H) {
+        srcCrop.x = compute(whf.w, srcCrop.x, srcCrop.w);
+    }
+    if(tr & OVERLAY_TRANSFORM_FLIP_V) {
+        srcCrop.y = compute(whf.h, srcCrop.y, srcCrop.h);
+    }
+    if(tr & OVERLAY_TRANSFORM_ROT_90) {
+        int tmp = srcCrop.x;
+        srcCrop.x = compute(whf.h,
+                srcCrop.y,
+                srcCrop.h);
+        srcCrop.y = tmp;
+        swap(whf.w, whf.h);
+        swap(srcCrop.w, srcCrop.h);
+    }
+}
+
+bool is3DTV() {
+    char is3DTV = '0';
+    IOFile fp(Res::edid3dInfoFile, "r");
+    (void)fp.read(is3DTV, 1);
+    ALOGI("3DTV EDID flag: %d", is3DTV);
+    return (is3DTV == '0') ? false : true;
+}
+
+bool isPanel3D() {
+    OvFD fd;
+    if(!overlay::open(fd, 0 /*fb*/, Res::fbPath)){
+        ALOGE("isPanel3D Can't open framebuffer 0");
+        return false;
+    }
+    fb_fix_screeninfo finfo;
+    if(!mdp_wrapper::getFScreenInfo(fd.getFD(), finfo)) {
+        ALOGE("isPanel3D read fb0 failed");
+    }
+    fd.close();
+    return (FB_TYPE_3D_PANEL == finfo.type) ? true : false;
+}
+
+bool usePanel3D() {
+    if(!isPanel3D())
+        return false;
+    char value[PROPERTY_VALUE_MAX];
+    property_get("persist.user.panel3D", value, "0");
+    int usePanel3D = atoi(value);
+    return usePanel3D ? true : false;
+}
+
+bool send3DInfoPacket (uint32_t format3D) {
+    IOFile fp(Res::format3DFile, "wb");
+    (void)fp.write("%d", format3D);
+    if(!fp.valid()) {
+        ALOGE("send3DInfoPacket: no sysfs entry for setting 3d mode");
+        return false;
+    }
+    return true;
+}
+
+bool enableBarrier (uint32_t orientation) {
+    IOFile fp(Res::barrierFile, "wb");
+    (void)fp.write("%d", orientation);
+    if(!fp.valid()) {
+        ALOGE("enableBarrier no sysfs entry for "
+                "enabling barriers on 3D panel");
+        return false;
+    }
+    return true;
+}
+
+uint32_t getS3DFormat(uint32_t fmt) {
+    // The S3D is part of the HAL_PIXEL_FORMAT_YV12 value. Add
+    // an explicit check for the format
+    if (fmt == HAL_PIXEL_FORMAT_YV12) {
+        return 0;
+    }
+    uint32_t fmt3D = format3D(fmt);
+    uint32_t fIn3D = format3DInput(fmt3D); // MSB 2 bytes - inp
+    uint32_t fOut3D = format3DOutput(fmt3D); // LSB 2 bytes - out
+    fmt3D = fIn3D | fOut3D;
+    if (!fIn3D) {
+        fmt3D |= fOut3D << SHIFT_TOT_3D; //Set the input format
+    }
+    if (!fOut3D) {
+        switch (fIn3D) {
+            case HAL_3D_IN_SIDE_BY_SIDE_L_R:
+            case HAL_3D_IN_SIDE_BY_SIDE_R_L:
+                // For all side by side formats, set the output
+                // format as Side-by-Side i.e 0x1
+                fmt3D |= HAL_3D_IN_SIDE_BY_SIDE_L_R >> SHIFT_TOT_3D;
+                break;
+            default:
+                fmt3D |= fIn3D >> SHIFT_TOT_3D; //Set the output format
+        }
+    }
+    return fmt3D;
+}
+
+void getDump(char *buf, size_t len, const char *prefix,
+        const mdp_overlay& ov) {
+    char str[256] = {'\0'};
+    snprintf(str, 256,
+            "%s id=%d z=%d fg=%d alpha=%d mask=%d flags=0x%x H.Deci=%d,"
+            "V.Deci=%d\n",
+            prefix, ov.id, ov.z_order, ov.is_fg, ov.alpha,
+            ov.transp_mask, ov.flags, ov.horz_deci, ov.vert_deci);
+    strncat(buf, str, strlen(str));
+    getDump(buf, len, "\tsrc", ov.src);
+    getDump(buf, len, "\tsrc_rect", ov.src_rect);
+    getDump(buf, len, "\tdst_rect", ov.dst_rect);
+}
+
+void getDump(char *buf, size_t len, const char *prefix,
+        const msmfb_img& ov) {
+    char str_src[256] = {'\0'};
+    snprintf(str_src, 256,
+            "%s w=%d h=%d format=%d %s\n",
+            prefix, ov.width, ov.height, ov.format,
+            overlay::utils::getFormatString(ov.format));
+    strncat(buf, str_src, strlen(str_src));
+}
+
+void getDump(char *buf, size_t len, const char *prefix,
+        const mdp_rect& ov) {
+    char str_rect[256] = {'\0'};
+    snprintf(str_rect, 256,
+            "%s x=%d y=%d w=%d h=%d\n",
+            prefix, ov.x, ov.y, ov.w, ov.h);
+    strncat(buf, str_rect, strlen(str_rect));
+}
+
+void getDump(char *buf, size_t len, const char *prefix,
+        const msmfb_overlay_data& ov) {
+    char str[256] = {'\0'};
+    snprintf(str, 256,
+            "%s id=%d\n",
+            prefix, ov.id);
+    strncat(buf, str, strlen(str));
+    getDump(buf, len, "\tdata", ov.data);
+}
+
+void getDump(char *buf, size_t len, const char *prefix,
+        const msmfb_data& ov) {
+    char str_data[256] = {'\0'};
+    snprintf(str_data, 256,
+            "%s offset=%d memid=%d id=%d flags=0x%x\n",
+            prefix, ov.offset, ov.memory_id, ov.id, ov.flags);
+    strncat(buf, str_data, strlen(str_data));
+}
+
+void getDump(char *buf, size_t len, const char *prefix,
+        const msm_rotator_img_info& rot) {
+    char str[256] = {'\0'};
+    snprintf(str, 256, "%s sessid=%u rot=%d, enable=%d downscale=%d\n",
+            prefix, rot.session_id, rot.rotations, rot.enable,
+            rot.downscale_ratio);
+    strncat(buf, str, strlen(str));
+    getDump(buf, len, "\tsrc", rot.src);
+    getDump(buf, len, "\tdst", rot.dst);
+    getDump(buf, len, "\tsrc_rect", rot.src_rect);
+}
+
+void getDump(char *buf, size_t len, const char *prefix,
+        const msm_rotator_data_info& rot) {
+    char str[256] = {'\0'};
+    snprintf(str, 256,
+            "%s sessid=%u\n",
+            prefix, rot.session_id);
+    strncat(buf, str, strlen(str));
+    getDump(buf, len, "\tsrc", rot.src);
+    getDump(buf, len, "\tdst", rot.dst);
+}
+
+//Helper to even out x,w and y,h pairs
+//x,y are always evened to ceil and w,h are evened to floor
+void normalizeCrop(uint32_t& xy, uint32_t& wh) {
+    if(xy & 1) {
+        even_ceil(xy);
+        if(wh & 1)
+            even_floor(wh);
+        else
+            wh -= 2;
+    } else {
+        even_floor(wh);
+    }
+}
+
+} // utils
+
+} // overlay
diff --git a/msm8974/liboverlay/overlayUtils.h b/msm8974/liboverlay/overlayUtils.h
new file mode 100644
index 0000000..c8ee259
--- /dev/null
+++ b/msm8974/liboverlay/overlayUtils.h
@@ -0,0 +1,834 @@
+/*
+* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef OVERLAY_UTILS_H
+#define OVERLAY_UTILS_H
+
+#include <cutils/log.h> // ALOGE, etc
+#include <errno.h>
+#include <fcntl.h> // open, O_RDWR, etc
+#include <hardware/hardware.h>
+#include <hardware/gralloc.h> // buffer_handle_t
+#include <linux/msm_mdp.h> // flags
+#include <linux/msm_rotator.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <utils/Log.h>
+#include "gralloc_priv.h" //for interlace
+
+// Older platforms do not support Venus.
+#ifndef VENUS_COLOR_FORMAT
+#define MDP_Y_CBCR_H2V2_VENUS MDP_IMGTYPE_LIMIT
+#endif
+
+/*
+*
+* Collection of utilities functions/structs/enums etc...
+*
+* */
+
+// comment that out if you want to remove asserts
+// or put it as -D in Android.mk. your choice.
+#define OVERLAY_HAS_ASSERT
+
+#ifdef OVERLAY_HAS_ASSERT
+# define OVASSERT(x, ...) if(!(x)) { ALOGE(__VA_ARGS__); abort(); }
+#else
+# define OVASSERT(x, ...) ALOGE_IF(!(x), __VA_ARGS__)
+#endif // OVERLAY_HAS_ASSERT
+
+#define DEBUG_OVERLAY 0
+#define PROFILE_OVERLAY 0
+
+#ifndef MDSS_MDP_RIGHT_MIXER
+#define MDSS_MDP_RIGHT_MIXER 0x100
+#endif
+
+#ifndef MDP_OV_PIPE_FORCE_DMA
+#define MDP_OV_PIPE_FORCE_DMA 0x4000
+#endif
+
+#define FB_DEVICE_TEMPLATE "/dev/graphics/fb%u"
+
+namespace overlay {
+
+// fwd
+class Overlay;
+class OvFD;
+
+/* helper function to open by using fbnum */
+bool open(OvFD& fd, uint32_t fbnum, const char* const dev,
+    int flags = O_RDWR);
+
+namespace utils {
+struct Whf;
+struct Dim;
+
+inline uint32_t setBit(uint32_t x, uint32_t mask) {
+    return (x | mask);
+}
+
+inline uint32_t clrBit(uint32_t x, uint32_t mask) {
+    return (x & ~mask);
+}
+
+/* Utility class to help avoid copying instances by making the copy ctor
+* and assignment operator private
+*
+* Usage:
+*    class SomeClass : utils::NoCopy {...};
+*/
+class NoCopy {
+protected:
+    NoCopy(){}
+    ~NoCopy() {}
+private:
+    NoCopy(const NoCopy&);
+    const NoCopy& operator=(const NoCopy&);
+};
+
+
+/* 3D related utils, defines etc...
+ * The compound format passed to the overlay is
+ * ABCCC where A is the input 3D format
+ * B is the output 3D format
+ * CCC is the color format e.g YCbCr420SP YCrCb420SP etc */
+enum { SHIFT_OUT_3D = 12,
+    SHIFT_TOT_3D = 16 };
+enum { INPUT_3D_MASK = 0xFFFF0000,
+    OUTPUT_3D_MASK = 0x0000FFFF };
+enum { BARRIER_LAND = 1,
+    BARRIER_PORT = 2 };
+
+inline uint32_t format3D(uint32_t x) { return x & 0xFF000; }
+inline uint32_t format3DOutput(uint32_t x) {
+    return (x & 0xF000) >> SHIFT_OUT_3D; }
+inline uint32_t format3DInput(uint32_t x) { return x & 0xF0000; }
+
+bool isHDMIConnected ();
+bool is3DTV();
+bool isPanel3D();
+bool usePanel3D();
+bool send3DInfoPacket (uint32_t fmt);
+bool enableBarrier (uint32_t orientation);
+uint32_t getS3DFormat(uint32_t fmt);
+bool isMdssRotator();
+void normalizeCrop(uint32_t& xy, uint32_t& wh);
+
+template <int CHAN>
+bool getPositionS3D(const Whf& whf, Dim& out);
+
+template <int CHAN>
+bool getCropS3D(const Dim& in, Dim& out, uint32_t fmt);
+
+template <class Type>
+void swapWidthHeight(Type& width, Type& height);
+
+struct Dim {
+    Dim () : x(0), y(0),
+    w(0), h(0),
+    o(0) {}
+    Dim(uint32_t _x, uint32_t _y, uint32_t _w, uint32_t _h) :
+        x(_x), y(_y),
+        w(_w), h(_h) {}
+    Dim(uint32_t _x, uint32_t _y, uint32_t _w, uint32_t _h, uint32_t _o) :
+        x(_x), y(_y),
+        w(_w), h(_h),
+        o(_o) {}
+    bool check(uint32_t _w, uint32_t _h) const {
+        return (x+w <= _w && y+h <= _h);
+
+    }
+
+    bool operator==(const Dim& d) const {
+        return d.x == x && d.y == y &&
+                d.w == w && d.h == h &&
+                d.o == o;
+    }
+
+    bool operator!=(const Dim& d) const {
+        return !operator==(d);
+    }
+
+    void dump() const;
+    uint32_t x;
+    uint32_t y;
+    uint32_t w;
+    uint32_t h;
+    uint32_t o;
+};
+
+// TODO have Whfz
+
+struct Whf {
+    Whf() : w(0), h(0), format(0), size(0) {}
+    Whf(uint32_t wi, uint32_t he, uint32_t f) :
+        w(wi), h(he), format(f), size(0) {}
+    Whf(uint32_t wi, uint32_t he, uint32_t f, uint32_t s) :
+        w(wi), h(he), format(f), size(s) {}
+    // FIXME not comparing size at the moment
+    bool operator==(const Whf& whf) const {
+        return whf.w == w && whf.h == h &&
+                whf.format == format;
+    }
+    bool operator!=(const Whf& whf) const {
+        return !operator==(whf);
+    }
+    void dump() const;
+    uint32_t w;
+    uint32_t h;
+    uint32_t format;
+    uint32_t size;
+};
+
+enum { MAX_PATH_LEN = 256 };
+
+enum { DEFAULT_PLANE_ALPHA = 0xFF };
+
+/**
+ * Rotator flags: not to be confused with orientation flags.
+ * Usually, you want to open the rotator to make sure it is
+ * ready for business.
+ * */
+ enum eRotFlags {
+    ROT_FLAGS_NONE = 0,
+    //Use rotator for 0 rotation. It is used anyway for others.
+    ROT_0_ENABLED = 1 << 0,
+    //Enable rotator downscale optimization for hardware bugs not handled in
+    //driver. If downscale optimizatation is required,
+    //then rotator will be used even if its 0 rotation case.
+    ROT_DOWNSCALE_ENABLED = 1 << 1,
+    ROT_PREROTATED = 1 << 2,
+};
+
+enum eRotDownscale {
+    ROT_DS_NONE = 0,
+    ROT_DS_HALF = 1,
+    ROT_DS_FOURTH = 2,
+    ROT_DS_EIGHTH = 3,
+};
+
+/* The values for is_fg flag for control alpha and transp
+ * IS_FG_OFF means is_fg = 0
+ * IS_FG_SET means is_fg = 1
+ */
+enum eIsFg {
+    IS_FG_OFF = 0,
+    IS_FG_SET = 1
+};
+
+/*
+ * Various mdp flags like PIPE SHARE, DEINTERLACE etc...
+ * kernel/common/linux/msm_mdp.h
+ * INTERLACE_MASK: hardware/qcom/display/libgralloc/badger/fb_priv.h
+ * */
+enum eMdpFlags {
+    OV_MDP_FLAGS_NONE = 0,
+    OV_MDP_PIPE_SHARE =  MDP_OV_PIPE_SHARE,
+    OV_MDP_PIPE_FORCE_DMA = MDP_OV_PIPE_FORCE_DMA,
+    OV_MDP_DEINTERLACE = MDP_DEINTERLACE,
+    OV_MDP_SECURE_OVERLAY_SESSION = MDP_SECURE_OVERLAY_SESSION,
+    OV_MDP_SOURCE_ROTATED_90 = MDP_SOURCE_ROTATED_90,
+    OV_MDP_BACKEND_COMPOSITION = MDP_BACKEND_COMPOSITION,
+    OV_MDP_BLEND_FG_PREMULT = MDP_BLEND_FG_PREMULT,
+    OV_MDP_FLIP_H = MDP_FLIP_LR,
+    OV_MDP_FLIP_V = MDP_FLIP_UD,
+    OV_MDSS_MDP_RIGHT_MIXER = MDSS_MDP_RIGHT_MIXER,
+    OV_MDP_PP_EN = MDP_OVERLAY_PP_CFG_EN,
+    OV_MDSS_MDP_BWC_EN = MDP_BWC_EN,
+};
+
+enum eZorder {
+    ZORDER_0 = 0,
+    ZORDER_1,
+    ZORDER_2,
+    ZORDER_3,
+    Z_SYSTEM_ALLOC = 0xFFFF
+};
+
+enum eMdpPipeType {
+    OV_MDP_PIPE_RGB = 0,
+    OV_MDP_PIPE_VG,
+    OV_MDP_PIPE_DMA,
+    OV_MDP_PIPE_ANY, //Any
+};
+
+// Identify destination pipes
+// TODO Names useless, replace with int and change all interfaces
+enum eDest {
+    OV_P0 = 0,
+    OV_P1,
+    OV_P2,
+    OV_P3,
+    OV_P4,
+    OV_P5,
+    OV_P6,
+    OV_P7,
+    OV_P8,
+    OV_P9,
+    OV_INVALID,
+    OV_MAX = OV_INVALID,
+};
+
+/* Used when a buffer is split over 2 pipes and sent to display */
+enum {
+    OV_LEFT_SPLIT = 0,
+    OV_RIGHT_SPLIT,
+};
+
+/* values for copybit_set_parameter(OVERLAY_TRANSFORM) */
+enum eTransform {
+    /* No rot */
+    OVERLAY_TRANSFORM_0 = 0x0,
+    /* flip source image horizontally 0x1 */
+    OVERLAY_TRANSFORM_FLIP_H = HAL_TRANSFORM_FLIP_H,
+    /* flip source image vertically 0x2 */
+    OVERLAY_TRANSFORM_FLIP_V = HAL_TRANSFORM_FLIP_V,
+    /* rotate source image 180 degrees
+     * It is basically bit-or-ed  H | V == 0x3 */
+    OVERLAY_TRANSFORM_ROT_180 = HAL_TRANSFORM_ROT_180,
+    /* rotate source image 90 degrees 0x4 */
+    OVERLAY_TRANSFORM_ROT_90 = HAL_TRANSFORM_ROT_90,
+    /* rotate source image 90 degrees and flip horizontally 0x5 */
+    OVERLAY_TRANSFORM_ROT_90_FLIP_H = HAL_TRANSFORM_ROT_90 |
+                                      HAL_TRANSFORM_FLIP_H,
+    /* rotate source image 90 degrees and flip vertically 0x6 */
+    OVERLAY_TRANSFORM_ROT_90_FLIP_V = HAL_TRANSFORM_ROT_90 |
+                                      HAL_TRANSFORM_FLIP_V,
+    /* rotate source image 270 degrees
+     * Basically 180 | 90 == 0x7 */
+    OVERLAY_TRANSFORM_ROT_270 = HAL_TRANSFORM_ROT_270,
+    /* rotate invalid like in Transform.h */
+    OVERLAY_TRANSFORM_INV = 0x80
+};
+
+enum eBlending {
+    OVERLAY_BLENDING_UNDEFINED = 0x0,
+    /* No blending */
+    OVERLAY_BLENDING_OPAQUE,
+    /* src.rgb + dst.rgb*(1-src_alpha) */
+    OVERLAY_BLENDING_PREMULT,
+    /* src.rgb * src_alpha + dst.rgb (1 - src_alpha) */
+    OVERLAY_BLENDING_COVERAGE,
+};
+
+// Used to consolidate pipe params
+struct PipeArgs {
+    PipeArgs() : mdpFlags(OV_MDP_FLAGS_NONE),
+        zorder(Z_SYSTEM_ALLOC),
+        isFg(IS_FG_OFF),
+        rotFlags(ROT_FLAGS_NONE),
+        planeAlpha(DEFAULT_PLANE_ALPHA),
+        blending(OVERLAY_BLENDING_COVERAGE){
+    }
+
+    PipeArgs(eMdpFlags f, Whf _whf,
+            eZorder z, eIsFg fg, eRotFlags r,
+            int pA, eBlending b) :
+        mdpFlags(f),
+        whf(_whf),
+        zorder(z),
+        isFg(fg),
+        rotFlags(r),
+        planeAlpha(pA),
+        blending(b){
+    }
+
+    eMdpFlags mdpFlags; // for mdp_overlay flags
+    Whf whf;
+    eZorder zorder; // stage number
+    eIsFg isFg; // control alpha & transp
+    eRotFlags rotFlags;
+    int planeAlpha;
+    eBlending blending;
+};
+
+// Cannot use HW_OVERLAY_MAGNIFICATION_LIMIT, since at the time
+// of integration, HW_OVERLAY_MAGNIFICATION_LIMIT was a define
+enum { HW_OV_MAGNIFICATION_LIMIT = 20,
+    HW_OV_MINIFICATION_LIMIT  = 8
+};
+
+inline void setMdpFlags(eMdpFlags& f, eMdpFlags v) {
+    f = static_cast<eMdpFlags>(setBit(f, v));
+}
+
+inline void clearMdpFlags(eMdpFlags& f, eMdpFlags v) {
+    f = static_cast<eMdpFlags>(clrBit(f, v));
+}
+
+enum { FB0, FB1, FB2 };
+
+struct ScreenInfo {
+    ScreenInfo() : mFBWidth(0),
+    mFBHeight(0),
+    mFBbpp(0),
+    mFBystride(0) {}
+    void dump(const char* const s) const;
+    uint32_t mFBWidth;
+    uint32_t mFBHeight;
+    uint32_t mFBbpp;
+    uint32_t mFBystride;
+};
+
+int getMdpFormat(int format);
+int getHALFormat(int mdpFormat);
+int getDownscaleFactor(const int& src_w, const int& src_h,
+        const int& dst_w, const int& dst_h);
+void getDecimationFactor(const int& src_w, const int& src_h,
+        const int& dst_w, const int& dst_h, uint8_t& horzDeci,
+        uint8_t& vertDeci);
+
+/* flip is upside down and such. V, H flip
+ * rotation is 90, 180 etc
+ * It returns MDP related enum/define that match rot+flip*/
+int getMdpOrient(eTransform rotation);
+const char* getFormatString(int format);
+
+template <class T>
+inline void memset0(T& t) { ::memset(&t, 0, sizeof(T)); }
+
+template <class T> inline void swap ( T& a, T& b )
+{
+    T c(a); a=b; b=c;
+}
+
+inline int alignup(int value, int a) {
+    //if align = 0, return the value. Else, do alignment.
+    return a ? ((((value - 1) / a) + 1) * a) : value;
+}
+
+inline int aligndown(int value, int a) {
+    //if align = 0, return the value. Else, do alignment.
+    return a ? ((value) & ~(a-1)) : value;
+}
+
+// FIXME that align should replace the upper one.
+inline int align(int value, int a) {
+    //if align = 0, return the value. Else, do alignment.
+    return a ? ((value + (a-1)) & ~(a-1)) : value;
+}
+
+enum eRotOutFmt {
+    ROT_OUT_FMT_DEFAULT,
+    ROT_OUT_FMT_Y_CRCB_H2V2
+};
+
+template <int ROT_OUT_FMT> struct RotOutFmt;
+
+// FIXME, taken from gralloc_priv.h. Need to
+// put it back as soon as overlay takes place of the old one
+/* possible formats for 3D content*/
+enum {
+    HAL_NO_3D                         = 0x0000,
+    HAL_3D_IN_SIDE_BY_SIDE_L_R        = 0x10000,
+    HAL_3D_IN_TOP_BOTTOM              = 0x20000,
+    HAL_3D_IN_INTERLEAVE              = 0x40000,
+    HAL_3D_IN_SIDE_BY_SIDE_R_L        = 0x80000,
+    HAL_3D_OUT_SIDE_BY_SIDE           = 0x1000,
+    HAL_3D_OUT_TOP_BOTTOM             = 0x2000,
+    HAL_3D_OUT_INTERLEAVE             = 0x4000,
+    HAL_3D_OUT_MONOSCOPIC             = 0x8000
+};
+
+enum { HAL_3D_OUT_SBS_MASK =
+    HAL_3D_OUT_SIDE_BY_SIDE >> overlay::utils::SHIFT_OUT_3D,
+    HAL_3D_OUT_TOP_BOT_MASK =
+            HAL_3D_OUT_TOP_BOTTOM >> overlay::utils::SHIFT_OUT_3D,
+    HAL_3D_OUT_INTERL_MASK =
+            HAL_3D_OUT_INTERLEAVE >> overlay::utils::SHIFT_OUT_3D,
+    HAL_3D_OUT_MONOS_MASK =
+            HAL_3D_OUT_MONOSCOPIC >> overlay::utils::SHIFT_OUT_3D
+};
+
+
+inline bool isYuv(uint32_t format) {
+    switch(format){
+        case MDP_Y_CBCR_H2V1:
+        case MDP_Y_CBCR_H2V2:
+        case MDP_Y_CRCB_H2V2:
+        case MDP_Y_CRCB_H1V1:
+        case MDP_Y_CRCB_H2V1:
+        case MDP_Y_CRCB_H2V2_TILE:
+        case MDP_Y_CBCR_H2V2_TILE:
+        case MDP_Y_CR_CB_H2V2:
+        case MDP_Y_CR_CB_GH2V2:
+        case MDP_Y_CBCR_H2V2_VENUS:
+            return true;
+        default:
+            return false;
+    }
+    return false;
+}
+
+inline bool isRgb(uint32_t format) {
+    switch(format) {
+        case MDP_RGBA_8888:
+        case MDP_BGRA_8888:
+        case MDP_RGBX_8888:
+        case MDP_RGB_565:
+            return true;
+        default:
+            return false;
+    }
+    return false;
+}
+
+inline const char* getFormatString(int format){
+    #define STR(f) #f;
+    static const char* formats[MDP_IMGTYPE_LIMIT + 1] = {0};
+    formats[MDP_RGB_565] = STR(MDP_RGB_565);
+    formats[MDP_XRGB_8888] = STR(MDP_XRGB_8888);
+    formats[MDP_Y_CBCR_H2V2] = STR(MDP_Y_CBCR_H2V2);
+    formats[MDP_Y_CBCR_H2V2_ADRENO] = STR(MDP_Y_CBCR_H2V2_ADRENO);
+    formats[MDP_ARGB_8888] = STR(MDP_ARGB_8888);
+    formats[MDP_RGB_888] = STR(MDP_RGB_888);
+    formats[MDP_Y_CRCB_H2V2] = STR(MDP_Y_CRCB_H2V2);
+    formats[MDP_YCRYCB_H2V1] = STR(MDP_YCRYCB_H2V1);
+    formats[MDP_CBYCRY_H2V1] = STR(MDP_CBYCRY_H2V1);
+    formats[MDP_Y_CRCB_H2V1] = STR(MDP_Y_CRCB_H2V1);
+    formats[MDP_Y_CBCR_H2V1] = STR(MDP_Y_CBCR_H2V1);
+    formats[MDP_Y_CRCB_H1V2] = STR(MDP_Y_CRCB_H1V2);
+    formats[MDP_Y_CBCR_H1V2] = STR(MDP_Y_CBCR_H1V2);
+    formats[MDP_RGBA_8888] = STR(MDP_RGBA_8888);
+    formats[MDP_BGRA_8888] = STR(MDP_BGRA_8888);
+    formats[MDP_RGBX_8888] = STR(MDP_RGBX_8888);
+    formats[MDP_Y_CRCB_H2V2_TILE] = STR(MDP_Y_CRCB_H2V2_TILE);
+    formats[MDP_Y_CBCR_H2V2_TILE] = STR(MDP_Y_CBCR_H2V2_TILE);
+    formats[MDP_Y_CR_CB_H2V2] = STR(MDP_Y_CR_CB_H2V2);
+    formats[MDP_Y_CR_CB_GH2V2] = STR(MDP_Y_CR_CB_GH2V2);
+    formats[MDP_Y_CB_CR_H2V2] = STR(MDP_Y_CB_CR_H2V2);
+    formats[MDP_Y_CRCB_H1V1] = STR(MDP_Y_CRCB_H1V1);
+    formats[MDP_Y_CBCR_H1V1] = STR(MDP_Y_CBCR_H1V1);
+    formats[MDP_YCRCB_H1V1] = STR(MDP_YCRCB_H1V1);
+    formats[MDP_YCBCR_H1V1] = STR(MDP_YCBCR_H1V1);
+    formats[MDP_BGR_565] = STR(MDP_BGR_565);
+    formats[MDP_BGR_888] = STR(MDP_BGR_888);
+    formats[MDP_Y_CBCR_H2V2_VENUS] = STR(MDP_Y_CBCR_H2V2_VENUS);
+    formats[MDP_BGRX_8888] = STR(MDP_BGRX_8888);
+    formats[MDP_IMGTYPE_LIMIT] = STR(MDP_IMGTYPE_LIMIT);
+
+    if(format < 0 || format >= MDP_IMGTYPE_LIMIT) {
+        ALOGE("%s wrong fmt %d", __FUNCTION__, format);
+        return "Unsupported format";
+    }
+    if(formats[format] == 0) {
+        ALOGE("%s: table missing format %d from header", __FUNCTION__, format);
+        return "";
+    }
+    return formats[format];
+}
+
+inline void Whf::dump() const {
+    ALOGE("== Dump WHF w=%d h=%d f=%d s=%d start/end ==",
+            w, h, format, size);
+}
+
+inline void Dim::dump() const {
+    ALOGE("== Dump Dim x=%d y=%d w=%d h=%d start/end ==", x, y, w, h);
+}
+
+// FB0
+template <int CHAN>
+inline Dim getPositionS3DImpl(const Whf& whf)
+{
+    switch (whf.format & OUTPUT_3D_MASK)
+    {
+        case HAL_3D_OUT_SBS_MASK:
+            // x, y, w, h
+            return Dim(0, 0, whf.w/2, whf.h);
+        case HAL_3D_OUT_TOP_BOT_MASK:
+            return Dim(0, 0, whf.w, whf.h/2);
+        case HAL_3D_OUT_MONOS_MASK:
+            return Dim();
+        case HAL_3D_OUT_INTERL_MASK:
+            // FIXME error?
+            ALOGE("%s HAL_3D_OUT_INTERLEAVE_MASK", __FUNCTION__);
+            return Dim();
+        default:
+            ALOGE("%s Unsupported 3D output format %d", __FUNCTION__,
+                    whf.format);
+    }
+    return Dim();
+}
+
+template <>
+inline Dim getPositionS3DImpl<utils::OV_RIGHT_SPLIT>(const Whf& whf)
+{
+    switch (whf.format & OUTPUT_3D_MASK)
+    {
+        case HAL_3D_OUT_SBS_MASK:
+            return Dim(whf.w/2, 0, whf.w/2, whf.h);
+        case HAL_3D_OUT_TOP_BOT_MASK:
+            return Dim(0, whf.h/2, whf.w, whf.h/2);
+        case HAL_3D_OUT_MONOS_MASK:
+            return Dim(0, 0, whf.w, whf.h);
+        case HAL_3D_OUT_INTERL_MASK:
+            // FIXME error?
+            ALOGE("%s HAL_3D_OUT_INTERLEAVE_MASK", __FUNCTION__);
+            return Dim();
+        default:
+            ALOGE("%s Unsupported 3D output format %d", __FUNCTION__,
+                    whf.format);
+    }
+    return Dim();
+}
+
+template <int CHAN>
+inline bool getPositionS3D(const Whf& whf, Dim& out) {
+    out = getPositionS3DImpl<CHAN>(whf);
+    return (out != Dim());
+}
+
+template <int CHAN>
+inline Dim getCropS3DImpl(const Dim& in, uint32_t fmt) {
+    switch (fmt & INPUT_3D_MASK)
+    {
+        case HAL_3D_IN_SIDE_BY_SIDE_L_R:
+            return Dim(0, 0, in.w/2, in.h);
+        case HAL_3D_IN_SIDE_BY_SIDE_R_L:
+            return Dim(in.w/2, 0, in.w/2, in.h);
+        case HAL_3D_IN_TOP_BOTTOM:
+            return Dim(0, 0, in.w, in.h/2);
+        case HAL_3D_IN_INTERLEAVE:
+            ALOGE("%s HAL_3D_IN_INTERLEAVE", __FUNCTION__);
+            break;
+        default:
+            ALOGE("%s Unsupported 3D format %d", __FUNCTION__, fmt);
+            break;
+    }
+    return Dim();
+}
+
+template <>
+inline Dim getCropS3DImpl<utils::OV_RIGHT_SPLIT>(const Dim& in, uint32_t fmt) {
+    switch (fmt & INPUT_3D_MASK)
+    {
+        case HAL_3D_IN_SIDE_BY_SIDE_L_R:
+            return Dim(in.w/2, 0, in.w/2, in.h);
+        case HAL_3D_IN_SIDE_BY_SIDE_R_L:
+            return Dim(0, 0, in.w/2, in.h);
+        case HAL_3D_IN_TOP_BOTTOM:
+            return Dim(0, in.h/2, in.w, in.h/2);
+        case HAL_3D_IN_INTERLEAVE:
+            ALOGE("%s HAL_3D_IN_INTERLEAVE", __FUNCTION__);
+            break;
+        default:
+            ALOGE("%s Unsupported 3D format %d", __FUNCTION__, fmt);
+            break;
+    }
+    return Dim();
+}
+
+template <int CHAN>
+inline bool getCropS3D(const Dim& in, Dim& out, uint32_t fmt)
+{
+    out = getCropS3DImpl<CHAN>(in, fmt);
+    return (out != Dim());
+}
+
+template <class Type>
+void swapWidthHeight(Type& width, Type& height) {
+    Type tmp = width;
+    width = height;
+    height = tmp;
+}
+
+inline void ScreenInfo::dump(const char* const s) const {
+    ALOGE("== Dump %s ScreenInfo w=%d h=%d"
+            " bpp=%d stride=%d start/end ==",
+            s, mFBWidth, mFBHeight, mFBbpp, mFBystride);
+}
+
+inline bool openDev(OvFD& fd, int fbnum,
+    const char* const devpath, int flags) {
+    return overlay::open(fd, fbnum, devpath, flags);
+}
+
+template <class T>
+inline void even_ceil(T& value) {
+    if(value & 1)
+        value++;
+}
+
+template <class T>
+inline void even_floor(T& value) {
+    if(value & 1)
+        value--;
+}
+
+void preRotateSource(const eTransform& tr, Whf& whf, Dim& srcCrop);
+void getDump(char *buf, size_t len, const char *prefix, const mdp_overlay& ov);
+void getDump(char *buf, size_t len, const char *prefix, const msmfb_img& ov);
+void getDump(char *buf, size_t len, const char *prefix, const mdp_rect& ov);
+void getDump(char *buf, size_t len, const char *prefix,
+        const msmfb_overlay_data& ov);
+void getDump(char *buf, size_t len, const char *prefix, const msmfb_data& ov);
+void getDump(char *buf, size_t len, const char *prefix,
+        const msm_rotator_img_info& ov);
+void getDump(char *buf, size_t len, const char *prefix,
+        const msm_rotator_data_info& ov);
+
+} // namespace utils ends
+
+//--------------------Class Res stuff (namespace overlay only) -----------
+
+class Res {
+public:
+    // /dev/graphics/fb%u
+    static const char* const fbPath;
+    // /dev/msm_rotator
+    static const char* const rotPath;
+    // /sys/class/graphics/fb1/format_3d
+    static const char* const format3DFile;
+    // /sys/class/graphics/fb1/3d_present
+    static const char* const edid3dInfoFile;
+    // /sys/devices/platform/mipi_novatek.0/enable_3d_barrier
+    static const char* const barrierFile;
+};
+
+
+//--------------------Class OvFD stuff (namespace overlay only) -----------
+
+/*
+* Holds one FD
+* Dtor will NOT close the underlying FD.
+* That enables us to copy that object around
+* */
+class OvFD {
+public:
+    /* Ctor */
+    explicit OvFD();
+
+    /* dtor will NOT close the underlying FD */
+    ~OvFD();
+
+    /* Open fd using the path given by dev.
+     * return false in failure */
+    bool open(const char* const dev,
+            int flags = O_RDWR);
+
+    /* populate path */
+    void setPath(const char* const dev);
+
+    /* Close fd if we have a valid fd. */
+    bool close();
+
+    /* returns underlying fd.*/
+    int getFD() const;
+
+    /* returns true if fd is valid */
+    bool valid() const;
+
+    /* like operator= */
+    void copy(int fd);
+
+    /* dump the state of the instance */
+    void dump() const;
+private:
+    /* helper enum for determine valid/invalid fd */
+    enum { INVAL = -1 };
+
+    /* actual os fd */
+    int mFD;
+
+    /* path, for debugging */
+    char mPath[utils::MAX_PATH_LEN];
+};
+
+//-------------------Inlines--------------------------
+
+inline bool open(OvFD& fd, uint32_t fbnum, const char* const dev, int flags)
+{
+    char dev_name[64] = {0};
+    snprintf(dev_name, sizeof(dev_name), dev, fbnum);
+    return fd.open(dev_name, flags);
+}
+
+inline OvFD::OvFD() : mFD (INVAL) {
+    mPath[0] = 0;
+}
+
+inline OvFD::~OvFD() {
+    //no op since copy() can be used to share fd, in 3d cases.
+}
+
+inline bool OvFD::open(const char* const dev, int flags)
+{
+    mFD = ::open(dev, flags, 0);
+    if (mFD < 0) {
+        // FIXME errno, strerror in bionic?
+        ALOGE("Cant open device %s err=%d", dev, errno);
+        return false;
+    }
+    setPath(dev);
+    return true;
+}
+
+inline void OvFD::setPath(const char* const dev)
+{
+    ::strncpy(mPath, dev, utils::MAX_PATH_LEN);
+}
+
+inline bool OvFD::close()
+{
+    int ret = 0;
+    if(valid()) {
+        ret = ::close(mFD);
+        mFD = INVAL;
+    }
+    return (ret == 0);
+}
+
+inline bool OvFD::valid() const
+{
+    return (mFD != INVAL);
+}
+
+inline int OvFD::getFD() const { return mFD; }
+
+inline void OvFD::copy(int fd) {
+    mFD = fd;
+}
+
+inline void OvFD::dump() const
+{
+    ALOGE("== Dump OvFD fd=%d path=%s start/end ==",
+            mFD, mPath);
+}
+
+//--------------- class OvFD stuff ends ---------------------
+
+} // overlay
+
+
+#endif // OVERLAY_UTILS_H
diff --git a/msm8974/liboverlay/overlayWriteback.cpp b/msm8974/liboverlay/overlayWriteback.cpp
new file mode 100644
index 0000000..d1d3223
--- /dev/null
+++ b/msm8974/liboverlay/overlayWriteback.cpp
@@ -0,0 +1,255 @@
+/*
+* Copyright (c) 2013 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation. nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "overlay.h"
+#include "overlayWriteback.h"
+#include "mdpWrapper.h"
+
+namespace overlay {
+
+//=========== class WritebackMem ==============================================
+bool WritebackMem::manageMem(uint32_t size, bool isSecure) {
+    if(mBuf.bufSz() == size) {
+        return true;
+    }
+    if(mBuf.valid()) {
+        if(!mBuf.close()) {
+            ALOGE("%s error closing mem", __func__);
+            return false;
+        }
+    }
+    return alloc(size, isSecure);
+}
+
+bool WritebackMem::alloc(uint32_t size, bool isSecure) {
+    if(!mBuf.open(NUM_BUFS, size, isSecure)){
+        ALOGE("%s: Failed to open", __func__);
+        mBuf.close();
+        return false;
+    }
+
+    OVASSERT(MAP_FAILED != mBuf.addr(), "MAP failed");
+    OVASSERT(mBuf.getFD() != -1, "getFd is -1");
+
+    mCurrOffsetIndex = 0;
+    for (uint32_t i = 0; i < NUM_BUFS; i++) {
+        mOffsets[i] = i * size;
+    }
+    return true;
+}
+
+bool WritebackMem::dealloc() {
+    bool ret = true;
+    if(mBuf.valid()) {
+        ret = mBuf.close();
+    }
+    return ret;
+}
+
+//=========== class Writeback =================================================
+Writeback::Writeback() : mXres(0), mYres(0), mOpFmt(-1) {
+    int fbNum = Overlay::getFbForDpy(Overlay::DPY_WRITEBACK);
+    if(!utils::openDev(mFd, fbNum, Res::fbPath, O_RDWR)) {
+        ALOGE("%s failed to init %s", __func__, Res::fbPath);
+        return;
+    }
+    startSession();
+}
+
+Writeback::~Writeback() {
+    stopSession();
+    if (!mFd.close()) {
+        ALOGE("%s error closing fd", __func__);
+    }
+}
+
+bool Writeback::startSession() {
+    if(!mdp_wrapper::wbInitStart(mFd.getFD())) {
+        ALOGE("%s failed", __func__);
+        return false;
+    }
+    return true;
+}
+
+bool Writeback::stopSession() {
+    if(mFd.valid()) {
+        if(!mdp_wrapper::wbStopTerminate(mFd.getFD())) {
+            ALOGE("%s failed", __func__);
+            return false;
+        }
+    } else {
+        ALOGE("%s Invalid fd", __func__);
+        return false;
+    }
+    return true;
+}
+
+bool Writeback::configureDpyInfo(int xres, int yres) {
+    if(mXres != xres || mYres != yres) {
+        fb_var_screeninfo vinfo;
+        memset(&vinfo, 0, sizeof(fb_var_screeninfo));
+        if(!mdp_wrapper::getVScreenInfo(mFd.getFD(), vinfo)) {
+            ALOGE("%s failed", __func__);
+            return false;
+        }
+        vinfo.xres = xres;
+        vinfo.yres = yres;
+        vinfo.xres_virtual = xres;
+        vinfo.yres_virtual = yres;
+        vinfo.xoffset = 0;
+        vinfo.yoffset = 0;
+        if(!mdp_wrapper::setVScreenInfo(mFd.getFD(), vinfo)) {
+            ALOGE("%s failed", __func__);
+            return false;
+        }
+        mXres = xres;
+        mYres = yres;
+    }
+    return true;
+}
+
+bool Writeback::configureMemory(uint32_t size, bool isSecure) {
+    if(!mWbMem.manageMem(size, isSecure)) {
+        ALOGE("%s failed, memory failure", __func__);
+        return false;
+    }
+    return true;
+}
+
+bool Writeback::queueBuffer(int opFd, uint32_t opOffset) {
+    memset(&mFbData, 0, sizeof(struct msmfb_data));
+    //Queue
+    mFbData.offset = opOffset;
+    mFbData.memory_id = opFd;
+    mFbData.id = 0;
+    mFbData.flags = 0;
+    if(!mdp_wrapper::wbQueueBuffer(mFd.getFD(), mFbData)) {
+        ALOGE("%s: queuebuffer failed", __func__);
+        return false;
+    }
+    return true;
+}
+
+bool Writeback::dequeueBuffer() {
+    //Dequeue
+    mFbData.flags = MSMFB_WRITEBACK_DEQUEUE_BLOCKING;
+    if(!mdp_wrapper::wbDequeueBuffer(mFd.getFD(), mFbData)) {
+        ALOGE("%s: dequeuebuffer failed", __func__);
+        return false;
+    }
+    return true;
+}
+
+bool Writeback::writeSync(int opFd, uint32_t opOffset) {
+    if(!queueBuffer(opFd, opOffset)) {
+        return false;
+    }
+    if(!Overlay::displayCommit(mFd.getFD())) {
+        return false;
+    }
+    if(!dequeueBuffer()) {
+        return false;
+    }
+    return true;
+}
+
+bool Writeback::writeSync() {
+    mWbMem.useNextBuffer();
+    return writeSync(mWbMem.getDstFd(), mWbMem.getOffset());
+}
+
+bool Writeback::setOutputFormat(int mdpFormat) {
+    if(mdpFormat != mOpFmt) {
+        struct msmfb_metadata metadata;
+        memset(&metadata, 0 , sizeof(metadata));
+        metadata.op = metadata_op_wb_format;
+        metadata.data.mixer_cfg.writeback_format = mdpFormat;
+        if (ioctl(mFd.getFD(), MSMFB_METADATA_SET, &metadata) < 0) {
+            ALOGE("Error setting MDP Writeback format");
+            return false;
+        }
+        mOpFmt = mdpFormat;
+    }
+    return true;
+}
+
+int Writeback::getOutputFormat() {
+    if(mOpFmt < 0) {
+        struct msmfb_metadata metadata;
+        memset(&metadata, 0 , sizeof(metadata));
+        metadata.op = metadata_op_wb_format;
+        if (ioctl(mFd.getFD(), MSMFB_METADATA_GET, &metadata) < 0) {
+            ALOGE("Error retrieving MDP Writeback format");
+            return -1;
+        }
+        mOpFmt =  metadata.data.mixer_cfg.writeback_format;
+    }
+    return mOpFmt;
+}
+
+//static
+
+Writeback *Writeback::getInstance() {
+    if(sWb == NULL) {
+        sWb = new Writeback();
+    }
+    sUsed = true;
+    return sWb;
+}
+
+void Writeback::configDone() {
+    if(sUsed == false && sWb) {
+        delete sWb;
+        sWb = NULL;
+    }
+}
+
+void Writeback::clear() {
+    sUsed = false;
+    if(sWb) {
+        delete sWb;
+        sWb = NULL;
+    }
+}
+
+bool Writeback::getDump(char *buf, size_t len) {
+    if(sWb) {
+        utils::getDump(buf, len, "WBData", sWb->mFbData);
+        char str[4] = {'\0'};
+        snprintf(str, 4, "\n");
+        strncat(buf, str, strlen(str));
+        return true;
+    }
+    return false;
+}
+
+Writeback *Writeback::sWb = 0;
+bool Writeback::sUsed = false;
+
+} //namespace overlay
diff --git a/msm8974/liboverlay/overlayWriteback.h b/msm8974/liboverlay/overlayWriteback.h
new file mode 100644
index 0000000..9785b64
--- /dev/null
+++ b/msm8974/liboverlay/overlayWriteback.h
@@ -0,0 +1,118 @@
+/*
+* Copyright (c) 2013 The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation. nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef OVERLAY_WRITEBACK_H
+#define OVERLAY_WRITEBACK_H
+
+#include "overlayMem.h"
+
+namespace overlay {
+
+class WritebackMgr;
+
+class WritebackMem {
+public:
+    explicit WritebackMem() : mCurrOffsetIndex(0) {
+        memset(&mOffsets, 0, sizeof(mOffsets));
+    }
+    ~WritebackMem() { dealloc(); }
+    bool manageMem(uint32_t size, bool isSecure);
+    void useNextBuffer() {
+            mCurrOffsetIndex = (mCurrOffsetIndex + 1) % NUM_BUFS;
+    }
+    uint32_t getOffset() const { return mOffsets[mCurrOffsetIndex]; }
+    int getDstFd() const { return mBuf.getFD(); }
+private:
+    bool alloc(uint32_t size, bool isSecure);
+    bool dealloc();
+    enum { NUM_BUFS = 2 };
+    OvMem mBuf;
+    uint32_t mOffsets[NUM_BUFS];
+    uint32_t mCurrOffsetIndex;
+};
+
+//Abstracts the WB2 interface of MDP
+//Has modes to either manage memory or work with memory allocated elsewhere
+class Writeback {
+public:
+    ~Writeback();
+    bool configureDpyInfo(int xres, int yres);
+    bool configureMemory(uint32_t size, bool isSecure);
+    /* Blocking write. (queue, commit, dequeue)
+     * This class will do writeback memory management.
+     * This class will call display-commit on writeback mixer.
+     */
+    bool writeSync();
+    /* Blocking write. (queue, commit, dequeue)
+     * Client must do writeback memory management.
+     * Client must not call display-commit on writeback mixer.
+     */
+    bool writeSync(int opFd, uint32_t opOffset);
+    /* Async queue. (Does not write)
+     * Client must do writeback memory management.
+     * Client must call display-commit on their own.
+     * Client must use sync mechanism e.g sync pt.
+     */
+    bool queueBuffer(int opFd, uint32_t opOffset);
+    uint32_t getOffset() const { return mWbMem.getOffset(); }
+    int getDstFd() const { return mWbMem.getDstFd(); }
+    /* Subject to GC if writeback isnt used for a drawing round.
+     * Get always if caching the value.
+     */
+    int getFbFd() const { return mFd.getFD(); }
+    int getOutputFormat();
+    bool setOutputFormat(int mdpFormat);
+
+    static Writeback* getInstance();
+    static void configBegin() { sUsed = false; }
+    static void configDone();
+    static void clear();
+    //Will take a dump of data structure only if there is an instance existing
+    //Returns true if dump is added to the input buffer, false otherwise
+    static bool getDump(char *buf, size_t len);
+
+private:
+    explicit Writeback();
+    bool startSession();
+    bool stopSession();
+    //Actually block_until_write_done for the usage here.
+    bool dequeueBuffer();
+    OvFD mFd;
+    WritebackMem mWbMem;
+    struct msmfb_data mFbData;
+    int mXres;
+    int mYres;
+    int mOpFmt;
+
+    static bool sUsed;
+    static Writeback *sWb;
+};
+
+}
+
+#endif
diff --git a/msm8974/liboverlay/pipes/overlay3DPipe.h b/msm8974/liboverlay/pipes/overlay3DPipe.h
new file mode 100644
index 0000000..4e5630e
--- /dev/null
+++ b/msm8974/liboverlay/pipes/overlay3DPipe.h
@@ -0,0 +1,465 @@
+/*
+* Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef OVERLAY_M3D_EXT_PIPE_H
+#define OVERLAY_M3D_EXT_PIPE_H
+
+#include "overlayGenPipe.h"
+#include "overlayUtils.h"
+
+namespace overlay {
+
+/////////////  M3DExt Pipe ////////////////////////////
+/**
+* A specific impl of GenericPipe for 3D.
+* Whenever needed to have a pass through - we do it.
+* If there is a special need for special/diff behavior
+* do it here
+* PANEL is always EXTERNAL for this pipe.
+* CHAN = 0,1 it's either Channel 1 or channel 2 needed for
+* 3D crop and position */
+template <int CHAN>
+class M3DExtPipe : utils::NoCopy {
+public:
+    /* Please look at overlayGenPipe.h for info */
+    explicit M3DExtPipe();
+    ~M3DExtPipe();
+    bool init(RotatorBase* rot);
+    bool close();
+    bool commit();
+    bool queueBuffer(int fd, uint32_t offset);
+    bool setCrop(const utils::Dim& d);
+    bool setPosition(const utils::Dim& dim);
+    bool setTransform(const utils::eTransform& param);
+    bool setSource(const utils::PipeArgs& args);
+    void dump() const;
+private:
+    overlay::GenericPipe<utils::EXTERNAL> mM3d;
+    // Cache the M3D format
+    uint32_t mM3Dfmt;
+};
+
+/////////////  M3DPrimary Pipe ////////////////////////////
+/**
+* A specific impl of GenericPipe for 3D.
+* Whenever needed to have a pass through - we do it.
+* If there is a special need for special/diff behavior
+* do it here
+* PANEL is always PRIMARY for this pipe.
+* CHAN = 0,1 it's either Channel 1 or channel 2 needed for
+* 3D crop and position */
+template <int CHAN>
+class M3DPrimaryPipe : utils::NoCopy {
+public:
+    /* Please look at overlayGenPipe.h for info */
+    explicit M3DPrimaryPipe();
+    ~M3DPrimaryPipe();
+    bool init(RotatorBase* rot);
+    bool close();
+    bool commit();
+    bool queueBuffer(int fd, uint32_t offset);
+    bool setCrop(const utils::Dim& d);
+    bool setPosition(const utils::Dim& dim);
+    bool setTransform(const utils::eTransform& param);
+    bool setSource(const utils::PipeArgs& args);
+    void dump() const;
+private:
+    overlay::GenericPipe<utils::PRIMARY> mM3d;
+    // Cache the M3D format
+    uint32_t mM3Dfmt;
+};
+
+/////////////  S3DExt Pipe ////////////////////////////////
+/**
+* A specific impl of GenericPipe for 3D.
+* Whenever needed to have a pass through - we do it.
+* If there is a special need for special/diff behavior
+* do it here.
+* PANEL is always EXTERNAL for this pipe.
+* CHAN = 0,1 it's either Channel 1 or channel 2 needed for
+* 3D crop and position */
+template <int CHAN>
+class S3DExtPipe : utils::NoCopy {
+public:
+    /* Please look at overlayGenPipe.h for info */
+    explicit S3DExtPipe();
+    ~S3DExtPipe();
+    bool init(RotatorBase* rot);
+    bool close();
+    bool commit();
+    bool queueBuffer(int fd, uint32_t offset);
+    bool setCrop(const utils::Dim& d);
+    bool setPosition(const utils::Dim& dim);
+    bool setTransform(const utils::eTransform& param);
+    bool setSource(const utils::PipeArgs& args);
+    void dump() const;
+private:
+    overlay::GenericPipe<utils::EXTERNAL> mS3d;
+    // Cache the 3D format
+    uint32_t mS3Dfmt;
+};
+
+/////////////  S3DPrimary Pipe ////////////////////////////
+/**
+* A specific impl of GenericPipe for 3D.
+* Whenever needed to have a pass through - we do it.
+* If there is a special need for special/diff behavior
+* do it here
+* PANEL is always PRIMARY for this pipe.
+* CHAN = 0,1 it's either Channel 1 or channel 2 needed for
+* 3D crop and position */
+template <int CHAN>
+class S3DPrimaryPipe : utils::NoCopy {
+public:
+    /* Please look at overlayGenPipe.h for info */
+    explicit S3DPrimaryPipe();
+    ~S3DPrimaryPipe();
+    bool init(RotatorBase* rot);
+    bool close();
+    bool commit();
+    bool queueBuffer(int fd, uint32_t offset);
+    bool setCrop(const utils::Dim& d);
+    bool setPosition(const utils::Dim& dim);
+    bool setTransform(const utils::eTransform& param);
+    bool setSource(const utils::PipeArgs& args);
+    void dump() const;
+private:
+    /* needed for 3D related IOCTL */
+    MdpCtrl3D mCtrl3D;
+    overlay::GenericPipe<utils::PRIMARY> mS3d;
+    // Cache the 3D format
+    uint32_t mS3Dfmt;
+};
+
+
+
+
+//------------------------Inlines and Templates--------------------------
+
+
+/////////////  M3DExt Pipe ////////////////////////////
+template <int CHAN>
+inline M3DExtPipe<CHAN>::M3DExtPipe() : mM3Dfmt(0) {}
+template <int CHAN>
+inline M3DExtPipe<CHAN>::~M3DExtPipe() { close(); }
+template <int CHAN>
+inline bool M3DExtPipe<CHAN>::init(RotatorBase* rot) {
+    ALOGE_IF(DEBUG_OVERLAY, "M3DExtPipe init");
+    if(!mM3d.init(rot)) {
+        ALOGE("3Dpipe failed to init");
+        return false;
+    }
+    return true;
+}
+template <int CHAN>
+inline bool M3DExtPipe<CHAN>::close() {
+    return mM3d.close();
+}
+template <int CHAN>
+inline bool M3DExtPipe<CHAN>::commit() { return mM3d.commit(); }
+template <int CHAN>
+inline bool M3DExtPipe<CHAN>::queueBuffer(int fd, uint32_t offset) {
+    return mM3d.queueBuffer(fd, offset);
+}
+template <int CHAN>
+inline bool M3DExtPipe<CHAN>::setCrop(const utils::Dim& d) {
+    utils::Dim _dim;
+    if(!utils::getCropS3D<CHAN>(d, _dim, mM3Dfmt)){
+        ALOGE("M3DExtPipe setCrop failed to getCropS3D");
+        _dim = d;
+    }
+    return mM3d.setCrop(_dim);
+}
+
+template <int CHAN>
+inline bool M3DExtPipe<CHAN>::setPosition(const utils::Dim& d) {
+    utils::Dim _dim;
+    // original setPositionHandleState has getPositionS3D(...,true)
+    // which means format is HAL_3D_OUT_SBS_MASK
+    // HAL_3D_OUT_SBS_MASK is 0x1000 >> 12 == 0x1 as the orig
+    // code suggets
+    utils::Whf _whf(mM3d.getScreenInfo().mFBWidth,
+            mM3d.getScreenInfo().mFBHeight,
+            mM3Dfmt);
+    if(!utils::getPositionS3D<CHAN>(_whf, _dim)) {
+        ALOGE("S3DPrimaryPipe setPosition err in getPositionS3D");
+        _dim = d;
+    }
+    return mM3d.setPosition(_dim);
+}
+template <int CHAN>
+inline bool M3DExtPipe<CHAN>::setTransform(const utils::eTransform& param) {
+    return mM3d.setTransform(param);
+}
+template <int CHAN>
+inline bool M3DExtPipe<CHAN>::setSource(const utils::PipeArgs& args)
+{
+    // extract 3D fmt
+    mM3Dfmt = utils::format3DInput(utils::getS3DFormat(args.whf.format)) |
+            utils::HAL_3D_OUT_MONOS_MASK;
+    return mM3d.setSource(args);
+}
+template <int CHAN>
+inline void M3DExtPipe<CHAN>::dump() const {
+    ALOGE("M3DExtPipe Pipe fmt=%d", mM3Dfmt);
+    mM3d.dump();
+}
+
+
+/////////////  M3DPrimary Pipe ////////////////////////////
+template <int CHAN>
+inline M3DPrimaryPipe<CHAN>::M3DPrimaryPipe() : mM3Dfmt(0) {}
+template <int CHAN>
+inline M3DPrimaryPipe<CHAN>::~M3DPrimaryPipe() { close(); }
+template <int CHAN>
+inline bool M3DPrimaryPipe<CHAN>::init(RotatorBase* rot) {
+    ALOGE_IF(DEBUG_OVERLAY, "M3DPrimaryPipe init");
+    if(!mM3d.init(rot)) {
+        ALOGE("3Dpipe failed to init");
+        return false;
+    }
+    return true;
+}
+template <int CHAN>
+inline bool M3DPrimaryPipe<CHAN>::close() {
+    return mM3d.close();
+}
+template <int CHAN>
+inline bool M3DPrimaryPipe<CHAN>::commit() { return mM3d.commit(); }
+template <int CHAN>
+inline bool M3DPrimaryPipe<CHAN>::queueBuffer(int fd, uint32_t offset) {
+    return mM3d.queueBuffer(fd, offset);
+}
+template <int CHAN>
+inline bool M3DPrimaryPipe<CHAN>::setCrop(const utils::Dim& d) {
+    utils::Dim _dim;
+    if(!utils::getCropS3D<CHAN>(d, _dim, mM3Dfmt)){
+        ALOGE("M3DPrimaryPipe setCrop failed to getCropS3D");
+        _dim = d;
+    }
+    return mM3d.setCrop(_dim);
+}
+template <int CHAN>
+inline bool M3DPrimaryPipe<CHAN>::setPosition(const utils::Dim& d) {
+    return mM3d.setPosition(d);
+}
+template <int CHAN>
+inline bool M3DPrimaryPipe<CHAN>::setTransform(const utils::eTransform& param) {
+    return mM3d.setTransform(param);
+}
+template <int CHAN>
+inline bool M3DPrimaryPipe<CHAN>::setSource(const utils::PipeArgs& args)
+{
+    // extract 3D fmt
+    mM3Dfmt = utils::format3DInput(utils::getS3DFormat(args.whf.format)) |
+            utils::HAL_3D_OUT_MONOS_MASK;
+    return mM3d.setSource(args);
+}
+template <int CHAN>
+inline void M3DPrimaryPipe<CHAN>::dump() const {
+    ALOGE("M3DPrimaryPipe Pipe fmt=%d", mM3Dfmt);
+    mM3d.dump();
+}
+
+/////////////  S3DExt Pipe ////////////////////////////////
+template <int CHAN>
+inline S3DExtPipe<CHAN>::S3DExtPipe() : mS3Dfmt(0) {}
+template <int CHAN>
+inline S3DExtPipe<CHAN>::~S3DExtPipe() { close(); }
+template <int CHAN>
+inline bool S3DExtPipe<CHAN>::init(RotatorBase* rot) {
+    ALOGE_IF(DEBUG_OVERLAY, "S3DExtPipe init");
+    if(!mS3d.init(rot)) {
+        ALOGE("3Dpipe failed to init");
+        return false;
+    }
+    return true;
+}
+template <int CHAN>
+inline bool S3DExtPipe<CHAN>::close() {
+    if(!utils::send3DInfoPacket(0)) {
+        ALOGE("S3DExtPipe close failed send3D info packet");
+    }
+    return mS3d.close();
+}
+template <int CHAN>
+inline bool S3DExtPipe<CHAN>::commit() { return mS3d.commit(); }
+template <int CHAN>
+inline bool S3DExtPipe<CHAN>::queueBuffer(int fd, uint32_t offset) {
+    return mS3d.queueBuffer(fd, offset);
+}
+template <int CHAN>
+inline bool S3DExtPipe<CHAN>::setCrop(const utils::Dim& d) {
+    utils::Dim _dim;
+    if(!utils::getCropS3D<CHAN>(d, _dim, mS3Dfmt)){
+        ALOGE("S3DExtPipe setCrop failed to getCropS3D");
+        _dim = d;
+    }
+    return mS3d.setCrop(_dim);
+}
+template <int CHAN>
+inline bool S3DExtPipe<CHAN>::setPosition(const utils::Dim& d)
+{
+    utils::Dim _dim;
+    utils::Whf _whf(mS3d.getScreenInfo().mFBWidth,
+            mS3d.getScreenInfo().mFBHeight,
+            mS3Dfmt);
+    if(!utils::getPositionS3D<CHAN>(_whf, _dim)) {
+        ALOGE("S3DExtPipe setPosition err in getPositionS3D");
+        _dim = d;
+    }
+    return mS3d.setPosition(_dim);
+}
+template <int CHAN>
+inline bool S3DExtPipe<CHAN>::setTransform(const utils::eTransform& param) {
+    return mS3d.setTransform(param);
+}
+template <int CHAN>
+inline bool S3DExtPipe<CHAN>::setSource(const utils::PipeArgs& args) {
+    mS3Dfmt = utils::getS3DFormat(args.whf.format);
+    return mS3d.setSource(args);
+}
+template <int CHAN>
+inline void S3DExtPipe<CHAN>::dump() const {
+    ALOGE("S3DExtPipe Pipe fmt=%d", mS3Dfmt);
+    mS3d.dump();
+}
+
+/////////////  S3DPrimary Pipe ////////////////////////////
+template <int CHAN>
+inline S3DPrimaryPipe<CHAN>::S3DPrimaryPipe() : mS3Dfmt(0) {}
+template <int CHAN>
+inline S3DPrimaryPipe<CHAN>::~S3DPrimaryPipe() { close(); }
+template <int CHAN>
+inline bool S3DPrimaryPipe<CHAN>::init(RotatorBase* rot) {
+    ALOGE_IF(DEBUG_OVERLAY, "S3DPrimaryPipe init");
+    if(!mS3d.init(rot)) {
+        ALOGE("3Dpipe failed to init");
+        return false;
+    }
+    // set the ctrl fd
+    mCtrl3D.setFd(mS3d.getCtrlFd());
+    return true;
+}
+template <int CHAN>
+inline bool S3DPrimaryPipe<CHAN>::close() {
+    if(!utils::enableBarrier(0)) {
+        ALOGE("S3DExtPipe close failed enable barrier");
+    }
+    mCtrl3D.close();
+    return mS3d.close();
+}
+
+template <int CHAN>
+inline bool S3DPrimaryPipe<CHAN>::commit() {
+    uint32_t fmt = mS3Dfmt & utils::OUTPUT_3D_MASK;
+    if(!utils::send3DInfoPacket(fmt)){
+        ALOGE("Error S3DExtPipe start error send3DInfoPacket %d", fmt);
+        return false;
+    }
+    return mS3d.commit();
+}
+template <int CHAN>
+inline bool S3DPrimaryPipe<CHAN>::queueBuffer(int fd, uint32_t offset) {
+    return mS3d.queueBuffer(fd, offset);
+}
+template <int CHAN>
+inline bool S3DPrimaryPipe<CHAN>::setCrop(const utils::Dim& d) {
+    utils::Dim _dim;
+    if(!utils::getCropS3D<CHAN>(d, _dim, mS3Dfmt)){
+        ALOGE("S3DPrimaryPipe setCrop failed to getCropS3D");
+        _dim = d;
+    }
+    return mS3d.setCrop(_dim);
+}
+template <int CHAN>
+inline bool S3DPrimaryPipe<CHAN>::setPosition(const utils::Dim& d)
+{
+    utils::Whf fbwhf(mS3d.getScreenInfo().mFBWidth,
+            mS3d.getScreenInfo().mFBHeight,
+            0 /* fmt dont care*/);
+    mCtrl3D.setWh(fbwhf);
+    if(!mCtrl3D.useVirtualFB()) {
+        ALOGE("Failed to use VFB on %d (non fatal)", utils::FB0);
+        return false;
+    }
+    utils::Dim _dim;
+    // original setPositionHandleState has getPositionS3D(...,true)
+    // which means format is HAL_3D_OUT_SBS_MASK
+    // HAL_3D_OUT_SBS_MASK is 0x1000 >> 12 == 0x1 as the orig
+    // code suggets
+    utils::Whf _whf(d.w, d.h, utils::HAL_3D_OUT_SBS_MASK);
+    if(!utils::getPositionS3D<CHAN>(_whf, _dim)) {
+        ALOGE("S3DPrimaryPipe setPosition err in getPositionS3D");
+        _dim = d;
+    }
+    return mS3d.setPosition(_dim);
+}
+
+/* for S3DPrimaryPipe, we need to have barriers once
+* So the easiest way to achieve it, is to make sure FB0 is having it before
+* setParam is running */
+template <>
+inline bool S3DPrimaryPipe<utils::OV_PIPE0>::setTransform(
+        const utils::eTransform& param) {
+    uint32_t barrier=0;
+    switch(param) {
+        case utils::OVERLAY_TRANSFORM_ROT_90:
+        case utils::OVERLAY_TRANSFORM_ROT_270:
+            barrier = utils::BARRIER_LAND;
+            break;
+        default:
+            barrier = utils::BARRIER_PORT;
+            break;
+    }
+    if(!utils::enableBarrier(barrier)) {
+        ALOGE("S3DPrimaryPipe setTransform failed to enable barrier");
+    }
+    return mS3d.setTransform(param);
+}
+
+template <int CHAN>
+inline bool S3DPrimaryPipe<CHAN>::setTransform(const utils::eTransform& param) {
+    return mS3d.setTransform(param);
+}
+template <int CHAN>
+inline bool S3DPrimaryPipe<CHAN>::setSource(const utils::PipeArgs& args)
+{
+    mS3Dfmt = utils::getS3DFormat(args.whf.format);
+    return mS3d.setSource(args);
+}
+template <int CHAN>
+inline void S3DPrimaryPipe<CHAN>::dump() const {
+    ALOGE("S3DPrimaryPipe Pipe fmt=%d", mS3Dfmt);
+    mS3d.dump();
+}
+
+} // overlay
+
+#endif // OVERLAY_M3D_EXT_PIPE_H
diff --git a/msm8974/liboverlay/pipes/overlayGenPipe.cpp b/msm8974/liboverlay/pipes/overlayGenPipe.cpp
new file mode 100644
index 0000000..d1e8dc9
--- /dev/null
+++ b/msm8974/liboverlay/pipes/overlayGenPipe.cpp
@@ -0,0 +1,179 @@
+/*
+* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "overlayGenPipe.h"
+#include "overlay.h"
+#include "mdp_version.h"
+
+namespace overlay {
+
+GenericPipe::GenericPipe(int dpy) : mDpy(dpy), mRotDownscaleOpt(false),
+    pipeState(CLOSED) {
+    init();
+}
+
+GenericPipe::~GenericPipe() {
+    close();
+}
+
+bool GenericPipe::init()
+{
+    ALOGE_IF(DEBUG_OVERLAY, "GenericPipe init");
+    mRotDownscaleOpt = false;
+
+    int fbNum = Overlay::getFbForDpy(mDpy);
+    if(fbNum < 0) {
+        ALOGE("%s: Invalid FB for the display: %d",__FUNCTION__, mDpy);
+        return false;
+    }
+
+    ALOGD_IF(DEBUG_OVERLAY,"%s: mFbNum:%d",__FUNCTION__, fbNum);
+
+    if(!mCtrlData.ctrl.init(fbNum)) {
+        ALOGE("GenericPipe failed to init ctrl");
+        return false;
+    }
+
+    if(!mCtrlData.data.init(fbNum)) {
+        ALOGE("GenericPipe failed to init data");
+        return false;
+    }
+
+    return true;
+}
+
+bool GenericPipe::close() {
+    bool ret = true;
+
+    if(!mCtrlData.ctrl.close()) {
+        ALOGE("GenericPipe failed to close ctrl");
+        ret = false;
+    }
+    if (!mCtrlData.data.close()) {
+        ALOGE("GenericPipe failed to close data");
+        ret = false;
+    }
+
+    setClosed();
+    return ret;
+}
+
+void GenericPipe::setSource(const utils::PipeArgs& args) {
+    mRotDownscaleOpt = args.rotFlags & utils::ROT_DOWNSCALE_ENABLED;
+    mCtrlData.ctrl.setSource(args);
+}
+
+void GenericPipe::setCrop(const overlay::utils::Dim& d) {
+    mCtrlData.ctrl.setCrop(d);
+}
+
+void GenericPipe::setTransform(const utils::eTransform& orient) {
+    mCtrlData.ctrl.setTransform(orient);
+}
+
+void GenericPipe::setPosition(const utils::Dim& d) {
+    mCtrlData.ctrl.setPosition(d);
+}
+
+bool GenericPipe::setVisualParams(const MetaData_t &metadata)
+{
+        return mCtrlData.ctrl.setVisualParams(metadata);
+}
+
+bool GenericPipe::commit() {
+    bool ret = false;
+    int downscale_factor = utils::ROT_DS_NONE;
+
+    if(mRotDownscaleOpt) {
+        ovutils::Dim src(mCtrlData.ctrl.getCrop());
+        ovutils::Dim dst(mCtrlData.ctrl.getPosition());
+        downscale_factor = ovutils::getDownscaleFactor(
+                src.w, src.h, dst.w, dst.h);
+    }
+
+    mCtrlData.ctrl.setDownscale(downscale_factor);
+    ret = mCtrlData.ctrl.commit();
+
+    pipeState = ret ? OPEN : CLOSED;
+    return ret;
+}
+
+bool GenericPipe::queueBuffer(int fd, uint32_t offset) {
+    //TODO Move pipe-id transfer to CtrlData class. Make ctrl and data private.
+    OVASSERT(isOpen(), "State is closed, cannot queueBuffer");
+    int pipeId = mCtrlData.ctrl.getPipeId();
+    OVASSERT(-1 != pipeId, "Ctrl ID should not be -1");
+    // set pipe id from ctrl to data
+    mCtrlData.data.setPipeId(pipeId);
+
+    return mCtrlData.data.queueBuffer(fd, offset);
+}
+
+int GenericPipe::getCtrlFd() const {
+    return mCtrlData.ctrl.getFd();
+}
+
+utils::Dim GenericPipe::getCrop() const
+{
+    return mCtrlData.ctrl.getCrop();
+}
+
+void GenericPipe::dump() const
+{
+    ALOGE("== Dump Generic pipe start ==");
+    ALOGE("pipe state = %d", (int)pipeState);
+    mCtrlData.ctrl.dump();
+    mCtrlData.data.dump();
+
+    ALOGE("== Dump Generic pipe end ==");
+}
+
+void GenericPipe::getDump(char *buf, size_t len) {
+    mCtrlData.ctrl.getDump(buf, len);
+    mCtrlData.data.getDump(buf, len);
+}
+
+bool GenericPipe::isClosed() const  {
+    return (pipeState == CLOSED);
+}
+
+bool GenericPipe::isOpen() const  {
+    return (pipeState == OPEN);
+}
+
+bool GenericPipe::setClosed() {
+    pipeState = CLOSED;
+    return true;
+}
+
+void GenericPipe::forceSet() {
+    mCtrlData.ctrl.forceSet();
+}
+
+} //namespace overlay
diff --git a/msm8974/liboverlay/pipes/overlayGenPipe.h b/msm8974/liboverlay/pipes/overlayGenPipe.h
new file mode 100644
index 0000000..2472f4e
--- /dev/null
+++ b/msm8974/liboverlay/pipes/overlayGenPipe.h
@@ -0,0 +1,101 @@
+/*
+* Copyright (c) 2011-2013, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*    * Redistributions of source code must retain the above copyright
+*      notice, this list of conditions and the following disclaimer.
+*    * Redistributions in binary form must reproduce the above
+*      copyright notice, this list of conditions and the following
+*      disclaimer in the documentation and/or other materials provided
+*      with the distribution.
+*    * Neither the name of The Linux Foundation nor the names of its
+*      contributors may be used to endorse or promote products derived
+*      from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef OVERLAY_GENERIC_PIPE_H
+#define OVERLAY_GENERIC_PIPE_H
+
+#include "overlayUtils.h"
+#include "overlayCtrlData.h"
+
+namespace overlay {
+
+class GenericPipe : utils::NoCopy {
+public:
+    /* ctor */
+    explicit GenericPipe(int dpy);
+    /* dtor */
+    ~GenericPipe();
+    bool init();
+    bool close();
+    /* Control APIs */
+    /* set source using whf, orient and wait flag */
+    void setSource(const utils::PipeArgs& args);
+    /* set crop a.k.a the region of interest */
+    void setCrop(const utils::Dim& d);
+    /* set orientation*/
+    void setTransform(const utils::eTransform& param);
+    /* set mdp posision using dim */
+    void setPosition(const utils::Dim& dim);
+    /* set visual param */
+    bool setVisualParams(const MetaData_t &metadata);
+    /* commit changes to the overlay "set"*/
+    bool commit();
+    /* Data APIs */
+    /* queue buffer to the overlay */
+    bool queueBuffer(int fd, uint32_t offset);
+    /* return cached startup args */
+    const utils::PipeArgs& getArgs() const;
+    /* retrieve cached crop data */
+    utils::Dim getCrop() const;
+    /* is closed */
+    bool isClosed() const;
+    /* is open */
+    bool isOpen() const;
+    /* return Ctrl fd. Used for S3D */
+    int getCtrlFd() const;
+    /* dump the state of the object */
+    void dump() const;
+    /* Return the dump in the specified buffer */
+    void getDump(char *buf, size_t len);
+    /* Marks the pipe for forcible setting of params
+     * even if they haven't changed
+     */
+    void forceSet();
+
+private:
+    /* set Closed pipe */
+    bool setClosed();
+
+    int mDpy;
+    /* Ctrl/Data aggregator */
+    CtrlData mCtrlData;
+    //Whether we will do downscale opt. This is just a request. If the frame is
+    //not a candidate, we might not do it.
+    bool mRotDownscaleOpt;
+    /* Pipe open or closed */
+    enum ePipeState {
+        CLOSED,
+        OPEN
+    };
+    ePipeState pipeState;
+};
+
+} //namespace overlay
+
+#endif // OVERLAY_GENERIC_PIPE_H
diff --git a/msm8974/libqdutils/Android.mk b/msm8974/libqdutils/Android.mk
new file mode 100644
index 0000000..459f548
--- /dev/null
+++ b/msm8974/libqdutils/Android.mk
@@ -0,0 +1,30 @@
+LOCAL_PATH := $(call my-dir)
+include $(LOCAL_PATH)/../common.mk
+include $(CLEAR_VARS)
+
+LOCAL_MODULE                  := libqdutils
+LOCAL_MODULE_TAGS             := optional
+LOCAL_SHARED_LIBRARIES        := $(common_libs)
+LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)
+LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"qdutils\"
+LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
+LOCAL_SRC_FILES               := profiler.cpp mdp_version.cpp \
+                                 idle_invalidator.cpp \
+                                 comptype.cpp
+include $(BUILD_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+
+LOCAL_COPY_HEADERS_TO           := $(common_header_export_path)
+LOCAL_COPY_HEADERS              := qdMetaData.h
+LOCAL_MODULE_PATH               := $(TARGET_OUT_SHARED_LIBRARIES)
+LOCAL_SHARED_LIBRARIES          := liblog libcutils
+LOCAL_C_INCLUDES                := $(common_includes)
+LOCAL_ADDITIONAL_DEPENDENCIES   := $(common_deps)
+LOCAL_SRC_FILES                 := qdMetaData.cpp
+LOCAL_CFLAGS                    := $(common_flags)
+LOCAL_CFLAGS                    += -DLOG_TAG=\"DisplayMetaData\"
+LOCAL_MODULE_TAGS               := optional
+LOCAL_MODULE                    := libqdMetaData
+include $(BUILD_SHARED_LIBRARY)
+
diff --git a/msm8974/libqdutils/comptype.cpp b/msm8974/libqdutils/comptype.cpp
new file mode 100644
index 0000000..a29158a
--- /dev/null
+++ b/msm8974/libqdutils/comptype.cpp
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation or the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include<comptype.h>
+
+//Instanticate the QCCompositionType Singleton
+ANDROID_SINGLETON_STATIC_INSTANCE(qdutils::QCCompositionType);
diff --git a/msm8974/libqdutils/comptype.h b/msm8974/libqdutils/comptype.h
new file mode 100644
index 0000000..71f4871
--- /dev/null
+++ b/msm8974/libqdutils/comptype.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation or the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef INCLUDE_LIBQCOM_COMPTYPES
+#define INCLUDE_LIBQCOM_COMPTYPES
+
+#include <stdint.h>
+#include <utils/Singleton.h>
+#include <cutils/properties.h>
+
+using namespace android;
+namespace qdutils {
+// Enum containing the supported composition types
+enum {
+    COMPOSITION_TYPE_GPU = 0,
+    COMPOSITION_TYPE_MDP = 0x1,
+    COMPOSITION_TYPE_C2D = 0x2,
+    COMPOSITION_TYPE_CPU = 0x4,
+    COMPOSITION_TYPE_DYN = 0x8
+};
+
+/* This class caches the composition type
+ */
+class QCCompositionType : public Singleton <QCCompositionType>
+{
+    public:
+        QCCompositionType();
+        ~QCCompositionType() { }
+        int getCompositionType() {return mCompositionType;}
+    private:
+        int mCompositionType;
+
+};
+
+inline QCCompositionType::QCCompositionType()
+{
+    char property[PROPERTY_VALUE_MAX];
+    mCompositionType = COMPOSITION_TYPE_GPU;
+    if (property_get("debug.composition.type", property, "gpu") > 0) {
+        if ((strncmp(property, "mdp", 3)) == 0) {
+            mCompositionType = COMPOSITION_TYPE_MDP;
+        } else if ((strncmp(property, "c2d", 3)) == 0) {
+            mCompositionType = COMPOSITION_TYPE_C2D;
+        } else if ((strncmp(property, "dyn", 3)) == 0) {
+#ifdef USE_MDP3
+            mCompositionType = COMPOSITION_TYPE_DYN | COMPOSITION_TYPE_MDP;
+#else
+            mCompositionType = COMPOSITION_TYPE_DYN | COMPOSITION_TYPE_C2D;
+#endif
+        }
+    }
+}
+
+}; //namespace qdutils
+#endif //INCLUDE_LIBQCOM_COMPTYPES
diff --git a/msm8974/libqdutils/idle_invalidator.cpp b/msm8974/libqdutils/idle_invalidator.cpp
new file mode 100644
index 0000000..97176a4
--- /dev/null
+++ b/msm8974/libqdutils/idle_invalidator.cpp
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "idle_invalidator.h"
+#include <unistd.h>
+
+#define II_DEBUG 0
+
+static const char *threadName = "Invalidator";
+InvalidatorHandler IdleInvalidator::mHandler = NULL;
+android::sp<IdleInvalidator> IdleInvalidator::sInstance(0);
+
+IdleInvalidator::IdleInvalidator(): Thread(false), mHwcContext(0),
+    mSleepAgain(false), mSleepTime(0) {
+        ALOGD_IF(II_DEBUG, "%s", __func__);
+    }
+
+int IdleInvalidator::init(InvalidatorHandler reg_handler, void* user_data,
+                          unsigned int idleSleepTime) {
+    ALOGD_IF(II_DEBUG, "%s", __func__);
+
+    Locker::Autolock _l(mLock);
+    /* store registered handler */
+    mHandler = reg_handler;
+    mHwcContext = user_data;
+    mSleepTime = idleSleepTime; //Time in millis
+    return 0;
+}
+
+bool IdleInvalidator::threadLoop() {
+    ALOGD_IF(II_DEBUG, "%s", __func__);
+    usleep(mSleepTime * 500);
+
+    Locker::Autolock _l(mLock);
+    if(mSleepAgain) {
+        //We need to sleep again!
+        mSleepAgain = false;
+        return true;
+    }
+
+    mHandler((void*)mHwcContext);
+    return false;
+}
+
+int IdleInvalidator::readyToRun() {
+    ALOGD_IF(II_DEBUG, "%s", __func__);
+    return 0; /*NO_ERROR*/
+}
+
+void IdleInvalidator::onFirstRef() {
+    ALOGD_IF(II_DEBUG, "%s", __func__);
+}
+
+void IdleInvalidator::markForSleep() {
+    Locker::Autolock _l(mLock);
+    mSleepAgain = true;
+    //Triggers the threadLoop to run, if not already running.
+    run(threadName, android::PRIORITY_AUDIO);
+}
+
+IdleInvalidator *IdleInvalidator::getInstance() {
+    ALOGD_IF(II_DEBUG, "%s", __func__);
+    if(sInstance.get() == NULL)
+        sInstance = new IdleInvalidator();
+    return sInstance.get();
+}
diff --git a/msm8974/libqdutils/idle_invalidator.h b/msm8974/libqdutils/idle_invalidator.h
new file mode 100644
index 0000000..abd9b29
--- /dev/null
+++ b/msm8974/libqdutils/idle_invalidator.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef INCLUDE_IDLEINVALIDATOR
+#define INCLUDE_IDLEINVALIDATOR
+
+#include <cutils/log.h>
+#include <utils/threads.h>
+#include <gr.h>
+
+typedef void (*InvalidatorHandler)(void*);
+
+class IdleInvalidator : public android::Thread {
+    void *mHwcContext;
+    bool mSleepAgain;
+    unsigned int mSleepTime;
+    static InvalidatorHandler mHandler;
+    static android::sp<IdleInvalidator> sInstance;
+    mutable Locker mLock;
+
+    public:
+    IdleInvalidator();
+    /* init timer obj */
+    int init(InvalidatorHandler reg_handler, void* user_data, unsigned int
+             idleSleepTime);
+    void markForSleep();
+    /*Overrides*/
+    virtual bool        threadLoop();
+    virtual int         readyToRun();
+    virtual void        onFirstRef();
+    static IdleInvalidator *getInstance();
+};
+
+#endif // INCLUDE_IDLEINVALIDATOR
diff --git a/msm8974/libqdutils/mdp_version.cpp b/msm8974/libqdutils/mdp_version.cpp
new file mode 100644
index 0000000..1dd317f
--- /dev/null
+++ b/msm8974/libqdutils/mdp_version.cpp
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <cutils/log.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/fb.h>
+#include <linux/msm_mdp.h>
+#include "mdp_version.h"
+
+ANDROID_SINGLETON_STATIC_INSTANCE(qdutils::MDPVersion);
+namespace qdutils {
+
+MDPVersion::MDPVersion()
+{
+    int fb_fd = open("/dev/graphics/fb0", O_RDWR);
+    int mdp_version = MDP_V_UNKNOWN;
+    char panel_type = 0;
+    struct fb_fix_screeninfo fb_finfo;
+
+    mMdpRev = 0;
+    mRGBPipes = 0;
+    mVGPipes = 0;
+    mDMAPipes = 0;
+    mFeatures = 0;
+    //TODO get this from driver, default for A-fam to 8
+    mMDPDownscale = 8;
+    mFd = fb_fd;
+
+    if (ioctl(fb_fd, FBIOGET_FSCREENINFO, &fb_finfo) < 0) {
+        ALOGE("FBIOGET_FSCREENINFO failed");
+        mdp_version =  MDP_V_UNKNOWN;
+    } else {
+        if(!strncmp(fb_finfo.id, "msmfb", 5)) {
+            char str_ver[4] = { 0 };
+            memcpy(str_ver, &fb_finfo.id[5], 3);
+            str_ver[3] = '\0';
+            mdp_version = atoi(str_ver);
+
+            //Normalize MDP version to ease comparison.
+            //This is needed only because
+            //MDP 3.0.3 reports value as 303 which
+            //is more than all the others
+            if (mdp_version < 100)
+                mdp_version *= 10;
+
+            mRGBPipes = mVGPipes = 2;
+
+        } else if (!strncmp(fb_finfo.id, "mdssfb", 6)) {
+            mdp_version = MDSS_V5;
+#ifdef MDSS_TARGET
+            struct msmfb_metadata metadata;
+            memset(&metadata, 0 , sizeof(metadata));
+            metadata.op = metadata_op_get_caps;
+            if (ioctl(fb_fd, MSMFB_METADATA_GET, &metadata) == -1) {
+                ALOGE("Error retrieving MDP revision and pipes info");
+                mdp_version = MDP_V_UNKNOWN;
+            } else {
+                mMdpRev = metadata.data.caps.mdp_rev;
+                mRGBPipes = metadata.data.caps.rgb_pipes;
+                mVGPipes = metadata.data.caps.vig_pipes;
+                mDMAPipes = metadata.data.caps.dma_pipes;
+                mFeatures = metadata.data.caps.features;
+                if (metadata.data.caps.mdp_rev == MDP_V3_0_4){
+                    mdp_version = MDP_V3_0_4;
+                }
+            }
+#endif
+        } else {
+            mdp_version = MDP_V_UNKNOWN;
+        }
+
+        /* Assumes panel type is 2nd element in '_' delimited id string */
+        char * ptype = strstr(fb_finfo.id, "_");
+        if (!ptype || (*(++ptype) == '\0')) {
+            ALOGE("Invalid framebuffer info string: %s", fb_finfo.id);
+            ptype = fb_finfo.id;
+        }
+        panel_type = *ptype;
+    }
+    mPanelType = panel_type;
+    mMDPVersion = mdp_version;
+    mHasOverlay = false;
+    if((mMDPVersion >= MDP_V4_0) ||
+       (mMDPVersion == MDP_V_UNKNOWN) ||
+       (mMDPVersion == MDP_V3_0_4))
+        mHasOverlay = true;
+    if(mMDPVersion >= MDSS_V5) {
+        //TODO get this from driver
+        mMDPDownscale = 4;
+
+        char split[64];
+        FILE* fp = fopen("/sys/class/graphics/fb0/msm_fb_split", "r");
+        if(fp){
+            //Format "left right" space as delimiter
+            if(fread(split, sizeof(char), 64, fp)) {
+                mSplit.mLeft = atoi(split);
+                ALOGI_IF(mSplit.mLeft, "Left Split=%d", mSplit.mLeft);
+                char *rght = strpbrk(split, " ");
+                if(rght)
+                    mSplit.mRight = atoi(rght + 1);
+                ALOGI_IF(rght, "Right Split=%d", mSplit.mRight);
+            }
+        } else {
+            ALOGE("Failed to open mdss_fb_split node");
+        }
+
+        if(fp)
+            fclose(fp);
+    }
+}
+
+MDPVersion::~MDPVersion() {
+    close(mFd);
+}
+
+bool MDPVersion::supportsDecimation() {
+    return mFeatures & MDP_DECIMATION_EN;
+}
+
+uint32_t MDPVersion::getMaxMDPDownscale() {
+    return mMDPDownscale;
+}
+
+bool MDPVersion::supportsBWC() {
+    // BWC - Bandwidth Compression
+    return (mFeatures & MDP_BWC_EN);
+}
+
+bool MDPVersion::is8x26() {
+    // check for 8x26 variants
+    // chip variants have same major number and minor numbers usually vary
+    // for e.g., MDSS_MDP_HW_REV_101 is 0x10010000
+    //                                    1001       -  major number
+    //                                        0000   -  minor number
+    // 8x26 v1 minor number is 0000
+    //      v2 minor number is 0001 etc..
+    if( mMdpRev >= MDSS_MDP_HW_REV_101 && mMdpRev < MDSS_MDP_HW_REV_102) {
+        return true;
+    }
+    return false;
+}
+
+}; //namespace qdutils
+
diff --git a/msm8974/libqdutils/mdp_version.h b/msm8974/libqdutils/mdp_version.h
new file mode 100644
index 0000000..316899f
--- /dev/null
+++ b/msm8974/libqdutils/mdp_version.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef INCLUDE_LIBQCOMUTILS_MDPVER
+#define INCLUDE_LIBQCOMUTILS_MDPVER
+
+#include <stdint.h>
+#include <utils/Singleton.h>
+#include <cutils/properties.h>
+
+/* This class gets the MSM type from the soc info
+*/
+using namespace android;
+namespace qdutils {
+enum mdp_version {
+    MDP_V_UNKNOWN = 0,
+    MDP_V2_2    = 220,
+    MDP_V3_0    = 300,
+    MDP_V3_0_3  = 303,
+    MDP_V3_0_4  = 304,
+    MDP_V3_1    = 310,
+    MDP_V4_0    = 400,
+    MDP_V4_1    = 410,
+    MDP_V4_2    = 420,
+    MDP_V4_3    = 430,
+    MDP_V4_4    = 440,
+    MDSS_V5     = 500,
+};
+
+enum mdp_rev {
+    MDSS_MDP_HW_REV_100 = 0x10000000,
+    MDSS_MDP_HW_REV_101 = 0x10010000, //8x26
+    MDSS_MDP_HW_REV_102 = 0x10020000,
+};
+
+enum {
+    MAX_DISPLAY_DIM = 2048,
+};
+
+#define MDDI_PANEL       '1'
+#define EBI2_PANEL       '2'
+#define LCDC_PANEL       '3'
+#define EXT_MDDI_PANEL   '4'
+#define TV_PANEL         '5'
+#define DTV_PANEL        '7'
+#define MIPI_VIDEO_PANEL '8'
+#define MIPI_CMD_PANEL   '9'
+#define WRITEBACK_PANEL  'a'
+#define LVDS_PANEL       'b'
+
+class MDPVersion;
+
+struct Split {
+    int mLeft;
+    int mRight;
+    Split() : mLeft(0), mRight(0){}
+    int left() { return mLeft; }
+    int right() { return mRight; }
+    friend class MDPVersion;
+};
+
+class MDPVersion : public Singleton <MDPVersion>
+{
+public:
+    MDPVersion();
+    ~MDPVersion();
+    int getMDPVersion() {return mMDPVersion;}
+    char getPanelType() {return mPanelType;}
+    bool hasOverlay() {return mHasOverlay;}
+    uint8_t getTotalPipes() { return (mRGBPipes + mVGPipes + mDMAPipes);}
+    uint8_t getRGBPipes() { return mRGBPipes; }
+    uint8_t getVGPipes() { return mVGPipes; }
+    uint8_t getDMAPipes() { return mDMAPipes; }
+    bool supportsDecimation();
+    uint32_t getMaxMDPDownscale();
+    bool supportsBWC();
+    bool is8x26();
+    int getLeftSplit() { return mSplit.left(); }
+    int getRightSplit() { return mSplit.right(); }
+private:
+    int mFd;
+    int mMDPVersion;
+    char mPanelType;
+    bool mHasOverlay;
+    uint32_t mMdpRev;
+    uint8_t mRGBPipes;
+    uint8_t mVGPipes;
+    uint8_t mDMAPipes;
+    uint32_t mFeatures;
+    uint32_t mMDPDownscale;
+    Split mSplit;
+};
+}; //namespace qdutils
+#endif //INCLUDE_LIBQCOMUTILS_MDPVER
diff --git a/msm8974/libqdutils/profiler.cpp b/msm8974/libqdutils/profiler.cpp
new file mode 100644
index 0000000..3c04382
--- /dev/null
+++ b/msm8974/libqdutils/profiler.cpp
@@ -0,0 +1,190 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOG_NDDEBUG 0
+#include "profiler.h"
+
+#ifdef DEBUG_CALC_FPS
+
+
+ANDROID_SINGLETON_STATIC_INSTANCE(qdutils::CalcFps) ;
+
+namespace qdutils {
+
+CalcFps::CalcFps() {
+    debug_fps_level = 0;
+    Init();
+}
+
+CalcFps::~CalcFps() {
+}
+
+void CalcFps::Init() {
+    char prop[PROPERTY_VALUE_MAX];
+    property_get("debug.gr.calcfps", prop, "0");
+    debug_fps_level = atoi(prop);
+    if (debug_fps_level > MAX_DEBUG_FPS_LEVEL) {
+        ALOGW("out of range value for debug.gr.calcfps, using 0");
+        debug_fps_level = 0;
+    }
+
+    ALOGD("DEBUG_CALC_FPS: %d", debug_fps_level);
+    populate_debug_fps_metadata();
+}
+
+void CalcFps::Fps() {
+    if (debug_fps_level > 0)
+        calc_fps(ns2us(systemTime()));
+}
+
+void CalcFps::populate_debug_fps_metadata(void)
+{
+    char prop[PROPERTY_VALUE_MAX];
+
+    /*defaults calculation of fps to based on number of frames*/
+    property_get("debug.gr.calcfps.type", prop, "0");
+    debug_fps_metadata.type = (debug_fps_metadata_t::DfmType) atoi(prop);
+
+    /*defaults to 1000ms*/
+    property_get("debug.gr.calcfps.timeperiod", prop, "1000");
+    debug_fps_metadata.time_period = atoi(prop);
+
+    property_get("debug.gr.calcfps.period", prop, "10");
+    debug_fps_metadata.period = atoi(prop);
+
+    if (debug_fps_metadata.period > MAX_FPS_CALC_PERIOD_IN_FRAMES) {
+        debug_fps_metadata.period = MAX_FPS_CALC_PERIOD_IN_FRAMES;
+    }
+
+    /* default ignorethresh_us: 500 milli seconds */
+    property_get("debug.gr.calcfps.ignorethresh_us", prop, "500000");
+    debug_fps_metadata.ignorethresh_us = atoi(prop);
+
+    debug_fps_metadata.framearrival_steps =
+        (debug_fps_metadata.ignorethresh_us / 16666);
+
+    if (debug_fps_metadata.framearrival_steps > MAX_FRAMEARRIVAL_STEPS) {
+        debug_fps_metadata.framearrival_steps = MAX_FRAMEARRIVAL_STEPS;
+        debug_fps_metadata.ignorethresh_us =
+            debug_fps_metadata.framearrival_steps * 16666;
+    }
+
+    /* 2ms margin of error for the gettimeofday */
+    debug_fps_metadata.margin_us = 2000;
+
+    for (unsigned int i = 0; i < MAX_FRAMEARRIVAL_STEPS; i++)
+        debug_fps_metadata.accum_framearrivals[i] = 0;
+
+    ALOGD("period: %d", debug_fps_metadata.period);
+    ALOGD("ignorethresh_us: %lld", debug_fps_metadata.ignorethresh_us);
+}
+
+void CalcFps::print_fps(float fps)
+{
+    if (debug_fps_metadata_t::DFM_FRAMES == debug_fps_metadata.type)
+        ALOGD("FPS for last %d frames: %3.2f", debug_fps_metadata.period, fps);
+    else
+        ALOGD("FPS for last (%f ms, %d frames): %3.2f",
+              debug_fps_metadata.time_elapsed,
+              debug_fps_metadata.curr_frame, fps);
+
+    debug_fps_metadata.curr_frame = 0;
+    debug_fps_metadata.time_elapsed = 0.0;
+
+    if (debug_fps_level > 1) {
+        ALOGD("Frame Arrival Distribution:");
+        for (unsigned int i = 0;
+             i < ((debug_fps_metadata.framearrival_steps / 6) + 1);
+             i++) {
+            ALOGD("%lld %lld %lld %lld %lld %lld",
+                  debug_fps_metadata.accum_framearrivals[i*6],
+                  debug_fps_metadata.accum_framearrivals[i*6+1],
+                  debug_fps_metadata.accum_framearrivals[i*6+2],
+                  debug_fps_metadata.accum_framearrivals[i*6+3],
+                  debug_fps_metadata.accum_framearrivals[i*6+4],
+                  debug_fps_metadata.accum_framearrivals[i*6+5]);
+        }
+
+        /* We are done with displaying, now clear the stats */
+        for (unsigned int i = 0;
+             i < debug_fps_metadata.framearrival_steps;
+             i++)
+            debug_fps_metadata.accum_framearrivals[i] = 0;
+    }
+    return;
+}
+
+void CalcFps::calc_fps(nsecs_t currtime_us)
+{
+    static nsecs_t oldtime_us = 0;
+
+    nsecs_t diff = currtime_us - oldtime_us;
+
+    oldtime_us = currtime_us;
+
+    if (debug_fps_metadata_t::DFM_FRAMES == debug_fps_metadata.type &&
+        diff > debug_fps_metadata.ignorethresh_us) {
+        return;
+    }
+
+    if (debug_fps_metadata.curr_frame < MAX_FPS_CALC_PERIOD_IN_FRAMES) {
+        debug_fps_metadata.framearrivals[debug_fps_metadata.curr_frame] = diff;
+    }
+
+    debug_fps_metadata.curr_frame++;
+
+    if (debug_fps_level > 1) {
+        unsigned int currstep = (diff + debug_fps_metadata.margin_us) / 16666;
+
+        if (currstep < debug_fps_metadata.framearrival_steps) {
+            debug_fps_metadata.accum_framearrivals[currstep-1]++;
+        }
+    }
+
+    if (debug_fps_metadata_t::DFM_FRAMES == debug_fps_metadata.type) {
+        if (debug_fps_metadata.curr_frame == debug_fps_metadata.period) {
+            /* time to calculate and display FPS */
+            nsecs_t sum = 0;
+            for (unsigned int i = 0; i < debug_fps_metadata.period; i++)
+                sum += debug_fps_metadata.framearrivals[i];
+            print_fps((debug_fps_metadata.period * float(1000000))/float(sum));
+        }
+    }
+    else if (debug_fps_metadata_t::DFM_TIME == debug_fps_metadata.type) {
+        debug_fps_metadata.time_elapsed += ((float)diff/1000.0);
+        if (debug_fps_metadata.time_elapsed >= debug_fps_metadata.time_period) {
+            float fps = (1000.0 * debug_fps_metadata.curr_frame)/
+                (float)debug_fps_metadata.time_elapsed;
+            print_fps(fps);
+        }
+    }
+    return;
+}
+};//namespace qomutils
+#endif
diff --git a/msm8974/libqdutils/profiler.h b/msm8974/libqdutils/profiler.h
new file mode 100644
index 0000000..5f270b0
--- /dev/null
+++ b/msm8974/libqdutils/profiler.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2011-2012, The Linux Foundation. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of The Linux Foundation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef INCLUDE_PROFILER
+#define INCLUDE_PROFILER
+
+#include <stdio.h>
+#include <utils/Singleton.h>
+#include <cutils/properties.h>
+#include <cutils/log.h>
+
+#ifndef DEBUG_CALC_FPS
+#define CALC_FPS() ((void)0)
+#define CALC_INIT() ((void)0)
+#else
+#define CALC_FPS() qdutils::CalcFps::getInstance().Fps()
+#define CALC_INIT() qdutils::CalcFps::getInstance().Init()
+using namespace android;
+namespace qdutils {
+class CalcFps : public Singleton<CalcFps> {
+    public:
+    CalcFps();
+    ~CalcFps();
+
+    void Init();
+    void Fps();
+
+    private:
+    static const unsigned int MAX_FPS_CALC_PERIOD_IN_FRAMES = 128;
+    static const unsigned int MAX_FRAMEARRIVAL_STEPS = 50;
+    static const unsigned int MAX_DEBUG_FPS_LEVEL = 2;
+
+    struct debug_fps_metadata_t {
+        /*fps calculation based on time or number of frames*/
+        enum DfmType {
+            DFM_FRAMES = 0,
+            DFM_TIME   = 1,
+        };
+
+        DfmType type;
+
+        /* indicates how much time do we wait till we calculate FPS */
+        unsigned long time_period;
+
+        /*indicates how much time elapsed since we report fps*/
+        float time_elapsed;
+
+        /* indicates how many frames do we wait till we calculate FPS */
+        unsigned int period;
+        /* current frame, will go upto period, and then reset */
+        unsigned int curr_frame;
+        /* frame will arrive at a multiple of 16666 us at the display.
+           This indicates how many steps to consider for our calculations.
+           For example, if framearrival_steps = 10, then the frame that arrived
+           after 166660 us or more will be ignored.
+           */
+        unsigned int framearrival_steps;
+        /* ignorethresh_us = framearrival_steps * 16666 */
+        nsecs_t      ignorethresh_us;
+        /* used to calculate the actual frame arrival step, the times might not be
+           accurate
+           */
+        unsigned int margin_us;
+
+        /* actual data storage */
+        nsecs_t      framearrivals[MAX_FPS_CALC_PERIOD_IN_FRAMES];
+        nsecs_t      accum_framearrivals[MAX_FRAMEARRIVAL_STEPS];
+    };
+
+    private:
+    void populate_debug_fps_metadata(void);
+    void print_fps(float fps);
+    void calc_fps(nsecs_t currtime_us);
+
+    private:
+    debug_fps_metadata_t debug_fps_metadata;
+    unsigned int debug_fps_level;
+};
+};//namespace qdutils
+#endif
+
+#endif // INCLUDE_PROFILER
diff --git a/msm8974/libqdutils/qdMetaData.cpp b/msm8974/libqdutils/qdMetaData.cpp
new file mode 100644
index 0000000..7fa4512
--- /dev/null
+++ b/msm8974/libqdutils/qdMetaData.cpp
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <string.h>
+#include <sys/mman.h>
+#include <cutils/log.h>
+#include <gralloc_priv.h>
+#include "qdMetaData.h"
+
+int setMetaData(private_handle_t *handle, DispParamType paramType,
+                                                    void *param) {
+    if (!handle) {
+        ALOGE("%s: Private handle is null!", __func__);
+        return -1;
+    }
+    if (handle->fd_metadata == -1) {
+        ALOGE("%s: Bad fd for extra data!", __func__);
+        return -1;
+    }
+    if (!param) {
+        ALOGE("%s: input param is null!", __func__);
+        return -1;
+    }
+    unsigned long size = ROUND_UP_PAGESIZE(sizeof(MetaData_t));
+    void *base = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED,
+        handle->fd_metadata, 0);
+    if (!base) {
+        ALOGE("%s: mmap() failed: Base addr is NULL!", __func__);
+        return -1;
+    }
+    MetaData_t *data = reinterpret_cast <MetaData_t *>(base);
+    data->operation |= paramType;
+    switch (paramType) {
+        case PP_PARAM_HSIC:
+            memcpy((void *)&data->hsicData, param, sizeof(HSICData_t));
+            break;
+        case PP_PARAM_SHARPNESS:
+            data->sharpness = *((int32_t *)param);
+            break;
+        case PP_PARAM_VID_INTFC:
+            data->video_interface = *((int32_t *)param);
+            break;
+        case PP_PARAM_INTERLACED:
+            data->interlaced = *((int32_t *)param);
+            break;
+        case PP_PARAM_IGC:
+            memcpy((void *)&data->igcData, param, sizeof(IGCData_t));
+            break;
+        case PP_PARAM_SHARP2:
+            memcpy((void *)&data->Sharp2Data, param, sizeof(Sharp2Data_t));
+            break;
+        case PP_PARAM_TIMESTAMP:
+            data->timestamp = *((int64_t *)param);
+            break;
+        case UPDATE_BUFFER_GEOMETRY:
+            memcpy((void *)&data->bufferDim, param, sizeof(BufferDim_t));
+            break;
+        case UPDATE_COLOR_SPACE:
+            data->colorSpace = *((ColorSpace_t *)param);
+            break;
+        default:
+            ALOGE("Unknown paramType %d", paramType);
+            break;
+    }
+    if(munmap(base, size))
+        ALOGE("%s: failed to unmap ptr 0x%x, err %d", __func__, (int)base,
+                                                                        errno);
+    return 0;
+}
diff --git a/msm8974/libqdutils/qdMetaData.h b/msm8974/libqdutils/qdMetaData.h
new file mode 100644
index 0000000..dd1a7db
--- /dev/null
+++ b/msm8974/libqdutils/qdMetaData.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _QDMETADATA_H
+#define _QDMETADATA_H
+
+#define MAX_IGC_LUT_ENTRIES 256
+
+typedef enum {
+    ITU_R_601,
+    ITU_R_601_FR,
+    ITU_R_709,
+} ColorSpace_t;
+
+struct HSICData_t {
+    int32_t hue;
+    float   saturation;
+    int32_t intensity;
+    float   contrast;
+};
+
+struct Sharp2Data_t {
+    int32_t strength;
+    uint32_t edge_thr;
+    uint32_t smooth_thr;
+    uint32_t noise_thr;
+};
+
+struct IGCData_t{
+    uint16_t c0[MAX_IGC_LUT_ENTRIES];
+    uint16_t c1[MAX_IGC_LUT_ENTRIES];
+    uint16_t c2[MAX_IGC_LUT_ENTRIES];
+};
+
+struct BufferDim_t {
+    int32_t sliceWidth;
+    int32_t sliceHeight;
+};
+
+struct MetaData_t {
+    int32_t operation;
+    int32_t interlaced;
+    BufferDim_t bufferDim;
+    HSICData_t hsicData;
+    int32_t sharpness;
+    int32_t video_interface;
+    IGCData_t igcData;
+    Sharp2Data_t Sharp2Data;
+    int64_t timestamp;
+    ColorSpace_t colorSpace;
+};
+
+typedef enum {
+    PP_PARAM_HSIC       = 0x0001,
+    PP_PARAM_SHARPNESS  = 0x0002,
+    PP_PARAM_INTERLACED = 0x0004,
+    PP_PARAM_VID_INTFC  = 0x0008,
+    PP_PARAM_IGC        = 0x0010,
+    PP_PARAM_SHARP2     = 0x0020,
+    PP_PARAM_TIMESTAMP  = 0x0040,
+    UPDATE_BUFFER_GEOMETRY = 0x0080,
+    UPDATE_COLOR_SPACE = 0x0100,
+} DispParamType;
+
+int setMetaData(private_handle_t *handle, DispParamType paramType, void *param);
+
+#endif /* _QDMETADATA_H */
+
diff --git a/msm8974/libqservice/Android.mk b/msm8974/libqservice/Android.mk
new file mode 100644
index 0000000..17b2eda
--- /dev/null
+++ b/msm8974/libqservice/Android.mk
@@ -0,0 +1,20 @@
+LOCAL_PATH := $(call my-dir)
+include $(LOCAL_PATH)/../common.mk
+include $(CLEAR_VARS)
+
+LOCAL_MODULE                  := libqservice
+LOCAL_MODULE_PATH             := $(TARGET_OUT_SHARED_LIBRARIES)
+LOCAL_MODULE_TAGS             := optional
+LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)
+LOCAL_SHARED_LIBRARIES        := $(common_libs) libexternal libbinder
+LOCAL_CFLAGS                  := $(common_flags) -DLOG_TAG=\"qdqservice\"
+LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
+LOCAL_SRC_FILES               := QService.cpp \
+                                 IQService.cpp \
+                                 IQClient.cpp
+LOCAL_COPY_HEADERS_TO         := $(common_header_export_path)
+LOCAL_COPY_HEADERS            := IQService.h \
+                                 IQClient.h
+
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/msm8974/libqservice/IQClient.cpp b/msm8974/libqservice/IQClient.cpp
new file mode 100644
index 0000000..30fbb64
--- /dev/null
+++ b/msm8974/libqservice/IQClient.cpp
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sys/types.h>
+#include <binder/Parcel.h>
+#include <binder/IBinder.h>
+#include <binder/IInterface.h>
+#include <utils/Errors.h>
+#include <IQClient.h>
+
+using namespace android;
+
+// ---------------------------------------------------------------------------
+
+namespace qClient {
+
+enum {
+    NOTIFY_CALLBACK = IBinder::FIRST_CALL_TRANSACTION,
+};
+
+class BpQClient : public BpInterface<IQClient>
+{
+public:
+    BpQClient(const sp<IBinder>& impl)
+        : BpInterface<IQClient>(impl) {}
+
+    virtual status_t notifyCallback(uint32_t msg, uint32_t value) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IQClient::getInterfaceDescriptor());
+        data.writeInt32(msg);
+        data.writeInt32(value);
+        remote()->transact(NOTIFY_CALLBACK, data, &reply);
+        status_t result = reply.readInt32();
+        return result;
+    }
+};
+
+IMPLEMENT_META_INTERFACE(QClient, "android.display.IQClient");
+
+// ----------------------------------------------------------------------
+
+status_t BnQClient::onTransact(
+    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
+{
+    switch(code) {
+        case NOTIFY_CALLBACK: {
+            CHECK_INTERFACE(IQClient, data, reply);
+            uint32_t msg = data.readInt32();
+            uint32_t value = data.readInt32();
+            notifyCallback(msg, value);
+            return NO_ERROR;
+        } break;
+        default:
+            return BBinder::onTransact(code, data, reply, flags);
+    }
+}
+
+}; // namespace qClient
diff --git a/msm8974/libqservice/IQClient.h b/msm8974/libqservice/IQClient.h
new file mode 100644
index 0000000..a28f826
--- /dev/null
+++ b/msm8974/libqservice/IQClient.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_IQCLIENT_H
+#define ANDROID_IQCLIENT_H
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <utils/Errors.h>
+#include <utils/RefBase.h>
+#include <binder/IInterface.h>
+
+namespace qClient {
+// ----------------------------------------------------------------------------
+class IQClient : public android::IInterface
+{
+public:
+    DECLARE_META_INTERFACE(QClient);
+    virtual android::status_t notifyCallback(uint32_t msg, uint32_t value) = 0;
+};
+
+// ----------------------------------------------------------------------------
+
+class BnQClient : public android::BnInterface<IQClient>
+{
+public:
+    virtual android::status_t onTransact( uint32_t code,
+                                          const android::Parcel& data,
+                                          android::Parcel* reply,
+                                          uint32_t flags = 0);
+};
+
+// ----------------------------------------------------------------------------
+}; // namespace qClient
+
+#endif // ANDROID_IQCLIENT_H
diff --git a/msm8974/libqservice/IQService.cpp b/msm8974/libqservice/IQService.cpp
new file mode 100644
index 0000000..d9aa735
--- /dev/null
+++ b/msm8974/libqservice/IQService.cpp
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <binder/Parcel.h>
+#include <binder/IBinder.h>
+#include <binder/IInterface.h>
+#include <binder/IPCThreadState.h>
+#include <utils/Errors.h>
+#include <private/android_filesystem_config.h>
+
+#include <IQService.h>
+
+using namespace android;
+using namespace qClient;
+
+// ---------------------------------------------------------------------------
+
+namespace qService {
+
+class BpQService : public BpInterface<IQService>
+{
+public:
+    BpQService(const sp<IBinder>& impl)
+        : BpInterface<IQService>(impl) {}
+
+    virtual void securing(uint32_t startEnd) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IQService::getInterfaceDescriptor());
+        data.writeInt32(startEnd);
+        remote()->transact(SECURING, data, &reply);
+    }
+
+    virtual void unsecuring(uint32_t startEnd) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IQService::getInterfaceDescriptor());
+        data.writeInt32(startEnd);
+        remote()->transact(UNSECURING, data, &reply);
+    }
+
+    virtual void connect(const sp<IQClient>& client) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IQService::getInterfaceDescriptor());
+        data.writeStrongBinder(IInterface::asBinder(client));
+        remote()->transact(CONNECT, data, &reply);
+    }
+
+    virtual status_t screenRefresh() {
+        Parcel data, reply;
+        data.writeInterfaceToken(IQService::getInterfaceDescriptor());
+        remote()->transact(SCREEN_REFRESH, data, &reply);
+        status_t result = reply.readInt32();
+        return result;
+    }
+};
+
+IMPLEMENT_META_INTERFACE(QService, "android.display.IQService");
+
+// ----------------------------------------------------------------------
+
+static void getProcName(int pid, char *buf, int size);
+
+status_t BnQService::onTransact(
+    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
+{
+    // IPC should be from mediaserver only
+    IPCThreadState* ipc = IPCThreadState::self();
+    const int callerPid = ipc->getCallingPid();
+    const int callerUid = ipc->getCallingUid();
+    const size_t MAX_BUF_SIZE = 1024;
+    char callingProcName[MAX_BUF_SIZE] = {0};
+
+    getProcName(callerPid, callingProcName, MAX_BUF_SIZE);
+
+    const bool permission = (callerUid == AID_MEDIA);
+
+    switch(code) {
+        case SECURING: {
+            if(!permission) {
+                ALOGE("display.qservice SECURING access denied: \
+                      pid=%d uid=%d process=%s",
+                      callerPid, callerUid, callingProcName);
+                return PERMISSION_DENIED;
+            }
+            CHECK_INTERFACE(IQService, data, reply);
+            uint32_t startEnd = data.readInt32();
+            securing(startEnd);
+            return NO_ERROR;
+        } break;
+        case UNSECURING: {
+            if(!permission) {
+                ALOGE("display.qservice UNSECURING access denied: \
+                      pid=%d uid=%d process=%s",
+                      callerPid, callerUid, callingProcName);
+                return PERMISSION_DENIED;
+            }
+            CHECK_INTERFACE(IQService, data, reply);
+            uint32_t startEnd = data.readInt32();
+            unsecuring(startEnd);
+            return NO_ERROR;
+        } break;
+        case CONNECT: {
+            CHECK_INTERFACE(IQService, data, reply);
+            if(callerUid != AID_GRAPHICS) {
+                ALOGE("display.qservice CONNECT access denied: \
+                      pid=%d uid=%d process=%s",
+                      callerPid, callerUid, callingProcName);
+                return PERMISSION_DENIED;
+            }
+            sp<IQClient> client =
+                interface_cast<IQClient>(data.readStrongBinder());
+            connect(client);
+            return NO_ERROR;
+        } break;
+        case SCREEN_REFRESH: {
+            CHECK_INTERFACE(IQService, data, reply);
+            if(callerUid != AID_SYSTEM) {
+                ALOGE("display.qservice SCREEN_REFRESH access denied: \
+                      pid=%d uid=%d process=%s",callerPid,
+                      callerUid, callingProcName);
+                return PERMISSION_DENIED;
+            }
+            return screenRefresh();
+        } break;
+        default:
+            return BBinder::onTransact(code, data, reply, flags);
+    }
+}
+
+//Helper
+static void getProcName(int pid, char *buf, int size) {
+    int fd = -1;
+    snprintf(buf, size, "/proc/%d/cmdline", pid);
+    fd = open(buf, O_RDONLY);
+    if (fd < 0) {
+        strcpy(buf, "Unknown");
+    } else {
+        int len = read(fd, buf, size - 1);
+        buf[len] = 0;
+        close(fd);
+    }
+}
+
+}; // namespace qService
diff --git a/msm8974/libqservice/IQService.h b/msm8974/libqservice/IQService.h
new file mode 100644
index 0000000..79e831d
--- /dev/null
+++ b/msm8974/libqservice/IQService.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are
+ * retained for attribution purposes only.
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_IQSERVICE_H
+#define ANDROID_IQSERVICE_H
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <utils/Errors.h>
+#include <utils/RefBase.h>
+#include <binder/IInterface.h>
+#include <binder/IBinder.h>
+#include <IQClient.h>
+
+namespace qService {
+// ----------------------------------------------------------------------------
+class IQService : public android::IInterface
+{
+public:
+    DECLARE_META_INTERFACE(QService);
+    enum {
+        // Hardware securing start/end notification
+        SECURING = android::IBinder::FIRST_CALL_TRANSACTION,
+        UNSECURING, // Hardware unsecuring start/end notification
+        CONNECT,
+        SCREEN_REFRESH,
+    };
+    enum {
+        END = 0,
+        START,
+    };
+    virtual void securing(uint32_t startEnd) = 0;
+    virtual void unsecuring(uint32_t startEnd) = 0;
+    virtual void connect(const android::sp<qClient::IQClient>& client) = 0;
+    virtual android::status_t screenRefresh() = 0;
+};
+
+// ----------------------------------------------------------------------------
+
+class BnQService : public android::BnInterface<IQService>
+{
+public:
+    virtual android::status_t onTransact( uint32_t code,
+                                          const android::Parcel& data,
+                                          android::Parcel* reply,
+                                          uint32_t flags = 0);
+};
+
+// ----------------------------------------------------------------------------
+}; // namespace qService
+
+#endif // ANDROID_IQSERVICE_H
diff --git a/msm8974/libqservice/QService.cpp b/msm8974/libqservice/QService.cpp
new file mode 100644
index 0000000..54e285c
--- /dev/null
+++ b/msm8974/libqservice/QService.cpp
@@ -0,0 +1,87 @@
+/*
+ *  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <QService.h>
+
+#define QSERVICE_DEBUG 0
+
+using namespace android;
+
+namespace qService {
+
+QService* QService::sQService = NULL;
+// ----------------------------------------------------------------------------
+QService::QService()
+{
+    ALOGD_IF(QSERVICE_DEBUG, "QService Constructor invoked");
+}
+
+QService::~QService()
+{
+    ALOGD_IF(QSERVICE_DEBUG,"QService Destructor invoked");
+}
+
+void QService::securing(uint32_t startEnd) {
+    if(mClient.get()) {
+        mClient->notifyCallback(SECURING, startEnd);
+    }
+}
+
+void QService::unsecuring(uint32_t startEnd) {
+    if(mClient.get()) {
+        mClient->notifyCallback(UNSECURING, startEnd);
+    }
+}
+
+void QService::connect(const sp<qClient::IQClient>& client) {
+    mClient = client;
+}
+
+android::status_t QService::screenRefresh() {
+    status_t result = NO_ERROR;
+    if(mClient.get()) {
+        result = mClient->notifyCallback(SCREEN_REFRESH, 0);
+    }
+    return result;
+}
+
+void QService::init()
+{
+    if(!sQService) {
+        sQService = new QService();
+        sp<IServiceManager> sm = defaultServiceManager();
+        sm->addService(String16("display.qservice"), sQService);
+        if(sm->checkService(String16("display.qservice")) != NULL)
+            ALOGD_IF(QSERVICE_DEBUG, "adding display.qservice succeeded");
+        else
+            ALOGD_IF(QSERVICE_DEBUG, "adding display.qservice failed");
+    }
+}
+
+}
diff --git a/msm8974/libqservice/QService.h b/msm8974/libqservice/QService.h
new file mode 100644
index 0000000..268bf81
--- /dev/null
+++ b/msm8974/libqservice/QService.h
@@ -0,0 +1,59 @@
+/*
+ *  Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ANDROID_QSERVICE_H
+#define ANDROID_QSERVICE_H
+
+#include <utils/Errors.h>
+#include <sys/types.h>
+#include <cutils/log.h>
+#include <binder/IServiceManager.h>
+#include <IQService.h>
+#include <IQClient.h>
+
+struct hwc_context_t;
+
+namespace qService {
+// ----------------------------------------------------------------------------
+
+class QService : public BnQService {
+public:
+    virtual ~QService();
+    virtual void securing(uint32_t startEnd);
+    virtual void unsecuring(uint32_t startEnd);
+    virtual void connect(const android::sp<qClient::IQClient>& client);
+    virtual android::status_t screenRefresh();
+    static void init();
+private:
+    QService();
+    android::sp<qClient::IQClient> mClient;
+    static QService *sQService;
+};
+}; // namespace qService
+#endif // ANDROID_QSERVICE_H
-- 
2.1.4

