From 1c7030d8cccf00b626598e344c6899f314abc668 Mon Sep 17 00:00:00 2001
From: Hamster Tian <haotia@gmail.com>
Date: Sat, 27 Aug 2016 11:03:04 +0800
Subject: [PATCH] Use wcnss_service from CM

Change-Id: I39a53bf1bcf88c0b51a693abe3d2d6cbb318994a
---
 qcwcn/wcnss-service/Android.mk         |  42 +++--
 qcwcn/wcnss-service/wcnss_qmi_client.c | 183 +++++++-----------
 qcwcn/wcnss-service/wcnss_service.c    | 332 ++++++++++++++++++++++++++++++++-
 3 files changed, 421 insertions(+), 136 deletions(-)

diff --git a/qcwcn/wcnss-service/Android.mk b/qcwcn/wcnss-service/Android.mk
index 39cdc57..aa06c38 100644
--- a/qcwcn/wcnss-service/Android.mk
+++ b/qcwcn/wcnss-service/Android.mk
@@ -1,27 +1,39 @@
-ifneq ($(filter msm8916 msm8909,$(TARGET_BOARD_PLATFORM)),)
 ifneq (,$(filter arm aarch64 arm64, $(TARGET_ARCH)))
+
 LOCAL_PATH := $(call my-dir)
+
 include $(CLEAR_VARS)
+
 LOCAL_MODULE := wcnss_service
 LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/common/inc/
 LOCAL_SRC_FILES := wcnss_service.c
-ifeq ($(strip $(TARGET_USES_QCOM_WCNSS_QMI)),true)
-LOCAL_CFLAGS += -DWCNSS_QMI
-LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/qmi/inc
-LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/qmi/services
-LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/qmi/platform
-LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/qmi/src
-LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/qmi/core/lib/inc
-LOCAL_SRC_FILES += wcnss_qmi_client.c
-endif #TARGET_USES_QCOM_WCNSS_QMI
 LOCAL_SHARED_LIBRARIES := libc libcutils libutils liblog
+
 ifeq ($(strip $(TARGET_USES_QCOM_WCNSS_QMI)),true)
-LOCAL_SHARED_LIBRARIES += libqmiservices libqmi libqcci_legacy libqmi_client_qmux
-LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/libmdmdetect/inc
-LOCAL_SHARED_LIBRARIES += libmdmdetect
+
+ifeq ($(TARGET_PROVIDES_WCNSS_QMI),true)
+LOCAL_CFLAGS += -DWCNSS_QMI_OSS
+LOCAL_SHARED_LIBRARIES += libdl
+else
+ifeq ($(TARGET_USES_WCNSS_MAC_ADDR_REV),true)
+LOCAL_CFLAGS += -DWCNSS_QMI_MAC_ADDR_REV
+endif
+
+ifneq ($(QCPATH),)
+LOCAL_CFLAGS += -DWCNSS_QMI
+LOCAL_SHARED_LIBRARIES += libwcnss_qmi
+else
+LOCAL_CFLAGS += -DWCNSS_QMI_OSS
+LOCAL_SHARED_LIBRARIES += libdl
+endif #QCPATH
+
+endif #TARGET_PROVIDES_WCNSS_QMI
+
 endif #TARGET_USES_QCOM_WCNSS_QMI
+
 LOCAL_MODULE_TAGS := optional
 LOCAL_CFLAGS += -Wall
+
 include $(BUILD_EXECUTABLE)
-endif
-endif # ifneq ($(filter msm8916 msm8909,$(TARGET_BOARD_PLATFORM)),)
+
+endif #TARGET_ARCH == arm
diff --git a/qcwcn/wcnss-service/wcnss_qmi_client.c b/qcwcn/wcnss-service/wcnss_qmi_client.c
index 28acce1..75242cd 100644
--- a/qcwcn/wcnss-service/wcnss_qmi_client.c
+++ b/qcwcn/wcnss-service/wcnss_qmi_client.c
@@ -29,11 +29,13 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifdef WCNSS_QMI
 #define LOG_TAG "wcnss_qmi"
 #include <cutils/log.h>
+#include <stdlib.h>
+#include <sys/stat.h>
 #include "wcnss_qmi_client.h"
-#include "qmi.h"
 #include "qmi_client.h"
 #include "device_management_service_v01.h"
 #include <cutils/properties.h>
+#include <string.h>
 
 #define SUCCESS 0
 #define FAILED -1
@@ -45,120 +47,23 @@ static qmi_client_type dms_qmi_client;
 static int qmi_handle;
 static int dms_init_done = FAILED;
 
-/* Android system property for fetching the modem type */
-#define QMI_UIM_PROPERTY_BASEBAND               "ro.baseband"
-
-/* Android system property values for various modem types */
-#define QMI_UIM_PROP_BASEBAND_VALUE_SVLTE_1     "svlte1"
-#define QMI_UIM_PROP_BASEBAND_VALUE_SVLTE_2A    "svlte2a"
-#define QMI_UIM_PROP_BASEBAND_VALUE_CSFB        "csfb"
-#define QMI_UIM_PROP_BASEBAND_VALUE_SGLTE       "sglte"
-#define QMI_UIM_PROP_BASEBAND_VALUE_SGLTE2      "sglte2"
-#define QMI_UIM_PROP_BASEBAND_VALUE_MSM         "msm"
-#define QMI_UIM_PROP_BASEBAND_VALUE_APQ         "apq"
-#define QMI_UIM_PROP_BASEBAND_VALUE_MDMUSB      "mdm"
-#define QMI_UIM_PROP_BASEBAND_VALUE_DSDA        "dsda"
-#define QMI_UIM_PROP_BASEBAND_VALUE_DSDA_2      "dsda2"
-
-static char *dms_find_modem_port( char *prop_value_ptr)
-{
-	char *qmi_modem_port_ptr = QMI_PORT_RMNET_0;
-
-	/* Sanity check */
-	if (prop_value_ptr == NULL) {
-		ALOGE("%s", "NULL prop_value_ptr, using default port",
-			__func__);
-		return qmi_modem_port_ptr;
-	}
-
-	ALOGE("%s: Baseband property value read: %s", __func__,
-			prop_value_ptr);
-
-	/* Map the port based on the read property */
-	if ((strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_SVLTE_1)  == 0) ||
-		(strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_SVLTE_2A) == 0) ||
-		(strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_CSFB) == 0)) {
-		qmi_modem_port_ptr = QMI_PORT_RMNET_SDIO_0;
-	} else if ((strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_MDMUSB) == 0) ||
-		(strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_SGLTE2) == 0)) {
-		qmi_modem_port_ptr = QMI_PORT_RMNET_USB_0;
-	} else if ((strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_MSM) == 0) ||
-		(strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_APQ) == 0) ||
-		(strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_SGLTE) == 0)) {
-		qmi_modem_port_ptr = QMI_PORT_RMNET_0;
-	} else if (strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_DSDA) == 0) {
-		/* If it is a DSDA configuration, use the existing API */
-		qmi_modem_port_ptr = (char *)QMI_PLATFORM_INTERNAL_USE_PORT_ID;
-	} else if (strcmp(prop_value_ptr,
-		QMI_UIM_PROP_BASEBAND_VALUE_DSDA_2) == 0) {
-		/* If it is a DSDA2 configuration, use the existing API */
-		qmi_modem_port_ptr = (char *)QMI_PLATFORM_INTERNAL_USE_PORT_ID;
-	} else {
-		ALOGE("%s: Property value does not match,using default port:%s",
-			__func__, qmi_modem_port_ptr);
-	}
-
-	ALOGE("%s: QMI port found for modem: %s", __func__, qmi_modem_port_ptr);
-
-	return qmi_modem_port_ptr;
-}
-
 int wcnss_init_qmi()
 {
 	qmi_client_error_type qmi_client_err;
 	qmi_idl_service_object_type dms_service;
-	char prop_value[PROPERTY_VALUE_MAX];
-	char *qmi_modem_port = NULL;
 
 	ALOGE("%s: Initialize wcnss QMI Interface", __func__);
+	qmi_client_os_params dms_os_params;
 
-	qmi_handle = qmi_init(NULL, NULL);
-	if (qmi_handle < 0) {
-		ALOGE("%s: Error while initializing qmi", __func__);
-		return FAILED;
-	}
-
-	dms_service = dms_get_service_object_v01();
-	if (dms_service == NULL) {
-		ALOGE("%s: Not able to get the service handle", __func__);
-		goto exit;
-	}
-
-	/* Find out the modem type */
-	memset(prop_value, 0x00, sizeof(prop_value));
-	property_get(QMI_UIM_PROPERTY_BASEBAND, prop_value, "");
+	memset(&dms_os_params, 0, sizeof(qmi_client_os_params));
+	qmi_client_err = qmi_client_init_instance(dms_get_service_object_v01(),
+			QMI_CLIENT_INSTANCE_ANY, NULL, NULL,
+			&dms_os_params, 5000, &dms_qmi_client);
 
-	/* Map to a respective QMI port */
-	qmi_modem_port = dms_find_modem_port(prop_value);
-	if (qmi_modem_port == NULL) {
-		ALOGE("%s: qmi_modem_port is NULL", __func__);
-		goto exit;
-	}
-
-	qmi_client_err = qmi_client_init((const char *)qmi_modem_port,
-			dms_service, NULL, dms_service, &dms_qmi_client);
-
-	if ((qmi_client_err == QMI_PORT_NOT_OPEN_ERR) &&
-			(strcmp(qmi_modem_port, QMI_PORT_RMNET_0) == 0)){
-		ALOGE("%s: Retrying with port RMNET_1: %d",
-				__func__, qmi_client_err);
-		qmi_modem_port = QMI_PORT_RMNET_1;
-		qmi_client_err = qmi_client_init((const char *)qmi_modem_port,
-			       dms_service, NULL, dms_service, &dms_qmi_client);
-	}
-
-	if (qmi_client_err != QMI_NO_ERR){
+	if(qmi_client_err != QMI_NO_ERR)
+	{
 		ALOGE("%s: Error while Initializing QMI Client: %d",
-			__func__, qmi_client_err);
+				__func__, qmi_client_err);
 		goto exit;
 	}
 
@@ -166,11 +71,6 @@ int wcnss_init_qmi()
 	return SUCCESS;
 
 exit:
-	qmi_handle = qmi_release(qmi_handle);
-	if ( qmi_handle < 0 )    {
-		ALOGE("%s: Error while releasing qmi %d",
-			 __func__, qmi_handle);
-	}
 	return FAILED;
 }
 
@@ -212,8 +112,63 @@ int wcnss_qmi_get_wlan_address(unsigned char *pBdAddr)
 		ALOGE("%s: Succesfully Read WLAN MAC Address", __func__);
 		return SUCCESS;
 	} else {
+#ifdef WCNSS_INVALID_MAC_PREFIX
+#ifndef WCNSS_GENMAC_FILE
+#define WCNSS_GENMAC_FILE "/persist/.genmac"
+#endif
+		int i = 0;
+		struct stat statbuf;
+		FILE *genmac;
+		int macbytes[6] = { 0, };
+		// Limit the prefix to 4 bytes, we want at least 2 to be random
+		int prefixlen = strnlen(WCNSS_INVALID_MAC_PREFIX,8)/2;
+
+		// Misconfigured device source...?
+		if (prefixlen < 2) {
+			return FAILED;
+		}
+
+		// Use a previously stored value if it exists
+		if (!stat(WCNSS_GENMAC_FILE, &statbuf)) {
+			genmac = fopen(WCNSS_GENMAC_FILE,"r");
+			if (fscanf(genmac, "%c%c%c%c%c%c", &pBdAddr[0],
+				     &pBdAddr[1], &pBdAddr[2], &pBdAddr[3],
+				     &pBdAddr[4], &pBdAddr[5]) == 6) {
+				fclose(genmac);
+				ALOGE("%s: Succesfully Read local WLAN MAC Address", __func__);
+				return SUCCESS;
+			}
+			fclose(genmac);
+		}
+
+		sscanf(WCNSS_INVALID_MAC_PREFIX, "%2x%2x%2x%2x",
+				&macbytes[0], &macbytes[1],
+				&macbytes[2], &macbytes[3]);
+
+		// We don't need strong randomness, and if the NV is corrupted
+		// any hardware values are suspect, so just seed it with the
+		// current time
+		srand(time(NULL));
+
+		for (i = prefixlen; i<6; i++) {
+			macbytes[i] = rand() % 255;
+		}
+		// Invert them
+		for (i = 0; i < 6; i++) {
+			pBdAddr[i] = macbytes[5-i];
+		}
+
+		// Store for reuse
+		genmac = fopen(WCNSS_GENMAC_FILE,"w");
+		fwrite(pBdAddr, 1, 6, genmac);
+		fclose(genmac);
+
+		ALOGE("%s: Failed to Read WLAN MAC Address, successfully randomized one", __func__);
+		return SUCCESS;
+#else
 		ALOGE("%s: Failed to Read WLAN MAC Address", __func__);
 		return FAILED;
+#endif
 	}
 }
 
@@ -235,12 +190,6 @@ void wcnss_qmi_deinit()
 			__func__, qmi_client_err);
 	}
 
-	qmi_handle = qmi_release(qmi_handle);
-	if (qmi_handle < 0)    {
-		ALOGE("%s: Error while releasing qmi %d",
-			__func__, qmi_handle);
-	}
-
 	dms_init_done = FAILED;
 }
 #endif
diff --git a/qcwcn/wcnss-service/wcnss_service.c b/qcwcn/wcnss-service/wcnss_service.c
index 9244ea0..b10c74b 100644
--- a/qcwcn/wcnss-service/wcnss_service.c
+++ b/qcwcn/wcnss-service/wcnss_service.c
@@ -27,6 +27,8 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 --------------------------------------------------------------------------*/
 
 #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <dirent.h>
@@ -40,8 +42,13 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <cutils/properties.h>
 #ifdef WCNSS_QMI
 #include "wcnss_qmi_client.h"
+#ifdef MDM_DETECT
 #include "mdm_detect.h"
 #endif
+#endif
+#ifdef WCNSS_QMI_OSS
+#include <dlfcn.h>
+#endif
 
 #define SUCCESS 0
 #define FAILED -1
@@ -77,10 +84,14 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define HEXA_A		10
 #define HEX_BASE		16
 
-#ifdef WCNSS_QMI
+#if defined (WCNSS_QMI) || defined(WCNSS_QMI_OSS)
 #define WLAN_ADDR_SIZE   6
 unsigned char wlan_nv_mac_addr[WLAN_ADDR_SIZE];
+#ifdef WCNSS_QMI_MAC_ADDR_REV
+#define MAC_ADDR_ARRAY(a) (a)[5], (a)[4], (a)[3], (a)[2], (a)[1], (a)[0]
+#else
 #define MAC_ADDR_ARRAY(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#endif
 #define MAC_ADDRESS_STR "%02x:%02x:%02x:%02x:%02x:%02x"
 
 /* As we Want to write in 00:0a:f5:11:22:33 format in sysfs file
@@ -89,6 +100,32 @@ unsigned char wlan_nv_mac_addr[WLAN_ADDR_SIZE];
 #define WLAN_MAC_ADDR_STRING 18
 #endif
 
+#define MAX_SOC_INFO_NAME_LEN (15)
+#define MAX_DATA_NVBIN_PATH_LEN (64)
+#define QRD_DYNAMIC_NV_PROP  "persist.sys.dynamic.nv"
+#define QRD_HW_PLATFORM  "QRD"
+#define QRD_PLATFORM_SUBTYPE_ID  0
+#define PERSIST_NVFILE    "/persist/WCNSS_qcom_wlan_nv.bin"
+#define DATA_NVFILE_DIR   "/data/misc/wifi/nvbin/"
+#define SYSFS_SOCID_PATH1   "/sys/devices/soc0/soc_id"
+#define SYSFS_SOCID_PATH2   "/sys/devices/system/soc/soc0/id"
+#define SYSFS_HW_PLATFORM_PATH1  "/sys/devices/soc0/hw_platform"
+#define SYSFS_HW_PLATFORM_PATH2   "/sys/devices/system/soc/soc0/hw_platform"
+#define SYSFS_PLATFORM_SUBTYPE_PATH1   "/sys/devices/soc0/platform_subtype_id"
+#define SYSFS_PLATFORM_SUBTYPE_PATH2    "/sys/devices/system/soc/soc0/platform_subtype_id"
+#define SYSFS_PLATFORM_VERSION_PATH1  "/sys/devices/soc0/platform_version"
+#define SYSFS_PLATFORM_VERSION_PATH2   "/sys/devices/system/soc/soc0/platform_version"
+#define SOCINFO_HWVER_MAJOR(ver) (((ver) & 0x00ff0000) >> 16)
+#define SOCINFO_HWVER_MINOR(ver) ((ver) & 0x000000ff)
+#define GET_SOC_INFO(buf, soc_node_path1, soc_node_path2, info_got) \
+		{  if (get_soc_info(buf, soc_node_path1, soc_node_path2) < 0) \
+		    { \
+		        ALOGE("get_soc_info failed!\n"); \
+		        return FAILED; \
+		    } \
+		    info_got = atoi(buf); \
+		}
+
 int wcnss_write_cal_data(int fd_dev)
 {
 	int rcount = 0;
@@ -393,18 +430,27 @@ void setup_wcnss_parameters(int *cal, int nv_mac_addr)
 		}
 	}
 
-#ifdef WCNSS_QMI
+#if defined(WCNSS_QMI) || defined (WCNSS_QMI_OSS)
 	if (SUCCESS == nv_mac_addr)
 	{
 		pos = 0;
 		msg[pos++] = WCNSS_USR_WLAN_MAC_ADDR >> BYTE_1;
 		msg[pos++] = WCNSS_USR_WLAN_MAC_ADDR >> BYTE_0;
+#ifdef WCNSS_QMI_MAC_ADDR_REV
+		msg[pos++] = wlan_nv_mac_addr[5];
+		msg[pos++] = wlan_nv_mac_addr[4];
+		msg[pos++] = wlan_nv_mac_addr[3];
+		msg[pos++] = wlan_nv_mac_addr[2];
+		msg[pos++] = wlan_nv_mac_addr[1];
+		msg[pos++] = wlan_nv_mac_addr[0];
+#else
 		msg[pos++] = wlan_nv_mac_addr[0];
 		msg[pos++] = wlan_nv_mac_addr[1];
 		msg[pos++] = wlan_nv_mac_addr[2];
 		msg[pos++] = wlan_nv_mac_addr[3];
 		msg[pos++] = wlan_nv_mac_addr[4];
 		msg[pos++] = wlan_nv_mac_addr[5];
+#endif
 
 		ALOGI("WLAN MAC Addr:" MAC_ADDRESS_STR,
 			MAC_ADDR_ARRAY(wlan_nv_mac_addr));
@@ -465,7 +511,7 @@ void setup_wlan_driver_ath_prop()
 	property_set("wlan.driver.ath", WLAN_DRIVER_ATH_DEFAULT_VAL);
 }
 
-#ifdef WCNSS_QMI
+#ifdef MDM_DETECT
 int check_modem_compatability(struct dev_info *mdm_detect_info)
 {
 	char args[MODEM_BASEBAND_PROPERTY_SIZE] = {0};
@@ -495,23 +541,293 @@ int check_modem_compatability(struct dev_info *mdm_detect_info)
 }
 #endif
 
+#ifdef WCNSS_QMI_OSS
+static void *wcnss_qmi_handle = NULL;
+static int (*wcnss_init_qmi)(void) = NULL;
+static int (*wcnss_qmi_get_wlan_address)(unsigned char *) = NULL;
+static void (*wcnss_qmi_deinit)(void) = NULL;
+
+static int setup_wcnss_qmi(void)
+{
+	const char *error = NULL;
+
+	/* initialize the DMS client and request the wlan mac address */
+	wcnss_qmi_handle = dlopen("libwcnss_qmi.so", RTLD_NOW);
+	if (!wcnss_qmi_handle) {
+		ALOGE("Failed to open libwcnss_qmi.so: %s", dlerror());
+		goto dlopen_err;
+	}
+
+	dlerror();
+
+	wcnss_init_qmi = dlsym(wcnss_qmi_handle, "wcnss_init_qmi");
+	if ((error = dlerror()) != NULL) {
+		ALOGE("Failed to resolve function: %s: %s",
+				"wcnss_init_qmi", error);
+		goto dlsym_err;
+	}
+
+	dlerror();
+
+	wcnss_qmi_get_wlan_address = dlsym(wcnss_qmi_handle,
+			"wcnss_qmi_get_wlan_address");
+	if ((error = dlerror()) != NULL) {
+		ALOGE("Failed to resolve function: %s: %s",
+				"wcnss_qmi_get_wlan_address", error);
+		goto dlsym_err;
+	}
+
+	dlerror();
+
+	wcnss_qmi_deinit = dlsym(wcnss_qmi_handle, "wcnss_qmi_deinit");
+	if ((error = dlerror()) != NULL) {
+		ALOGE("Failed to resolve function: %s: %s",
+				"wcnss_qmi_deinit", error);
+		goto dlsym_err;
+	}
+
+	return SUCCESS;
+
+dlsym_err:
+	dlclose(wcnss_qmi_handle);
+dlopen_err:
+	return FAILED;
+}
+#endif
+
+static int read_line_from_file(const char *path, char *buf, size_t count)
+{
+	char * fgets_ret;
+	FILE * fd;
+	int rv;
+
+	fd = fopen(path, "r");
+	if (fd == NULL)
+	return -1;
+
+	fgets_ret = fgets(buf, (int)count, fd);
+	if (NULL != fgets_ret) {
+	    rv = (int)strlen(buf);
+	} else {
+	    rv = ferror(fd);
+	}
+
+	fclose(fd);
+
+	return rv;
+}
+
+static int get_soc_info(char *buf, char *soc_node_path1,
+			char *soc_node_path2)
+{
+	int ret = 0;
+
+	ret = read_line_from_file(soc_node_path1, buf,
+					MAX_SOC_INFO_NAME_LEN);
+	if (ret < 0) {
+		ret = read_line_from_file(soc_node_path2, buf,
+					MAX_SOC_INFO_NAME_LEN);
+		if (ret < 0) {
+		    ALOGE("getting socinfo(%s, %d) failed.\n",
+					soc_node_path1, ret);
+		    return ret;
+		}
+	}
+	if (ret && buf[ret - 1] == '\n')
+		buf[ret - 1] = '\0';
+
+	return ret;
+}
+
+static int get_data_nvfile_path(char *data_nvfile_path,
+	struct stat *pdata_nvfile_stat)
+{
+	char target_board_platform[PROP_VALUE_MAX] = {'\0'};
+	char buf[MAX_SOC_INFO_NAME_LEN] = {'\0'};
+	int  soc_id, platform_subtype_id, platform_version;
+	int  major_hwver, minor_hwver;
+	int  rc;
+
+	rc = property_get("ro.board.platform", target_board_platform, "");
+	if (!rc)
+	{
+		ALOGE("get ro.board.platform fail, rc=%d(%s)\n",
+				rc, strerror(errno));
+		return FAILED;
+	}
+
+	GET_SOC_INFO(buf, SYSFS_SOCID_PATH1, SYSFS_SOCID_PATH2, soc_id);
+	GET_SOC_INFO(buf, SYSFS_PLATFORM_SUBTYPE_PATH1,
+			SYSFS_PLATFORM_SUBTYPE_PATH2, platform_subtype_id);
+	GET_SOC_INFO(buf, SYSFS_PLATFORM_VERSION_PATH1,
+			SYSFS_PLATFORM_VERSION_PATH2, platform_version);
+
+	major_hwver = SOCINFO_HWVER_MAJOR(platform_version);
+	minor_hwver = SOCINFO_HWVER_MINOR(platform_version);
+
+	snprintf(data_nvfile_path, MAX_DATA_NVBIN_PATH_LEN,
+		"%s%s_%d_0x%02x_0x%02x_0x%02x_nv.bin", DATA_NVFILE_DIR,
+		target_board_platform, soc_id, platform_subtype_id&0xff,
+		major_hwver&0xff, minor_hwver&0xff);
+	ALOGI("data_nvfile_path %s\n",
+			data_nvfile_path);
+
+	if (stat(data_nvfile_path, pdata_nvfile_stat) != 0)
+	{
+		ALOGE("source file do not exist %s\n",
+				data_nvfile_path);
+		return FAILED;
+	}
+
+	return SUCCESS;
+}
+
+static int nvbin_sendfile(const char *dst, const char *src,
+	struct stat *src_stat)
+{
+	struct utimbuf new_time;
+	int fp_src, fp_dst;
+	int rc;
+	if ((fp_src = open(src, O_RDONLY)) < 0)
+	{
+		ALOGE("open %s failed(%s).\n",
+				src, strerror(errno));
+		return FAILED;
+	}
+
+	if ((fp_dst = open(dst, O_WRONLY |O_TRUNC)) < 0)
+	{
+		close(fp_src);
+		ALOGE("open %s failed(%s).\n",
+				dst, strerror(errno));
+		return FAILED;
+	}
+
+	if (sendfile(fp_dst, fp_src, 0, src_stat->st_size) == -1)
+	{
+		ALOGE("dynamic nv sendfile failed.size:%ld (%s).\n",
+				src_stat->st_size, strerror(errno));
+		rc = FAILED;
+		goto exit;
+	}
+
+	new_time.actime  = src_stat->st_atime;
+	new_time.modtime = src_stat->st_mtime;
+	if (utime(dst, &new_time) != 0)
+	{
+		ALOGE("could not preserve the timestamp %s",
+				strerror(errno));
+		rc = FAILED;
+		goto exit;
+	}
+
+	rc = SUCCESS;
+exit:
+	close(fp_dst);
+	close(fp_src);
+	return rc;
+}
+void dynamic_nv_replace()
+{
+	char data_nvfile_path[MAX_DATA_NVBIN_PATH_LEN] = {'\0'};
+	char property_nv_replaced_status [PROPERTY_VALUE_MAX] = { '\0' };
+	char buf[MAX_SOC_INFO_NAME_LEN] = {'\0'};
+	struct stat  data_nvfile_stat;
+	int rc;
+
+	if (property_get(QRD_DYNAMIC_NV_PROP, property_nv_replaced_status, NULL)
+		&& strcmp(property_nv_replaced_status, "done") == 0) {
+		ALOGI("dynamic nv have been replaced. leave\n");
+		return;
+	}
+
+	rc = get_soc_info(buf, SYSFS_HW_PLATFORM_PATH1, SYSFS_HW_PLATFORM_PATH2);
+	if (rc < 0)
+	{
+		ALOGE("get_soc_info(HW_PLATFORM) fail!\n");
+		return;
+	} else {
+		if( 0 != strncmp(buf, QRD_HW_PLATFORM, MAX_SOC_INFO_NAME_LEN))
+		{
+			ALOGI("dynamic nv only for QRD platform, current platform:%s.\n",
+					buf);
+			return;
+		}
+	}
+
+	rc = get_data_nvfile_path(data_nvfile_path, &data_nvfile_stat);
+	if (rc != SUCCESS)
+	{
+		ALOGE("Get source file path fail !\n");
+		return;
+	}
+
+	if (property_set(QRD_DYNAMIC_NV_PROP, "replacing") < 0)
+	{
+		ALOGE("set %s to replacing failed (%s).\n",
+				QRD_DYNAMIC_NV_PROP, strerror(errno));
+		return;
+	}
+
+	rc = nvbin_sendfile(PERSIST_NVFILE, data_nvfile_path, &data_nvfile_stat);
+	if ( rc != SUCCESS)
+	{
+		ALOGE("nvbin_sendfile failed.\n");
+		return;
+	}
+
+	if (property_set(QRD_DYNAMIC_NV_PROP, "done") < 0)
+	{
+		ALOGE("set %s to done failed(%s).\n",
+				QRD_DYNAMIC_NV_PROP, strerror(errno));
+		return;
+	}
+
+	ALOGI("dynamic nv replace sucessfully!\n");
+
+}
+
 int main(int argc, char *argv[])
 {
 	int rc;
 	int fd_dev, ret_cal;
 	int nv_mac_addr = FAILED;
 #ifdef WCNSS_QMI
+#ifdef MDM_DETECT
 	struct dev_info mdm_detect_info;
+#endif
 	int nom = 0;
 #endif
 
 	setup_wlan_config_file();
 
+#ifdef WCNSS_QMI_OSS
+	/* dlopen WCNSS QMI lib */
+
+	rc = setup_wcnss_qmi();
+	if (rc == SUCCESS) {
+		if (SUCCESS == (*wcnss_init_qmi)()) {
+			rc = (*wcnss_qmi_get_wlan_address)(wlan_nv_mac_addr);
+			if (rc == SUCCESS) {
+				nv_mac_addr = SUCCESS;
+				ALOGE("WLAN MAC Addr:" MAC_ADDRESS_STR,
+						MAC_ADDR_ARRAY(wlan_nv_mac_addr));
+			} else
+				ALOGE("Failed to Get MAC addr from modem");
+
+			(*wcnss_qmi_deinit)();
+		}
+		else
+			ALOGE("Failed to Initialize wcnss QMI Interface");
+	} else {
+		ALOGE("Failed to Initialize wcnss QMI interface library");
+	}
+#endif
 #ifdef WCNSS_QMI
 	/* Call ESOC API to get the number of modems.
 	   If the number of modems is not zero, only then proceed
 	   with the eap_proxy intialization.*/
-
+#ifdef MDM_DETECT
 	nom = get_system_info(&mdm_detect_info);
 
 	if (nom > 0)
@@ -529,6 +845,7 @@ int main(int argc, char *argv[])
 		ALOGE("wcnss_service: Target does not have external modem");
 		goto nomodem;
 	}
+#endif
 
 	/* initialize the DMS client and request the wlan mac address */
 
@@ -550,6 +867,9 @@ int main(int argc, char *argv[])
 
 nomodem:
 #endif
+
+	dynamic_nv_replace();
+
 	setup_wcnss_parameters(&ret_cal, nv_mac_addr);
 
 	fd_dev = open(WCNSS_DEVICE, O_RDWR);
@@ -578,5 +898,9 @@ nomodem:
 
 	close(fd_dev);
 
+#ifdef WCNSS_QMI_OSS
+	dlclose(wcnss_qmi_handle);
+#endif
+
 	return rc;
 }
-- 
2.1.4

